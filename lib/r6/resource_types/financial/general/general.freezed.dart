// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'general.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

Account _$AccountFromJson(Map<String, dynamic> json) {
  return _Account.fromJson(json);
}

/// @nodoc
mixin _$Account {
  /// [resourceType] This is a Account resource
  @JsonKey(unknownEnumValue: R6ResourceType.Account)
  R6ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  FhirMeta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  FhirCode? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Unique identifier used to reference the account.  Might or
  ///  might not be intended for human use (e.g. credit card number).
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [status] Indicates whether the account is presently used/usable or not.
  FhirCode? get status => throw _privateConstructorUsedError;

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement => throw _privateConstructorUsedError;

  /// [billingStatus] The BillingStatus tracks the lifecycle of the account
  ///  through the billing process. It indicates how transactions are treated
  ///  when they are allocated to the account.
  CodeableConcept? get billingStatus => throw _privateConstructorUsedError;

  /// [type] Categorizes the account for reporting and searching purposes.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [name] Name used for the account when displaying it to humans in
  ///  reports, etc.
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [subject] Identifies the entity which incurs the expenses. While the
  ///  immediate recipients of services or goods might be entities related to
  ///  the subject, the expenses were ultimately incurred by the subject of
  ///  the Account.
  List<Reference>? get subject => throw _privateConstructorUsedError;

  /// [servicePeriod] The date range of services associated with this account.
  Period? get servicePeriod => throw _privateConstructorUsedError;

  /// [covers] An account that collects the charges for a specific set of
  ///  services offered over a limited time period.  For example, a hospital
  ///  account might contain all charges related to a given admission,
  ///  including any inpatient appointments, and possibly re-admissions, of
  ///  the billing for those re-admissions should be grouped with the initial
  ///  admission for the purpose of claim submission.
  List<Reference>? get covers => throw _privateConstructorUsedError;

  /// [coverage] The party(s) that are responsible for covering the payment
  ///  of this account, and what order should they be applied to the account.
  List<AccountCoverage>? get coverage => throw _privateConstructorUsedError;

  /// [owner] Indicates the service area, hospital, department, etc. with
  ///  responsibility for managing the Account.
  Reference? get owner => throw _privateConstructorUsedError;

  /// [description] Provides additional information about what the account
  ///  tracks and how it is used.
  FhirMarkdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [guarantor] The parties responsible for balancing the account if other
  ///  payment options fall short.
  List<AccountGuarantor>? get guarantor => throw _privateConstructorUsedError;

  /// [diagnosis] When using an account for billing a specific Encounter the
  ///  set of diagnoses that are relevant for billing are stored here on the
  ///  account where they are able to be sequenced appropriately prior to
  ///  processing to produce claim(s).
  List<AccountDiagnosis>? get diagnosis => throw _privateConstructorUsedError;

  /// [procedure] When using an account for billing a specific Encounter the
  ///  set of procedures that are relevant for billing are stored here on the
  ///  account where they are able to be sequenced appropriately prior to
  ///  processing to produce claim(s).
  List<AccountProcedure>? get procedure => throw _privateConstructorUsedError;

  /// [relatedAccount] Other associated accounts related to this account.
  List<AccountRelatedAccount>? get relatedAccount =>
      throw _privateConstructorUsedError;

  /// [currency] The default currency for the account.
  CodeableConcept? get currency => throw _privateConstructorUsedError;

  /// [balance] The calculated account balances - these are calculated and
  ///  processed by the finance system. The balances with a `term` that is
  ///  not current are usually generated/updated by an invoicing or similar
  ///  process.
  List<AccountBalance>? get balance => throw _privateConstructorUsedError;

  /// [calculatedAt] Time the balance amount was calculated.
  FhirInstant? get calculatedAt => throw _privateConstructorUsedError;

  /// [calculatedAtElement] ("_calculatedAt") Extensions for calculatedAt
  @JsonKey(name: '_calculatedAt')
  Element? get calculatedAtElement => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AccountCopyWith<Account> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountCopyWith<$Res> {
  factory $AccountCopyWith(Account value, $Res Function(Account) then) =
      _$AccountCopyWithImpl<$Res, Account>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.Account)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      FhirCode? status,
      @JsonKey(name: '_status') Element? statusElement,
      CodeableConcept? billingStatus,
      CodeableConcept? type,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      List<Reference>? subject,
      Period? servicePeriod,
      List<Reference>? covers,
      List<AccountCoverage>? coverage,
      Reference? owner,
      FhirMarkdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      List<AccountGuarantor>? guarantor,
      List<AccountDiagnosis>? diagnosis,
      List<AccountProcedure>? procedure,
      List<AccountRelatedAccount>? relatedAccount,
      CodeableConcept? currency,
      List<AccountBalance>? balance,
      FhirInstant? calculatedAt,
      @JsonKey(name: '_calculatedAt') Element? calculatedAtElement});

  $FhirMetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get statusElement;
  $CodeableConceptCopyWith<$Res>? get billingStatus;
  $CodeableConceptCopyWith<$Res>? get type;
  $ElementCopyWith<$Res>? get nameElement;
  $PeriodCopyWith<$Res>? get servicePeriod;
  $ReferenceCopyWith<$Res>? get owner;
  $ElementCopyWith<$Res>? get descriptionElement;
  $CodeableConceptCopyWith<$Res>? get currency;
  $ElementCopyWith<$Res>? get calculatedAtElement;
}

/// @nodoc
class _$AccountCopyWithImpl<$Res, $Val extends Account>
    implements $AccountCopyWith<$Res> {
  _$AccountCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? billingStatus = freezed,
    Object? type = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? subject = freezed,
    Object? servicePeriod = freezed,
    Object? covers = freezed,
    Object? coverage = freezed,
    Object? owner = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? guarantor = freezed,
    Object? diagnosis = freezed,
    Object? procedure = freezed,
    Object? relatedAccount = freezed,
    Object? currency = freezed,
    Object? balance = freezed,
    Object? calculatedAt = freezed,
    Object? calculatedAtElement = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      billingStatus: freezed == billingStatus
          ? _value.billingStatus
          : billingStatus // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      subject: freezed == subject
          ? _value.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      servicePeriod: freezed == servicePeriod
          ? _value.servicePeriod
          : servicePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      covers: freezed == covers
          ? _value.covers
          : covers // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      coverage: freezed == coverage
          ? _value.coverage
          : coverage // ignore: cast_nullable_to_non_nullable
              as List<AccountCoverage>?,
      owner: freezed == owner
          ? _value.owner
          : owner // ignore: cast_nullable_to_non_nullable
              as Reference?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as FhirMarkdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      guarantor: freezed == guarantor
          ? _value.guarantor
          : guarantor // ignore: cast_nullable_to_non_nullable
              as List<AccountGuarantor>?,
      diagnosis: freezed == diagnosis
          ? _value.diagnosis
          : diagnosis // ignore: cast_nullable_to_non_nullable
              as List<AccountDiagnosis>?,
      procedure: freezed == procedure
          ? _value.procedure
          : procedure // ignore: cast_nullable_to_non_nullable
              as List<AccountProcedure>?,
      relatedAccount: freezed == relatedAccount
          ? _value.relatedAccount
          : relatedAccount // ignore: cast_nullable_to_non_nullable
              as List<AccountRelatedAccount>?,
      currency: freezed == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      balance: freezed == balance
          ? _value.balance
          : balance // ignore: cast_nullable_to_non_nullable
              as List<AccountBalance>?,
      calculatedAt: freezed == calculatedAt
          ? _value.calculatedAt
          : calculatedAt // ignore: cast_nullable_to_non_nullable
              as FhirInstant?,
      calculatedAtElement: freezed == calculatedAtElement
          ? _value.calculatedAtElement
          : calculatedAtElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FhirMetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $FhirMetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusElement {
    if (_value.statusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusElement!, (value) {
      return _then(_value.copyWith(statusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get billingStatus {
    if (_value.billingStatus == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.billingStatus!, (value) {
      return _then(_value.copyWith(billingStatus: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get servicePeriod {
    if (_value.servicePeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.servicePeriod!, (value) {
      return _then(_value.copyWith(servicePeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get owner {
    if (_value.owner == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.owner!, (value) {
      return _then(_value.copyWith(owner: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get currency {
    if (_value.currency == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.currency!, (value) {
      return _then(_value.copyWith(currency: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get calculatedAtElement {
    if (_value.calculatedAtElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.calculatedAtElement!, (value) {
      return _then(_value.copyWith(calculatedAtElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AccountImplCopyWith<$Res> implements $AccountCopyWith<$Res> {
  factory _$$AccountImplCopyWith(
          _$AccountImpl value, $Res Function(_$AccountImpl) then) =
      __$$AccountImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.Account)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      FhirCode? status,
      @JsonKey(name: '_status') Element? statusElement,
      CodeableConcept? billingStatus,
      CodeableConcept? type,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      List<Reference>? subject,
      Period? servicePeriod,
      List<Reference>? covers,
      List<AccountCoverage>? coverage,
      Reference? owner,
      FhirMarkdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      List<AccountGuarantor>? guarantor,
      List<AccountDiagnosis>? diagnosis,
      List<AccountProcedure>? procedure,
      List<AccountRelatedAccount>? relatedAccount,
      CodeableConcept? currency,
      List<AccountBalance>? balance,
      FhirInstant? calculatedAt,
      @JsonKey(name: '_calculatedAt') Element? calculatedAtElement});

  @override
  $FhirMetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get statusElement;
  @override
  $CodeableConceptCopyWith<$Res>? get billingStatus;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $PeriodCopyWith<$Res>? get servicePeriod;
  @override
  $ReferenceCopyWith<$Res>? get owner;
  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get currency;
  @override
  $ElementCopyWith<$Res>? get calculatedAtElement;
}

/// @nodoc
class __$$AccountImplCopyWithImpl<$Res>
    extends _$AccountCopyWithImpl<$Res, _$AccountImpl>
    implements _$$AccountImplCopyWith<$Res> {
  __$$AccountImplCopyWithImpl(
      _$AccountImpl _value, $Res Function(_$AccountImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? billingStatus = freezed,
    Object? type = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? subject = freezed,
    Object? servicePeriod = freezed,
    Object? covers = freezed,
    Object? coverage = freezed,
    Object? owner = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? guarantor = freezed,
    Object? diagnosis = freezed,
    Object? procedure = freezed,
    Object? relatedAccount = freezed,
    Object? currency = freezed,
    Object? balance = freezed,
    Object? calculatedAt = freezed,
    Object? calculatedAtElement = freezed,
  }) {
    return _then(_$AccountImpl(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      billingStatus: freezed == billingStatus
          ? _value.billingStatus
          : billingStatus // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      subject: freezed == subject
          ? _value._subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      servicePeriod: freezed == servicePeriod
          ? _value.servicePeriod
          : servicePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      covers: freezed == covers
          ? _value._covers
          : covers // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      coverage: freezed == coverage
          ? _value._coverage
          : coverage // ignore: cast_nullable_to_non_nullable
              as List<AccountCoverage>?,
      owner: freezed == owner
          ? _value.owner
          : owner // ignore: cast_nullable_to_non_nullable
              as Reference?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as FhirMarkdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      guarantor: freezed == guarantor
          ? _value._guarantor
          : guarantor // ignore: cast_nullable_to_non_nullable
              as List<AccountGuarantor>?,
      diagnosis: freezed == diagnosis
          ? _value._diagnosis
          : diagnosis // ignore: cast_nullable_to_non_nullable
              as List<AccountDiagnosis>?,
      procedure: freezed == procedure
          ? _value._procedure
          : procedure // ignore: cast_nullable_to_non_nullable
              as List<AccountProcedure>?,
      relatedAccount: freezed == relatedAccount
          ? _value._relatedAccount
          : relatedAccount // ignore: cast_nullable_to_non_nullable
              as List<AccountRelatedAccount>?,
      currency: freezed == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      balance: freezed == balance
          ? _value._balance
          : balance // ignore: cast_nullable_to_non_nullable
              as List<AccountBalance>?,
      calculatedAt: freezed == calculatedAt
          ? _value.calculatedAt
          : calculatedAt // ignore: cast_nullable_to_non_nullable
              as FhirInstant?,
      calculatedAtElement: freezed == calculatedAtElement
          ? _value.calculatedAtElement
          : calculatedAtElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AccountImpl extends _Account {
  const _$AccountImpl(
      {@JsonKey(unknownEnumValue: R6ResourceType.Account)
      this.resourceType = R6ResourceType.Account,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.status,
      @JsonKey(name: '_status') this.statusElement,
      this.billingStatus,
      this.type,
      this.name,
      @JsonKey(name: '_name') this.nameElement,
      final List<Reference>? subject,
      this.servicePeriod,
      final List<Reference>? covers,
      final List<AccountCoverage>? coverage,
      this.owner,
      this.description,
      @JsonKey(name: '_description') this.descriptionElement,
      final List<AccountGuarantor>? guarantor,
      final List<AccountDiagnosis>? diagnosis,
      final List<AccountProcedure>? procedure,
      final List<AccountRelatedAccount>? relatedAccount,
      this.currency,
      final List<AccountBalance>? balance,
      this.calculatedAt,
      @JsonKey(name: '_calculatedAt') this.calculatedAtElement})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _subject = subject,
        _covers = covers,
        _coverage = coverage,
        _guarantor = guarantor,
        _diagnosis = diagnosis,
        _procedure = procedure,
        _relatedAccount = relatedAccount,
        _balance = balance,
        super._();

  factory _$AccountImpl.fromJson(Map<String, dynamic> json) =>
      _$$AccountImplFromJson(json);

  /// [resourceType] This is a Account resource
  @override
  @JsonKey(unknownEnumValue: R6ResourceType.Account)
  final R6ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  @override
  final FhirMeta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final FhirCode? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Unique identifier used to reference the account.  Might or
  ///  might not be intended for human use (e.g. credit card number).
  final List<Identifier>? _identifier;

  /// [identifier] Unique identifier used to reference the account.  Might or
  ///  might not be intended for human use (e.g. credit card number).
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] Indicates whether the account is presently used/usable or not.
  @override
  final FhirCode? status;

  /// [statusElement] ("_status") Extensions for status
  @override
  @JsonKey(name: '_status')
  final Element? statusElement;

  /// [billingStatus] The BillingStatus tracks the lifecycle of the account
  ///  through the billing process. It indicates how transactions are treated
  ///  when they are allocated to the account.
  @override
  final CodeableConcept? billingStatus;

  /// [type] Categorizes the account for reporting and searching purposes.
  @override
  final CodeableConcept? type;

  /// [name] Name used for the account when displaying it to humans in
  ///  reports, etc.
  @override
  final String? name;

  /// [nameElement] ("_name") Extensions for name
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [subject] Identifies the entity which incurs the expenses. While the
  ///  immediate recipients of services or goods might be entities related to
  ///  the subject, the expenses were ultimately incurred by the subject of
  ///  the Account.
  final List<Reference>? _subject;

  /// [subject] Identifies the entity which incurs the expenses. While the
  ///  immediate recipients of services or goods might be entities related to
  ///  the subject, the expenses were ultimately incurred by the subject of
  ///  the Account.
  @override
  List<Reference>? get subject {
    final value = _subject;
    if (value == null) return null;
    if (_subject is EqualUnmodifiableListView) return _subject;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [servicePeriod] The date range of services associated with this account.
  @override
  final Period? servicePeriod;

  /// [covers] An account that collects the charges for a specific set of
  ///  services offered over a limited time period.  For example, a hospital
  ///  account might contain all charges related to a given admission,
  ///  including any inpatient appointments, and possibly re-admissions, of
  ///  the billing for those re-admissions should be grouped with the initial
  ///  admission for the purpose of claim submission.
  final List<Reference>? _covers;

  /// [covers] An account that collects the charges for a specific set of
  ///  services offered over a limited time period.  For example, a hospital
  ///  account might contain all charges related to a given admission,
  ///  including any inpatient appointments, and possibly re-admissions, of
  ///  the billing for those re-admissions should be grouped with the initial
  ///  admission for the purpose of claim submission.
  @override
  List<Reference>? get covers {
    final value = _covers;
    if (value == null) return null;
    if (_covers is EqualUnmodifiableListView) return _covers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [coverage] The party(s) that are responsible for covering the payment
  ///  of this account, and what order should they be applied to the account.
  final List<AccountCoverage>? _coverage;

  /// [coverage] The party(s) that are responsible for covering the payment
  ///  of this account, and what order should they be applied to the account.
  @override
  List<AccountCoverage>? get coverage {
    final value = _coverage;
    if (value == null) return null;
    if (_coverage is EqualUnmodifiableListView) return _coverage;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [owner] Indicates the service area, hospital, department, etc. with
  ///  responsibility for managing the Account.
  @override
  final Reference? owner;

  /// [description] Provides additional information about what the account
  ///  tracks and how it is used.
  @override
  final FhirMarkdown? description;

  /// [descriptionElement] ("_description") Extensions for description
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [guarantor] The parties responsible for balancing the account if other
  ///  payment options fall short.
  final List<AccountGuarantor>? _guarantor;

  /// [guarantor] The parties responsible for balancing the account if other
  ///  payment options fall short.
  @override
  List<AccountGuarantor>? get guarantor {
    final value = _guarantor;
    if (value == null) return null;
    if (_guarantor is EqualUnmodifiableListView) return _guarantor;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [diagnosis] When using an account for billing a specific Encounter the
  ///  set of diagnoses that are relevant for billing are stored here on the
  ///  account where they are able to be sequenced appropriately prior to
  ///  processing to produce claim(s).
  final List<AccountDiagnosis>? _diagnosis;

  /// [diagnosis] When using an account for billing a specific Encounter the
  ///  set of diagnoses that are relevant for billing are stored here on the
  ///  account where they are able to be sequenced appropriately prior to
  ///  processing to produce claim(s).
  @override
  List<AccountDiagnosis>? get diagnosis {
    final value = _diagnosis;
    if (value == null) return null;
    if (_diagnosis is EqualUnmodifiableListView) return _diagnosis;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [procedure] When using an account for billing a specific Encounter the
  ///  set of procedures that are relevant for billing are stored here on the
  ///  account where they are able to be sequenced appropriately prior to
  ///  processing to produce claim(s).
  final List<AccountProcedure>? _procedure;

  /// [procedure] When using an account for billing a specific Encounter the
  ///  set of procedures that are relevant for billing are stored here on the
  ///  account where they are able to be sequenced appropriately prior to
  ///  processing to produce claim(s).
  @override
  List<AccountProcedure>? get procedure {
    final value = _procedure;
    if (value == null) return null;
    if (_procedure is EqualUnmodifiableListView) return _procedure;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [relatedAccount] Other associated accounts related to this account.
  final List<AccountRelatedAccount>? _relatedAccount;

  /// [relatedAccount] Other associated accounts related to this account.
  @override
  List<AccountRelatedAccount>? get relatedAccount {
    final value = _relatedAccount;
    if (value == null) return null;
    if (_relatedAccount is EqualUnmodifiableListView) return _relatedAccount;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [currency] The default currency for the account.
  @override
  final CodeableConcept? currency;

  /// [balance] The calculated account balances - these are calculated and
  ///  processed by the finance system. The balances with a `term` that is
  ///  not current are usually generated/updated by an invoicing or similar
  ///  process.
  final List<AccountBalance>? _balance;

  /// [balance] The calculated account balances - these are calculated and
  ///  processed by the finance system. The balances with a `term` that is
  ///  not current are usually generated/updated by an invoicing or similar
  ///  process.
  @override
  List<AccountBalance>? get balance {
    final value = _balance;
    if (value == null) return null;
    if (_balance is EqualUnmodifiableListView) return _balance;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [calculatedAt] Time the balance amount was calculated.
  @override
  final FhirInstant? calculatedAt;

  /// [calculatedAtElement] ("_calculatedAt") Extensions for calculatedAt
  @override
  @JsonKey(name: '_calculatedAt')
  final Element? calculatedAtElement;

  @override
  String toString() {
    return 'Account(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, status: $status, statusElement: $statusElement, billingStatus: $billingStatus, type: $type, name: $name, nameElement: $nameElement, subject: $subject, servicePeriod: $servicePeriod, covers: $covers, coverage: $coverage, owner: $owner, description: $description, descriptionElement: $descriptionElement, guarantor: $guarantor, diagnosis: $diagnosis, procedure: $procedure, relatedAccount: $relatedAccount, currency: $currency, balance: $balance, calculatedAt: $calculatedAt, calculatedAtElement: $calculatedAtElement)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountImpl &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusElement, statusElement) ||
                other.statusElement == statusElement) &&
            (identical(other.billingStatus, billingStatus) ||
                other.billingStatus == billingStatus) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            const DeepCollectionEquality().equals(other._subject, _subject) &&
            (identical(other.servicePeriod, servicePeriod) ||
                other.servicePeriod == servicePeriod) &&
            const DeepCollectionEquality().equals(other._covers, _covers) &&
            const DeepCollectionEquality().equals(other._coverage, _coverage) &&
            (identical(other.owner, owner) || other.owner == owner) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            const DeepCollectionEquality()
                .equals(other._guarantor, _guarantor) &&
            const DeepCollectionEquality()
                .equals(other._diagnosis, _diagnosis) &&
            const DeepCollectionEquality()
                .equals(other._procedure, _procedure) &&
            const DeepCollectionEquality()
                .equals(other._relatedAccount, _relatedAccount) &&
            (identical(other.currency, currency) ||
                other.currency == currency) &&
            const DeepCollectionEquality().equals(other._balance, _balance) &&
            (identical(other.calculatedAt, calculatedAt) ||
                other.calculatedAt == calculatedAt) &&
            (identical(other.calculatedAtElement, calculatedAtElement) ||
                other.calculatedAtElement == calculatedAtElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        status,
        statusElement,
        billingStatus,
        type,
        name,
        nameElement,
        const DeepCollectionEquality().hash(_subject),
        servicePeriod,
        const DeepCollectionEquality().hash(_covers),
        const DeepCollectionEquality().hash(_coverage),
        owner,
        description,
        descriptionElement,
        const DeepCollectionEquality().hash(_guarantor),
        const DeepCollectionEquality().hash(_diagnosis),
        const DeepCollectionEquality().hash(_procedure),
        const DeepCollectionEquality().hash(_relatedAccount),
        currency,
        const DeepCollectionEquality().hash(_balance),
        calculatedAt,
        calculatedAtElement
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountImplCopyWith<_$AccountImpl> get copyWith =>
      __$$AccountImplCopyWithImpl<_$AccountImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AccountImplToJson(
      this,
    );
  }
}

abstract class _Account extends Account {
  const factory _Account(
          {@JsonKey(unknownEnumValue: R6ResourceType.Account)
          final R6ResourceType resourceType,
          final FhirId? id,
          final FhirMeta? meta,
          final FhirUri? implicitRules,
          @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
          final FhirCode? language,
          @JsonKey(name: '_language') final Element? languageElement,
          final Narrative? text,
          final List<Resource>? contained,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Identifier>? identifier,
          final FhirCode? status,
          @JsonKey(name: '_status') final Element? statusElement,
          final CodeableConcept? billingStatus,
          final CodeableConcept? type,
          final String? name,
          @JsonKey(name: '_name') final Element? nameElement,
          final List<Reference>? subject,
          final Period? servicePeriod,
          final List<Reference>? covers,
          final List<AccountCoverage>? coverage,
          final Reference? owner,
          final FhirMarkdown? description,
          @JsonKey(name: '_description') final Element? descriptionElement,
          final List<AccountGuarantor>? guarantor,
          final List<AccountDiagnosis>? diagnosis,
          final List<AccountProcedure>? procedure,
          final List<AccountRelatedAccount>? relatedAccount,
          final CodeableConcept? currency,
          final List<AccountBalance>? balance,
          final FhirInstant? calculatedAt,
          @JsonKey(name: '_calculatedAt') final Element? calculatedAtElement}) =
      _$AccountImpl;
  const _Account._() : super._();

  factory _Account.fromJson(Map<String, dynamic> json) = _$AccountImpl.fromJson;

  @override

  /// [resourceType] This is a Account resource
  @JsonKey(unknownEnumValue: R6ResourceType.Account)
  R6ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  FhirMeta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  FhirCode? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Unique identifier used to reference the account.  Might or
  ///  might not be intended for human use (e.g. credit card number).
  List<Identifier>? get identifier;
  @override

  /// [status] Indicates whether the account is presently used/usable or not.
  FhirCode? get status;
  @override

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement;
  @override

  /// [billingStatus] The BillingStatus tracks the lifecycle of the account
  ///  through the billing process. It indicates how transactions are treated
  ///  when they are allocated to the account.
  CodeableConcept? get billingStatus;
  @override

  /// [type] Categorizes the account for reporting and searching purposes.
  CodeableConcept? get type;
  @override

  /// [name] Name used for the account when displaying it to humans in
  ///  reports, etc.
  String? get name;
  @override

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [subject] Identifies the entity which incurs the expenses. While the
  ///  immediate recipients of services or goods might be entities related to
  ///  the subject, the expenses were ultimately incurred by the subject of
  ///  the Account.
  List<Reference>? get subject;
  @override

  /// [servicePeriod] The date range of services associated with this account.
  Period? get servicePeriod;
  @override

  /// [covers] An account that collects the charges for a specific set of
  ///  services offered over a limited time period.  For example, a hospital
  ///  account might contain all charges related to a given admission,
  ///  including any inpatient appointments, and possibly re-admissions, of
  ///  the billing for those re-admissions should be grouped with the initial
  ///  admission for the purpose of claim submission.
  List<Reference>? get covers;
  @override

  /// [coverage] The party(s) that are responsible for covering the payment
  ///  of this account, and what order should they be applied to the account.
  List<AccountCoverage>? get coverage;
  @override

  /// [owner] Indicates the service area, hospital, department, etc. with
  ///  responsibility for managing the Account.
  Reference? get owner;
  @override

  /// [description] Provides additional information about what the account
  ///  tracks and how it is used.
  FhirMarkdown? get description;
  @override

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [guarantor] The parties responsible for balancing the account if other
  ///  payment options fall short.
  List<AccountGuarantor>? get guarantor;
  @override

  /// [diagnosis] When using an account for billing a specific Encounter the
  ///  set of diagnoses that are relevant for billing are stored here on the
  ///  account where they are able to be sequenced appropriately prior to
  ///  processing to produce claim(s).
  List<AccountDiagnosis>? get diagnosis;
  @override

  /// [procedure] When using an account for billing a specific Encounter the
  ///  set of procedures that are relevant for billing are stored here on the
  ///  account where they are able to be sequenced appropriately prior to
  ///  processing to produce claim(s).
  List<AccountProcedure>? get procedure;
  @override

  /// [relatedAccount] Other associated accounts related to this account.
  List<AccountRelatedAccount>? get relatedAccount;
  @override

  /// [currency] The default currency for the account.
  CodeableConcept? get currency;
  @override

  /// [balance] The calculated account balances - these are calculated and
  ///  processed by the finance system. The balances with a `term` that is
  ///  not current are usually generated/updated by an invoicing or similar
  ///  process.
  List<AccountBalance>? get balance;
  @override

  /// [calculatedAt] Time the balance amount was calculated.
  FhirInstant? get calculatedAt;
  @override

  /// [calculatedAtElement] ("_calculatedAt") Extensions for calculatedAt
  @JsonKey(name: '_calculatedAt')
  Element? get calculatedAtElement;
  @override
  @JsonKey(ignore: true)
  _$$AccountImplCopyWith<_$AccountImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AccountCoverage _$AccountCoverageFromJson(Map<String, dynamic> json) {
  return _AccountCoverage.fromJson(json);
}

/// @nodoc
mixin _$AccountCoverage {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [coverage] The party(s) that contribute to payment (or part of) of the
  ///  charges applied to this account (including self-pay).A coverage may
  ///  only be responsible for specific types of charges, and the sequence of
  ///  the coverages in the account could be important when processing
  ///  billing.
  Reference get coverage => throw _privateConstructorUsedError;

  /// [priority] The priority of the coverage in the context of this account.
  FhirPositiveInt? get priority => throw _privateConstructorUsedError;

  /// [priorityElement] ("_priority") Extensions for priority
  @JsonKey(name: '_priority')
  Element? get priorityElement => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AccountCoverageCopyWith<AccountCoverage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountCoverageCopyWith<$Res> {
  factory $AccountCoverageCopyWith(
          AccountCoverage value, $Res Function(AccountCoverage) then) =
      _$AccountCoverageCopyWithImpl<$Res, AccountCoverage>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference coverage,
      FhirPositiveInt? priority,
      @JsonKey(name: '_priority') Element? priorityElement});

  $ReferenceCopyWith<$Res> get coverage;
  $ElementCopyWith<$Res>? get priorityElement;
}

/// @nodoc
class _$AccountCoverageCopyWithImpl<$Res, $Val extends AccountCoverage>
    implements $AccountCoverageCopyWith<$Res> {
  _$AccountCoverageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? coverage = null,
    Object? priority = freezed,
    Object? priorityElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      coverage: null == coverage
          ? _value.coverage
          : coverage // ignore: cast_nullable_to_non_nullable
              as Reference,
      priority: freezed == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      priorityElement: freezed == priorityElement
          ? _value.priorityElement
          : priorityElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get coverage {
    return $ReferenceCopyWith<$Res>(_value.coverage, (value) {
      return _then(_value.copyWith(coverage: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get priorityElement {
    if (_value.priorityElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.priorityElement!, (value) {
      return _then(_value.copyWith(priorityElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AccountCoverageImplCopyWith<$Res>
    implements $AccountCoverageCopyWith<$Res> {
  factory _$$AccountCoverageImplCopyWith(_$AccountCoverageImpl value,
          $Res Function(_$AccountCoverageImpl) then) =
      __$$AccountCoverageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference coverage,
      FhirPositiveInt? priority,
      @JsonKey(name: '_priority') Element? priorityElement});

  @override
  $ReferenceCopyWith<$Res> get coverage;
  @override
  $ElementCopyWith<$Res>? get priorityElement;
}

/// @nodoc
class __$$AccountCoverageImplCopyWithImpl<$Res>
    extends _$AccountCoverageCopyWithImpl<$Res, _$AccountCoverageImpl>
    implements _$$AccountCoverageImplCopyWith<$Res> {
  __$$AccountCoverageImplCopyWithImpl(
      _$AccountCoverageImpl _value, $Res Function(_$AccountCoverageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? coverage = null,
    Object? priority = freezed,
    Object? priorityElement = freezed,
  }) {
    return _then(_$AccountCoverageImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      coverage: null == coverage
          ? _value.coverage
          : coverage // ignore: cast_nullable_to_non_nullable
              as Reference,
      priority: freezed == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      priorityElement: freezed == priorityElement
          ? _value.priorityElement
          : priorityElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AccountCoverageImpl extends _AccountCoverage {
  const _$AccountCoverageImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.coverage,
      this.priority,
      @JsonKey(name: '_priority') this.priorityElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$AccountCoverageImpl.fromJson(Map<String, dynamic> json) =>
      _$$AccountCoverageImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [coverage] The party(s) that contribute to payment (or part of) of the
  ///  charges applied to this account (including self-pay).A coverage may
  ///  only be responsible for specific types of charges, and the sequence of
  ///  the coverages in the account could be important when processing
  ///  billing.
  @override
  final Reference coverage;

  /// [priority] The priority of the coverage in the context of this account.
  @override
  final FhirPositiveInt? priority;

  /// [priorityElement] ("_priority") Extensions for priority
  @override
  @JsonKey(name: '_priority')
  final Element? priorityElement;

  @override
  String toString() {
    return 'AccountCoverage(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, coverage: $coverage, priority: $priority, priorityElement: $priorityElement)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountCoverageImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.coverage, coverage) ||
                other.coverage == coverage) &&
            (identical(other.priority, priority) ||
                other.priority == priority) &&
            (identical(other.priorityElement, priorityElement) ||
                other.priorityElement == priorityElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      coverage,
      priority,
      priorityElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountCoverageImplCopyWith<_$AccountCoverageImpl> get copyWith =>
      __$$AccountCoverageImplCopyWithImpl<_$AccountCoverageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AccountCoverageImplToJson(
      this,
    );
  }
}

abstract class _AccountCoverage extends AccountCoverage {
  const factory _AccountCoverage(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final Reference coverage,
          final FhirPositiveInt? priority,
          @JsonKey(name: '_priority') final Element? priorityElement}) =
      _$AccountCoverageImpl;
  const _AccountCoverage._() : super._();

  factory _AccountCoverage.fromJson(Map<String, dynamic> json) =
      _$AccountCoverageImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [coverage] The party(s) that contribute to payment (or part of) of the
  ///  charges applied to this account (including self-pay).A coverage may
  ///  only be responsible for specific types of charges, and the sequence of
  ///  the coverages in the account could be important when processing
  ///  billing.
  Reference get coverage;
  @override

  /// [priority] The priority of the coverage in the context of this account.
  FhirPositiveInt? get priority;
  @override

  /// [priorityElement] ("_priority") Extensions for priority
  @JsonKey(name: '_priority')
  Element? get priorityElement;
  @override
  @JsonKey(ignore: true)
  _$$AccountCoverageImplCopyWith<_$AccountCoverageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AccountGuarantor _$AccountGuarantorFromJson(Map<String, dynamic> json) {
  return _AccountGuarantor.fromJson(json);
}

/// @nodoc
mixin _$AccountGuarantor {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [party] The entity who is responsible.
  Reference get party => throw _privateConstructorUsedError;

  /// [onHold] A guarantor may be placed on credit hold or otherwise have
  ///  their role temporarily suspended.
  FhirBoolean? get onHold => throw _privateConstructorUsedError;

  /// [onHoldElement] ("_onHold") Extensions for onHold
  @JsonKey(name: '_onHold')
  Element? get onHoldElement => throw _privateConstructorUsedError;

  /// [period] The timeframe during which the guarantor accepts
  ///  responsibility for the account.
  Period? get period => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AccountGuarantorCopyWith<AccountGuarantor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountGuarantorCopyWith<$Res> {
  factory $AccountGuarantorCopyWith(
          AccountGuarantor value, $Res Function(AccountGuarantor) then) =
      _$AccountGuarantorCopyWithImpl<$Res, AccountGuarantor>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference party,
      FhirBoolean? onHold,
      @JsonKey(name: '_onHold') Element? onHoldElement,
      Period? period});

  $ReferenceCopyWith<$Res> get party;
  $ElementCopyWith<$Res>? get onHoldElement;
  $PeriodCopyWith<$Res>? get period;
}

/// @nodoc
class _$AccountGuarantorCopyWithImpl<$Res, $Val extends AccountGuarantor>
    implements $AccountGuarantorCopyWith<$Res> {
  _$AccountGuarantorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? party = null,
    Object? onHold = freezed,
    Object? onHoldElement = freezed,
    Object? period = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      party: null == party
          ? _value.party
          : party // ignore: cast_nullable_to_non_nullable
              as Reference,
      onHold: freezed == onHold
          ? _value.onHold
          : onHold // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      onHoldElement: freezed == onHoldElement
          ? _value.onHoldElement
          : onHoldElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      period: freezed == period
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as Period?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get party {
    return $ReferenceCopyWith<$Res>(_value.party, (value) {
      return _then(_value.copyWith(party: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get onHoldElement {
    if (_value.onHoldElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.onHoldElement!, (value) {
      return _then(_value.copyWith(onHoldElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get period {
    if (_value.period == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.period!, (value) {
      return _then(_value.copyWith(period: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AccountGuarantorImplCopyWith<$Res>
    implements $AccountGuarantorCopyWith<$Res> {
  factory _$$AccountGuarantorImplCopyWith(_$AccountGuarantorImpl value,
          $Res Function(_$AccountGuarantorImpl) then) =
      __$$AccountGuarantorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference party,
      FhirBoolean? onHold,
      @JsonKey(name: '_onHold') Element? onHoldElement,
      Period? period});

  @override
  $ReferenceCopyWith<$Res> get party;
  @override
  $ElementCopyWith<$Res>? get onHoldElement;
  @override
  $PeriodCopyWith<$Res>? get period;
}

/// @nodoc
class __$$AccountGuarantorImplCopyWithImpl<$Res>
    extends _$AccountGuarantorCopyWithImpl<$Res, _$AccountGuarantorImpl>
    implements _$$AccountGuarantorImplCopyWith<$Res> {
  __$$AccountGuarantorImplCopyWithImpl(_$AccountGuarantorImpl _value,
      $Res Function(_$AccountGuarantorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? party = null,
    Object? onHold = freezed,
    Object? onHoldElement = freezed,
    Object? period = freezed,
  }) {
    return _then(_$AccountGuarantorImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      party: null == party
          ? _value.party
          : party // ignore: cast_nullable_to_non_nullable
              as Reference,
      onHold: freezed == onHold
          ? _value.onHold
          : onHold // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      onHoldElement: freezed == onHoldElement
          ? _value.onHoldElement
          : onHoldElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      period: freezed == period
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as Period?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AccountGuarantorImpl extends _AccountGuarantor {
  const _$AccountGuarantorImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.party,
      this.onHold,
      @JsonKey(name: '_onHold') this.onHoldElement,
      this.period})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$AccountGuarantorImpl.fromJson(Map<String, dynamic> json) =>
      _$$AccountGuarantorImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [party] The entity who is responsible.
  @override
  final Reference party;

  /// [onHold] A guarantor may be placed on credit hold or otherwise have
  ///  their role temporarily suspended.
  @override
  final FhirBoolean? onHold;

  /// [onHoldElement] ("_onHold") Extensions for onHold
  @override
  @JsonKey(name: '_onHold')
  final Element? onHoldElement;

  /// [period] The timeframe during which the guarantor accepts
  ///  responsibility for the account.
  @override
  final Period? period;

  @override
  String toString() {
    return 'AccountGuarantor(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, party: $party, onHold: $onHold, onHoldElement: $onHoldElement, period: $period)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountGuarantorImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.party, party) || other.party == party) &&
            (identical(other.onHold, onHold) || other.onHold == onHold) &&
            (identical(other.onHoldElement, onHoldElement) ||
                other.onHoldElement == onHoldElement) &&
            (identical(other.period, period) || other.period == period));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      party,
      onHold,
      onHoldElement,
      period);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountGuarantorImplCopyWith<_$AccountGuarantorImpl> get copyWith =>
      __$$AccountGuarantorImplCopyWithImpl<_$AccountGuarantorImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AccountGuarantorImplToJson(
      this,
    );
  }
}

abstract class _AccountGuarantor extends AccountGuarantor {
  const factory _AccountGuarantor(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final Reference party,
      final FhirBoolean? onHold,
      @JsonKey(name: '_onHold') final Element? onHoldElement,
      final Period? period}) = _$AccountGuarantorImpl;
  const _AccountGuarantor._() : super._();

  factory _AccountGuarantor.fromJson(Map<String, dynamic> json) =
      _$AccountGuarantorImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [party] The entity who is responsible.
  Reference get party;
  @override

  /// [onHold] A guarantor may be placed on credit hold or otherwise have
  ///  their role temporarily suspended.
  FhirBoolean? get onHold;
  @override

  /// [onHoldElement] ("_onHold") Extensions for onHold
  @JsonKey(name: '_onHold')
  Element? get onHoldElement;
  @override

  /// [period] The timeframe during which the guarantor accepts
  ///  responsibility for the account.
  Period? get period;
  @override
  @JsonKey(ignore: true)
  _$$AccountGuarantorImplCopyWith<_$AccountGuarantorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AccountDiagnosis _$AccountDiagnosisFromJson(Map<String, dynamic> json) {
  return _AccountDiagnosis.fromJson(json);
}

/// @nodoc
mixin _$AccountDiagnosis {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [sequence] Ranking of the diagnosis (for each type).
  FhirPositiveInt? get sequence => throw _privateConstructorUsedError;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement => throw _privateConstructorUsedError;

  /// [condition] The diagnosis relevant to the account.
  CodeableReference get condition => throw _privateConstructorUsedError;

  /// [dateOfDiagnosis] Ranking of the diagnosis (for each type).
  FhirDateTime? get dateOfDiagnosis => throw _privateConstructorUsedError;

  /// [dateOfDiagnosisElement] ("_dateOfDiagnosis") Extensions for
  ///  dateOfDiagnosis
  @JsonKey(name: '_dateOfDiagnosis')
  Element? get dateOfDiagnosisElement => throw _privateConstructorUsedError;

  /// [type] Type that this diagnosis has relevant to the account (e.g.
  ///  admission, billing, discharge ).
  List<CodeableConcept>? get type => throw _privateConstructorUsedError;

  /// [onAdmission] Was the Diagnosis present on Admission in the related
  ///  Encounter.
  FhirBoolean? get onAdmission => throw _privateConstructorUsedError;

  /// [onAdmissionElement] ("_onAdmission") Extensions for onAdmission
  @JsonKey(name: '_onAdmission')
  Element? get onAdmissionElement => throw _privateConstructorUsedError;

  /// [packageCode] The package code can be used to group diagnoses that may
  ///  be priced or delivered as a single product. Such as DRGs.
  List<CodeableConcept>? get packageCode => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AccountDiagnosisCopyWith<AccountDiagnosis> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountDiagnosisCopyWith<$Res> {
  factory $AccountDiagnosisCopyWith(
          AccountDiagnosis value, $Res Function(AccountDiagnosis) then) =
      _$AccountDiagnosisCopyWithImpl<$Res, AccountDiagnosis>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      CodeableReference condition,
      FhirDateTime? dateOfDiagnosis,
      @JsonKey(name: '_dateOfDiagnosis') Element? dateOfDiagnosisElement,
      List<CodeableConcept>? type,
      FhirBoolean? onAdmission,
      @JsonKey(name: '_onAdmission') Element? onAdmissionElement,
      List<CodeableConcept>? packageCode});

  $ElementCopyWith<$Res>? get sequenceElement;
  $CodeableReferenceCopyWith<$Res> get condition;
  $ElementCopyWith<$Res>? get dateOfDiagnosisElement;
  $ElementCopyWith<$Res>? get onAdmissionElement;
}

/// @nodoc
class _$AccountDiagnosisCopyWithImpl<$Res, $Val extends AccountDiagnosis>
    implements $AccountDiagnosisCopyWith<$Res> {
  _$AccountDiagnosisCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? condition = null,
    Object? dateOfDiagnosis = freezed,
    Object? dateOfDiagnosisElement = freezed,
    Object? type = freezed,
    Object? onAdmission = freezed,
    Object? onAdmissionElement = freezed,
    Object? packageCode = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      condition: null == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      dateOfDiagnosis: freezed == dateOfDiagnosis
          ? _value.dateOfDiagnosis
          : dateOfDiagnosis // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateOfDiagnosisElement: freezed == dateOfDiagnosisElement
          ? _value.dateOfDiagnosisElement
          : dateOfDiagnosisElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      onAdmission: freezed == onAdmission
          ? _value.onAdmission
          : onAdmission // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      onAdmissionElement: freezed == onAdmissionElement
          ? _value.onAdmissionElement
          : onAdmissionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      packageCode: freezed == packageCode
          ? _value.packageCode
          : packageCode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get sequenceElement {
    if (_value.sequenceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.sequenceElement!, (value) {
      return _then(_value.copyWith(sequenceElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res> get condition {
    return $CodeableReferenceCopyWith<$Res>(_value.condition, (value) {
      return _then(_value.copyWith(condition: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get dateOfDiagnosisElement {
    if (_value.dateOfDiagnosisElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.dateOfDiagnosisElement!, (value) {
      return _then(_value.copyWith(dateOfDiagnosisElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get onAdmissionElement {
    if (_value.onAdmissionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.onAdmissionElement!, (value) {
      return _then(_value.copyWith(onAdmissionElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AccountDiagnosisImplCopyWith<$Res>
    implements $AccountDiagnosisCopyWith<$Res> {
  factory _$$AccountDiagnosisImplCopyWith(_$AccountDiagnosisImpl value,
          $Res Function(_$AccountDiagnosisImpl) then) =
      __$$AccountDiagnosisImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      CodeableReference condition,
      FhirDateTime? dateOfDiagnosis,
      @JsonKey(name: '_dateOfDiagnosis') Element? dateOfDiagnosisElement,
      List<CodeableConcept>? type,
      FhirBoolean? onAdmission,
      @JsonKey(name: '_onAdmission') Element? onAdmissionElement,
      List<CodeableConcept>? packageCode});

  @override
  $ElementCopyWith<$Res>? get sequenceElement;
  @override
  $CodeableReferenceCopyWith<$Res> get condition;
  @override
  $ElementCopyWith<$Res>? get dateOfDiagnosisElement;
  @override
  $ElementCopyWith<$Res>? get onAdmissionElement;
}

/// @nodoc
class __$$AccountDiagnosisImplCopyWithImpl<$Res>
    extends _$AccountDiagnosisCopyWithImpl<$Res, _$AccountDiagnosisImpl>
    implements _$$AccountDiagnosisImplCopyWith<$Res> {
  __$$AccountDiagnosisImplCopyWithImpl(_$AccountDiagnosisImpl _value,
      $Res Function(_$AccountDiagnosisImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? condition = null,
    Object? dateOfDiagnosis = freezed,
    Object? dateOfDiagnosisElement = freezed,
    Object? type = freezed,
    Object? onAdmission = freezed,
    Object? onAdmissionElement = freezed,
    Object? packageCode = freezed,
  }) {
    return _then(_$AccountDiagnosisImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      condition: null == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      dateOfDiagnosis: freezed == dateOfDiagnosis
          ? _value.dateOfDiagnosis
          : dateOfDiagnosis // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateOfDiagnosisElement: freezed == dateOfDiagnosisElement
          ? _value.dateOfDiagnosisElement
          : dateOfDiagnosisElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value._type
          : type // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      onAdmission: freezed == onAdmission
          ? _value.onAdmission
          : onAdmission // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      onAdmissionElement: freezed == onAdmissionElement
          ? _value.onAdmissionElement
          : onAdmissionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      packageCode: freezed == packageCode
          ? _value._packageCode
          : packageCode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AccountDiagnosisImpl extends _AccountDiagnosis {
  const _$AccountDiagnosisImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.sequence,
      @JsonKey(name: '_sequence') this.sequenceElement,
      required this.condition,
      this.dateOfDiagnosis,
      @JsonKey(name: '_dateOfDiagnosis') this.dateOfDiagnosisElement,
      final List<CodeableConcept>? type,
      this.onAdmission,
      @JsonKey(name: '_onAdmission') this.onAdmissionElement,
      final List<CodeableConcept>? packageCode})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _type = type,
        _packageCode = packageCode,
        super._();

  factory _$AccountDiagnosisImpl.fromJson(Map<String, dynamic> json) =>
      _$$AccountDiagnosisImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sequence] Ranking of the diagnosis (for each type).
  @override
  final FhirPositiveInt? sequence;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @override
  @JsonKey(name: '_sequence')
  final Element? sequenceElement;

  /// [condition] The diagnosis relevant to the account.
  @override
  final CodeableReference condition;

  /// [dateOfDiagnosis] Ranking of the diagnosis (for each type).
  @override
  final FhirDateTime? dateOfDiagnosis;

  /// [dateOfDiagnosisElement] ("_dateOfDiagnosis") Extensions for
  ///  dateOfDiagnosis
  @override
  @JsonKey(name: '_dateOfDiagnosis')
  final Element? dateOfDiagnosisElement;

  /// [type] Type that this diagnosis has relevant to the account (e.g.
  ///  admission, billing, discharge ).
  final List<CodeableConcept>? _type;

  /// [type] Type that this diagnosis has relevant to the account (e.g.
  ///  admission, billing, discharge ).
  @override
  List<CodeableConcept>? get type {
    final value = _type;
    if (value == null) return null;
    if (_type is EqualUnmodifiableListView) return _type;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [onAdmission] Was the Diagnosis present on Admission in the related
  ///  Encounter.
  @override
  final FhirBoolean? onAdmission;

  /// [onAdmissionElement] ("_onAdmission") Extensions for onAdmission
  @override
  @JsonKey(name: '_onAdmission')
  final Element? onAdmissionElement;

  /// [packageCode] The package code can be used to group diagnoses that may
  ///  be priced or delivered as a single product. Such as DRGs.
  final List<CodeableConcept>? _packageCode;

  /// [packageCode] The package code can be used to group diagnoses that may
  ///  be priced or delivered as a single product. Such as DRGs.
  @override
  List<CodeableConcept>? get packageCode {
    final value = _packageCode;
    if (value == null) return null;
    if (_packageCode is EqualUnmodifiableListView) return _packageCode;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AccountDiagnosis(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, sequence: $sequence, sequenceElement: $sequenceElement, condition: $condition, dateOfDiagnosis: $dateOfDiagnosis, dateOfDiagnosisElement: $dateOfDiagnosisElement, type: $type, onAdmission: $onAdmission, onAdmissionElement: $onAdmissionElement, packageCode: $packageCode)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountDiagnosisImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.sequence, sequence) ||
                other.sequence == sequence) &&
            (identical(other.sequenceElement, sequenceElement) ||
                other.sequenceElement == sequenceElement) &&
            (identical(other.condition, condition) ||
                other.condition == condition) &&
            (identical(other.dateOfDiagnosis, dateOfDiagnosis) ||
                other.dateOfDiagnosis == dateOfDiagnosis) &&
            (identical(other.dateOfDiagnosisElement, dateOfDiagnosisElement) ||
                other.dateOfDiagnosisElement == dateOfDiagnosisElement) &&
            const DeepCollectionEquality().equals(other._type, _type) &&
            (identical(other.onAdmission, onAdmission) ||
                other.onAdmission == onAdmission) &&
            (identical(other.onAdmissionElement, onAdmissionElement) ||
                other.onAdmissionElement == onAdmissionElement) &&
            const DeepCollectionEquality()
                .equals(other._packageCode, _packageCode));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      sequence,
      sequenceElement,
      condition,
      dateOfDiagnosis,
      dateOfDiagnosisElement,
      const DeepCollectionEquality().hash(_type),
      onAdmission,
      onAdmissionElement,
      const DeepCollectionEquality().hash(_packageCode));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountDiagnosisImplCopyWith<_$AccountDiagnosisImpl> get copyWith =>
      __$$AccountDiagnosisImplCopyWithImpl<_$AccountDiagnosisImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AccountDiagnosisImplToJson(
      this,
    );
  }
}

abstract class _AccountDiagnosis extends AccountDiagnosis {
  const factory _AccountDiagnosis(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') final Element? sequenceElement,
      required final CodeableReference condition,
      final FhirDateTime? dateOfDiagnosis,
      @JsonKey(name: '_dateOfDiagnosis') final Element? dateOfDiagnosisElement,
      final List<CodeableConcept>? type,
      final FhirBoolean? onAdmission,
      @JsonKey(name: '_onAdmission') final Element? onAdmissionElement,
      final List<CodeableConcept>? packageCode}) = _$AccountDiagnosisImpl;
  const _AccountDiagnosis._() : super._();

  factory _AccountDiagnosis.fromJson(Map<String, dynamic> json) =
      _$AccountDiagnosisImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [sequence] Ranking of the diagnosis (for each type).
  FhirPositiveInt? get sequence;
  @override

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement;
  @override

  /// [condition] The diagnosis relevant to the account.
  CodeableReference get condition;
  @override

  /// [dateOfDiagnosis] Ranking of the diagnosis (for each type).
  FhirDateTime? get dateOfDiagnosis;
  @override

  /// [dateOfDiagnosisElement] ("_dateOfDiagnosis") Extensions for
  ///  dateOfDiagnosis
  @JsonKey(name: '_dateOfDiagnosis')
  Element? get dateOfDiagnosisElement;
  @override

  /// [type] Type that this diagnosis has relevant to the account (e.g.
  ///  admission, billing, discharge ).
  List<CodeableConcept>? get type;
  @override

  /// [onAdmission] Was the Diagnosis present on Admission in the related
  ///  Encounter.
  FhirBoolean? get onAdmission;
  @override

  /// [onAdmissionElement] ("_onAdmission") Extensions for onAdmission
  @JsonKey(name: '_onAdmission')
  Element? get onAdmissionElement;
  @override

  /// [packageCode] The package code can be used to group diagnoses that may
  ///  be priced or delivered as a single product. Such as DRGs.
  List<CodeableConcept>? get packageCode;
  @override
  @JsonKey(ignore: true)
  _$$AccountDiagnosisImplCopyWith<_$AccountDiagnosisImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AccountProcedure _$AccountProcedureFromJson(Map<String, dynamic> json) {
  return _AccountProcedure.fromJson(json);
}

/// @nodoc
mixin _$AccountProcedure {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [sequence] Ranking of the procedure (for each type).
  FhirPositiveInt? get sequence => throw _privateConstructorUsedError;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement => throw _privateConstructorUsedError;

  /// [code] The procedure relevant to the account.
  CodeableReference get code => throw _privateConstructorUsedError;

  /// [dateOfService] Date of the procedure when using a coded procedure. If
  ///  using a reference to a procedure, then the date on the procedure
  ///  should be used.
  FhirDateTime? get dateOfService => throw _privateConstructorUsedError;

  /// [dateOfServiceElement] ("_dateOfService") Extensions for dateOfService
  @JsonKey(name: '_dateOfService')
  Element? get dateOfServiceElement => throw _privateConstructorUsedError;

  /// [type] How this procedure value should be used in charging the account.
  List<CodeableConcept>? get type => throw _privateConstructorUsedError;

  /// [packageCode] The package code can be used to group procedures that may
  ///  be priced or delivered as a single product. Such as DRGs.
  List<CodeableConcept>? get packageCode => throw _privateConstructorUsedError;

  /// [device] Any devices that were associated with the procedure relevant
  ///  to the account.
  List<Reference>? get device => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AccountProcedureCopyWith<AccountProcedure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountProcedureCopyWith<$Res> {
  factory $AccountProcedureCopyWith(
          AccountProcedure value, $Res Function(AccountProcedure) then) =
      _$AccountProcedureCopyWithImpl<$Res, AccountProcedure>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      CodeableReference code,
      FhirDateTime? dateOfService,
      @JsonKey(name: '_dateOfService') Element? dateOfServiceElement,
      List<CodeableConcept>? type,
      List<CodeableConcept>? packageCode,
      List<Reference>? device});

  $ElementCopyWith<$Res>? get sequenceElement;
  $CodeableReferenceCopyWith<$Res> get code;
  $ElementCopyWith<$Res>? get dateOfServiceElement;
}

/// @nodoc
class _$AccountProcedureCopyWithImpl<$Res, $Val extends AccountProcedure>
    implements $AccountProcedureCopyWith<$Res> {
  _$AccountProcedureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? code = null,
    Object? dateOfService = freezed,
    Object? dateOfServiceElement = freezed,
    Object? type = freezed,
    Object? packageCode = freezed,
    Object? device = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      dateOfService: freezed == dateOfService
          ? _value.dateOfService
          : dateOfService // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateOfServiceElement: freezed == dateOfServiceElement
          ? _value.dateOfServiceElement
          : dateOfServiceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      packageCode: freezed == packageCode
          ? _value.packageCode
          : packageCode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      device: freezed == device
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get sequenceElement {
    if (_value.sequenceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.sequenceElement!, (value) {
      return _then(_value.copyWith(sequenceElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableReferenceCopyWith<$Res> get code {
    return $CodeableReferenceCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get dateOfServiceElement {
    if (_value.dateOfServiceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.dateOfServiceElement!, (value) {
      return _then(_value.copyWith(dateOfServiceElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AccountProcedureImplCopyWith<$Res>
    implements $AccountProcedureCopyWith<$Res> {
  factory _$$AccountProcedureImplCopyWith(_$AccountProcedureImpl value,
          $Res Function(_$AccountProcedureImpl) then) =
      __$$AccountProcedureImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      CodeableReference code,
      FhirDateTime? dateOfService,
      @JsonKey(name: '_dateOfService') Element? dateOfServiceElement,
      List<CodeableConcept>? type,
      List<CodeableConcept>? packageCode,
      List<Reference>? device});

  @override
  $ElementCopyWith<$Res>? get sequenceElement;
  @override
  $CodeableReferenceCopyWith<$Res> get code;
  @override
  $ElementCopyWith<$Res>? get dateOfServiceElement;
}

/// @nodoc
class __$$AccountProcedureImplCopyWithImpl<$Res>
    extends _$AccountProcedureCopyWithImpl<$Res, _$AccountProcedureImpl>
    implements _$$AccountProcedureImplCopyWith<$Res> {
  __$$AccountProcedureImplCopyWithImpl(_$AccountProcedureImpl _value,
      $Res Function(_$AccountProcedureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? code = null,
    Object? dateOfService = freezed,
    Object? dateOfServiceElement = freezed,
    Object? type = freezed,
    Object? packageCode = freezed,
    Object? device = freezed,
  }) {
    return _then(_$AccountProcedureImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableReference,
      dateOfService: freezed == dateOfService
          ? _value.dateOfService
          : dateOfService // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateOfServiceElement: freezed == dateOfServiceElement
          ? _value.dateOfServiceElement
          : dateOfServiceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value._type
          : type // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      packageCode: freezed == packageCode
          ? _value._packageCode
          : packageCode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      device: freezed == device
          ? _value._device
          : device // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AccountProcedureImpl extends _AccountProcedure {
  const _$AccountProcedureImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.sequence,
      @JsonKey(name: '_sequence') this.sequenceElement,
      required this.code,
      this.dateOfService,
      @JsonKey(name: '_dateOfService') this.dateOfServiceElement,
      final List<CodeableConcept>? type,
      final List<CodeableConcept>? packageCode,
      final List<Reference>? device})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _type = type,
        _packageCode = packageCode,
        _device = device,
        super._();

  factory _$AccountProcedureImpl.fromJson(Map<String, dynamic> json) =>
      _$$AccountProcedureImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sequence] Ranking of the procedure (for each type).
  @override
  final FhirPositiveInt? sequence;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @override
  @JsonKey(name: '_sequence')
  final Element? sequenceElement;

  /// [code] The procedure relevant to the account.
  @override
  final CodeableReference code;

  /// [dateOfService] Date of the procedure when using a coded procedure. If
  ///  using a reference to a procedure, then the date on the procedure
  ///  should be used.
  @override
  final FhirDateTime? dateOfService;

  /// [dateOfServiceElement] ("_dateOfService") Extensions for dateOfService
  @override
  @JsonKey(name: '_dateOfService')
  final Element? dateOfServiceElement;

  /// [type] How this procedure value should be used in charging the account.
  final List<CodeableConcept>? _type;

  /// [type] How this procedure value should be used in charging the account.
  @override
  List<CodeableConcept>? get type {
    final value = _type;
    if (value == null) return null;
    if (_type is EqualUnmodifiableListView) return _type;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [packageCode] The package code can be used to group procedures that may
  ///  be priced or delivered as a single product. Such as DRGs.
  final List<CodeableConcept>? _packageCode;

  /// [packageCode] The package code can be used to group procedures that may
  ///  be priced or delivered as a single product. Such as DRGs.
  @override
  List<CodeableConcept>? get packageCode {
    final value = _packageCode;
    if (value == null) return null;
    if (_packageCode is EqualUnmodifiableListView) return _packageCode;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [device] Any devices that were associated with the procedure relevant
  ///  to the account.
  final List<Reference>? _device;

  /// [device] Any devices that were associated with the procedure relevant
  ///  to the account.
  @override
  List<Reference>? get device {
    final value = _device;
    if (value == null) return null;
    if (_device is EqualUnmodifiableListView) return _device;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AccountProcedure(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, sequence: $sequence, sequenceElement: $sequenceElement, code: $code, dateOfService: $dateOfService, dateOfServiceElement: $dateOfServiceElement, type: $type, packageCode: $packageCode, device: $device)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountProcedureImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.sequence, sequence) ||
                other.sequence == sequence) &&
            (identical(other.sequenceElement, sequenceElement) ||
                other.sequenceElement == sequenceElement) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.dateOfService, dateOfService) ||
                other.dateOfService == dateOfService) &&
            (identical(other.dateOfServiceElement, dateOfServiceElement) ||
                other.dateOfServiceElement == dateOfServiceElement) &&
            const DeepCollectionEquality().equals(other._type, _type) &&
            const DeepCollectionEquality()
                .equals(other._packageCode, _packageCode) &&
            const DeepCollectionEquality().equals(other._device, _device));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      sequence,
      sequenceElement,
      code,
      dateOfService,
      dateOfServiceElement,
      const DeepCollectionEquality().hash(_type),
      const DeepCollectionEquality().hash(_packageCode),
      const DeepCollectionEquality().hash(_device));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountProcedureImplCopyWith<_$AccountProcedureImpl> get copyWith =>
      __$$AccountProcedureImplCopyWithImpl<_$AccountProcedureImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AccountProcedureImplToJson(
      this,
    );
  }
}

abstract class _AccountProcedure extends AccountProcedure {
  const factory _AccountProcedure(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') final Element? sequenceElement,
      required final CodeableReference code,
      final FhirDateTime? dateOfService,
      @JsonKey(name: '_dateOfService') final Element? dateOfServiceElement,
      final List<CodeableConcept>? type,
      final List<CodeableConcept>? packageCode,
      final List<Reference>? device}) = _$AccountProcedureImpl;
  const _AccountProcedure._() : super._();

  factory _AccountProcedure.fromJson(Map<String, dynamic> json) =
      _$AccountProcedureImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [sequence] Ranking of the procedure (for each type).
  FhirPositiveInt? get sequence;
  @override

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement;
  @override

  /// [code] The procedure relevant to the account.
  CodeableReference get code;
  @override

  /// [dateOfService] Date of the procedure when using a coded procedure. If
  ///  using a reference to a procedure, then the date on the procedure
  ///  should be used.
  FhirDateTime? get dateOfService;
  @override

  /// [dateOfServiceElement] ("_dateOfService") Extensions for dateOfService
  @JsonKey(name: '_dateOfService')
  Element? get dateOfServiceElement;
  @override

  /// [type] How this procedure value should be used in charging the account.
  List<CodeableConcept>? get type;
  @override

  /// [packageCode] The package code can be used to group procedures that may
  ///  be priced or delivered as a single product. Such as DRGs.
  List<CodeableConcept>? get packageCode;
  @override

  /// [device] Any devices that were associated with the procedure relevant
  ///  to the account.
  List<Reference>? get device;
  @override
  @JsonKey(ignore: true)
  _$$AccountProcedureImplCopyWith<_$AccountProcedureImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AccountRelatedAccount _$AccountRelatedAccountFromJson(
    Map<String, dynamic> json) {
  return _AccountRelatedAccount.fromJson(json);
}

/// @nodoc
mixin _$AccountRelatedAccount {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [relationship] Relationship of the associated Account.
  CodeableConcept? get relationship => throw _privateConstructorUsedError;

  /// [account] Reference to an associated Account.
  Reference get account => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AccountRelatedAccountCopyWith<AccountRelatedAccount> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountRelatedAccountCopyWith<$Res> {
  factory $AccountRelatedAccountCopyWith(AccountRelatedAccount value,
          $Res Function(AccountRelatedAccount) then) =
      _$AccountRelatedAccountCopyWithImpl<$Res, AccountRelatedAccount>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? relationship,
      Reference account});

  $CodeableConceptCopyWith<$Res>? get relationship;
  $ReferenceCopyWith<$Res> get account;
}

/// @nodoc
class _$AccountRelatedAccountCopyWithImpl<$Res,
        $Val extends AccountRelatedAccount>
    implements $AccountRelatedAccountCopyWith<$Res> {
  _$AccountRelatedAccountCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? relationship = freezed,
    Object? account = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      relationship: freezed == relationship
          ? _value.relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      account: null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as Reference,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get relationship {
    if (_value.relationship == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.relationship!, (value) {
      return _then(_value.copyWith(relationship: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get account {
    return $ReferenceCopyWith<$Res>(_value.account, (value) {
      return _then(_value.copyWith(account: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AccountRelatedAccountImplCopyWith<$Res>
    implements $AccountRelatedAccountCopyWith<$Res> {
  factory _$$AccountRelatedAccountImplCopyWith(
          _$AccountRelatedAccountImpl value,
          $Res Function(_$AccountRelatedAccountImpl) then) =
      __$$AccountRelatedAccountImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? relationship,
      Reference account});

  @override
  $CodeableConceptCopyWith<$Res>? get relationship;
  @override
  $ReferenceCopyWith<$Res> get account;
}

/// @nodoc
class __$$AccountRelatedAccountImplCopyWithImpl<$Res>
    extends _$AccountRelatedAccountCopyWithImpl<$Res,
        _$AccountRelatedAccountImpl>
    implements _$$AccountRelatedAccountImplCopyWith<$Res> {
  __$$AccountRelatedAccountImplCopyWithImpl(_$AccountRelatedAccountImpl _value,
      $Res Function(_$AccountRelatedAccountImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? relationship = freezed,
    Object? account = null,
  }) {
    return _then(_$AccountRelatedAccountImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      relationship: freezed == relationship
          ? _value.relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      account: null == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as Reference,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AccountRelatedAccountImpl extends _AccountRelatedAccount {
  const _$AccountRelatedAccountImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.relationship,
      required this.account})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$AccountRelatedAccountImpl.fromJson(Map<String, dynamic> json) =>
      _$$AccountRelatedAccountImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [relationship] Relationship of the associated Account.
  @override
  final CodeableConcept? relationship;

  /// [account] Reference to an associated Account.
  @override
  final Reference account;

  @override
  String toString() {
    return 'AccountRelatedAccount(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, relationship: $relationship, account: $account)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountRelatedAccountImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.relationship, relationship) ||
                other.relationship == relationship) &&
            (identical(other.account, account) || other.account == account));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      relationship,
      account);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountRelatedAccountImplCopyWith<_$AccountRelatedAccountImpl>
      get copyWith => __$$AccountRelatedAccountImplCopyWithImpl<
          _$AccountRelatedAccountImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AccountRelatedAccountImplToJson(
      this,
    );
  }
}

abstract class _AccountRelatedAccount extends AccountRelatedAccount {
  const factory _AccountRelatedAccount(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? relationship,
      required final Reference account}) = _$AccountRelatedAccountImpl;
  const _AccountRelatedAccount._() : super._();

  factory _AccountRelatedAccount.fromJson(Map<String, dynamic> json) =
      _$AccountRelatedAccountImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [relationship] Relationship of the associated Account.
  CodeableConcept? get relationship;
  @override

  /// [account] Reference to an associated Account.
  Reference get account;
  @override
  @JsonKey(ignore: true)
  _$$AccountRelatedAccountImplCopyWith<_$AccountRelatedAccountImpl>
      get copyWith => throw _privateConstructorUsedError;
}

AccountBalance _$AccountBalanceFromJson(Map<String, dynamic> json) {
  return _AccountBalance.fromJson(json);
}

/// @nodoc
mixin _$AccountBalance {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [aggregate] Who is expected to pay this part of the balance.
  CodeableConcept? get aggregate => throw _privateConstructorUsedError;

  /// [term] The term of the account balances - The balance value is the
  ///  amount that was outstanding for this age.
  CodeableConcept? get term => throw _privateConstructorUsedError;

  /// [estimate] The amount is only an estimated value - this is likely
  ///  common for `current` term balances, but not with known terms (that
  ///  were generated by a backend process).
  FhirBoolean? get estimate => throw _privateConstructorUsedError;

  /// [estimateElement] ("_estimate") Extensions for estimate
  @JsonKey(name: '_estimate')
  Element? get estimateElement => throw _privateConstructorUsedError;

  /// [amount] The actual balance value calculated for the age defined in the
  ///  term property.
  Money get amount => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AccountBalanceCopyWith<AccountBalance> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountBalanceCopyWith<$Res> {
  factory $AccountBalanceCopyWith(
          AccountBalance value, $Res Function(AccountBalance) then) =
      _$AccountBalanceCopyWithImpl<$Res, AccountBalance>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? aggregate,
      CodeableConcept? term,
      FhirBoolean? estimate,
      @JsonKey(name: '_estimate') Element? estimateElement,
      Money amount});

  $CodeableConceptCopyWith<$Res>? get aggregate;
  $CodeableConceptCopyWith<$Res>? get term;
  $ElementCopyWith<$Res>? get estimateElement;
  $MoneyCopyWith<$Res> get amount;
}

/// @nodoc
class _$AccountBalanceCopyWithImpl<$Res, $Val extends AccountBalance>
    implements $AccountBalanceCopyWith<$Res> {
  _$AccountBalanceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? aggregate = freezed,
    Object? term = freezed,
    Object? estimate = freezed,
    Object? estimateElement = freezed,
    Object? amount = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      aggregate: freezed == aggregate
          ? _value.aggregate
          : aggregate // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      term: freezed == term
          ? _value.term
          : term // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      estimate: freezed == estimate
          ? _value.estimate
          : estimate // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      estimateElement: freezed == estimateElement
          ? _value.estimateElement
          : estimateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Money,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get aggregate {
    if (_value.aggregate == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.aggregate!, (value) {
      return _then(_value.copyWith(aggregate: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get term {
    if (_value.term == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.term!, (value) {
      return _then(_value.copyWith(term: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get estimateElement {
    if (_value.estimateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.estimateElement!, (value) {
      return _then(_value.copyWith(estimateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res> get amount {
    return $MoneyCopyWith<$Res>(_value.amount, (value) {
      return _then(_value.copyWith(amount: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AccountBalanceImplCopyWith<$Res>
    implements $AccountBalanceCopyWith<$Res> {
  factory _$$AccountBalanceImplCopyWith(_$AccountBalanceImpl value,
          $Res Function(_$AccountBalanceImpl) then) =
      __$$AccountBalanceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? aggregate,
      CodeableConcept? term,
      FhirBoolean? estimate,
      @JsonKey(name: '_estimate') Element? estimateElement,
      Money amount});

  @override
  $CodeableConceptCopyWith<$Res>? get aggregate;
  @override
  $CodeableConceptCopyWith<$Res>? get term;
  @override
  $ElementCopyWith<$Res>? get estimateElement;
  @override
  $MoneyCopyWith<$Res> get amount;
}

/// @nodoc
class __$$AccountBalanceImplCopyWithImpl<$Res>
    extends _$AccountBalanceCopyWithImpl<$Res, _$AccountBalanceImpl>
    implements _$$AccountBalanceImplCopyWith<$Res> {
  __$$AccountBalanceImplCopyWithImpl(
      _$AccountBalanceImpl _value, $Res Function(_$AccountBalanceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? aggregate = freezed,
    Object? term = freezed,
    Object? estimate = freezed,
    Object? estimateElement = freezed,
    Object? amount = null,
  }) {
    return _then(_$AccountBalanceImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      aggregate: freezed == aggregate
          ? _value.aggregate
          : aggregate // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      term: freezed == term
          ? _value.term
          : term // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      estimate: freezed == estimate
          ? _value.estimate
          : estimate // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      estimateElement: freezed == estimateElement
          ? _value.estimateElement
          : estimateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Money,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AccountBalanceImpl extends _AccountBalance {
  const _$AccountBalanceImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.aggregate,
      this.term,
      this.estimate,
      @JsonKey(name: '_estimate') this.estimateElement,
      required this.amount})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$AccountBalanceImpl.fromJson(Map<String, dynamic> json) =>
      _$$AccountBalanceImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [aggregate] Who is expected to pay this part of the balance.
  @override
  final CodeableConcept? aggregate;

  /// [term] The term of the account balances - The balance value is the
  ///  amount that was outstanding for this age.
  @override
  final CodeableConcept? term;

  /// [estimate] The amount is only an estimated value - this is likely
  ///  common for `current` term balances, but not with known terms (that
  ///  were generated by a backend process).
  @override
  final FhirBoolean? estimate;

  /// [estimateElement] ("_estimate") Extensions for estimate
  @override
  @JsonKey(name: '_estimate')
  final Element? estimateElement;

  /// [amount] The actual balance value calculated for the age defined in the
  ///  term property.
  @override
  final Money amount;

  @override
  String toString() {
    return 'AccountBalance(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, aggregate: $aggregate, term: $term, estimate: $estimate, estimateElement: $estimateElement, amount: $amount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountBalanceImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.aggregate, aggregate) ||
                other.aggregate == aggregate) &&
            (identical(other.term, term) || other.term == term) &&
            (identical(other.estimate, estimate) ||
                other.estimate == estimate) &&
            (identical(other.estimateElement, estimateElement) ||
                other.estimateElement == estimateElement) &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      aggregate,
      term,
      estimate,
      estimateElement,
      amount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountBalanceImplCopyWith<_$AccountBalanceImpl> get copyWith =>
      __$$AccountBalanceImplCopyWithImpl<_$AccountBalanceImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AccountBalanceImplToJson(
      this,
    );
  }
}

abstract class _AccountBalance extends AccountBalance {
  const factory _AccountBalance(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? aggregate,
      final CodeableConcept? term,
      final FhirBoolean? estimate,
      @JsonKey(name: '_estimate') final Element? estimateElement,
      required final Money amount}) = _$AccountBalanceImpl;
  const _AccountBalance._() : super._();

  factory _AccountBalance.fromJson(Map<String, dynamic> json) =
      _$AccountBalanceImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [aggregate] Who is expected to pay this part of the balance.
  CodeableConcept? get aggregate;
  @override

  /// [term] The term of the account balances - The balance value is the
  ///  amount that was outstanding for this age.
  CodeableConcept? get term;
  @override

  /// [estimate] The amount is only an estimated value - this is likely
  ///  common for `current` term balances, but not with known terms (that
  ///  were generated by a backend process).
  FhirBoolean? get estimate;
  @override

  /// [estimateElement] ("_estimate") Extensions for estimate
  @JsonKey(name: '_estimate')
  Element? get estimateElement;
  @override

  /// [amount] The actual balance value calculated for the age defined in the
  ///  term property.
  Money get amount;
  @override
  @JsonKey(ignore: true)
  _$$AccountBalanceImplCopyWith<_$AccountBalanceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChargeItem _$ChargeItemFromJson(Map<String, dynamic> json) {
  return _ChargeItem.fromJson(json);
}

/// @nodoc
mixin _$ChargeItem {
  /// [resourceType] This is a ChargeItem resource
  @JsonKey(unknownEnumValue: R6ResourceType.ChargeItem)
  R6ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  FhirMeta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  FhirCode? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Identifiers assigned to this event performer or other
  ///  systems.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [definitionUri] References the (external) source of pricing
  ///  information, rules of application for the code this ChargeItem uses.
  List<FhirUri>? get definitionUri => throw _privateConstructorUsedError;

  /// [definitionUriElement] ("_definitionUri") Extensions for definitionUri
  @JsonKey(name: '_definitionUri')
  List<Element>? get definitionUriElement => throw _privateConstructorUsedError;

  /// [definitionCanonical] References the source of pricing information,
  ///  rules of application for the code this ChargeItem uses.
  List<FhirCanonical>? get definitionCanonical =>
      throw _privateConstructorUsedError;

  /// [status] The current state of the ChargeItem.
  FhirCode? get status => throw _privateConstructorUsedError;

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement => throw _privateConstructorUsedError;

  /// [partOf] ChargeItems can be grouped to larger ChargeItems covering the
  ///  whole set.
  List<Reference>? get partOf => throw _privateConstructorUsedError;

  /// [code] A code that identifies the charge, like a billing code.
  CodeableConcept get code => throw _privateConstructorUsedError;

  /// [subject] The individual or set of individuals the action is being or
  ///  was performed on.
  Reference get subject => throw _privateConstructorUsedError;

  /// [encounter] This ChargeItem has the details of how the associated
  ///  Encounter should be billed or otherwise be handled by finance systems.
  Reference? get encounter => throw _privateConstructorUsedError;

  /// [occurrenceDateTime] Date/time(s) or duration when the charged service
  ///  was applied.
  FhirDateTime? get occurrenceDateTime => throw _privateConstructorUsedError;

  /// [occurrenceDateTimeElement] ("_occurrenceDateTime") Extensions for
  ///  occurrenceDateTime
  @JsonKey(name: '_occurrenceDateTime')
  Element? get occurrenceDateTimeElement => throw _privateConstructorUsedError;

  /// [occurrencePeriod] Date/time(s) or duration when the charged service
  ///  was applied.
  Period? get occurrencePeriod => throw _privateConstructorUsedError;

  /// [occurrenceTiming] Date/time(s) or duration when the charged service
  ///  was applied.
  Timing? get occurrenceTiming => throw _privateConstructorUsedError;

  /// [performer] Indicates who or what performed or participated in the
  ///  charged service.
  List<ChargeItemPerformer>? get performer =>
      throw _privateConstructorUsedError;

  /// [performingOrganization] The organization performing the service.
  Reference? get performingOrganization => throw _privateConstructorUsedError;

  /// [requestingOrganization] The organization requesting the service.
  Reference? get requestingOrganization => throw _privateConstructorUsedError;

  /// [costCenter] The financial cost center permits the tracking of charge
  ///  attribution.
  Reference? get costCenter => throw _privateConstructorUsedError;

  /// [quantity] Quantity of which the charge item has been serviced.
  Quantity? get quantity => throw _privateConstructorUsedError;

  /// [bodysite] The anatomical location where the related service has been
  ///  applied.
  List<CodeableConcept>? get bodysite => throw _privateConstructorUsedError;

  /// [unitPriceComponent] The unit price of the chargable item.
  MonetaryComponent? get unitPriceComponent =>
      throw _privateConstructorUsedError;

  /// [totalPriceComponent] The total price for the chargable item,
  ///  accounting for the quantity.
  MonetaryComponent? get totalPriceComponent =>
      throw _privateConstructorUsedError;

  /// [overrideReason] If the list price or the rule-based factor associated
  ///  with the code is overridden, this attribute can capture a text to
  ///  indicate the  reason for this action.
  CodeableConcept? get overrideReason => throw _privateConstructorUsedError;

  /// [enterer] The device, practitioner, etc. who entered the charge item.
  Reference? get enterer => throw _privateConstructorUsedError;

  /// [enteredDate] Date the charge item was entered.
  FhirDateTime? get enteredDate => throw _privateConstructorUsedError;

  /// [enteredDateElement] ("_enteredDate") Extensions for enteredDate
  @JsonKey(name: '_enteredDate')
  Element? get enteredDateElement => throw _privateConstructorUsedError;

  /// [reason] Describes why the event occurred in coded or textual form.
  List<CodeableConcept>? get reason => throw _privateConstructorUsedError;

  /// [service] Indicated the rendered service that caused this charge.
  List<CodeableReference>? get service => throw _privateConstructorUsedError;

  /// [product] Identifies the device, food, drug or other product being
  ///  charged either by type code or reference to an instance.
  List<CodeableReference>? get product => throw _privateConstructorUsedError;

  /// [account] Account into which this ChargeItems belongs.
  List<Reference>? get account => throw _privateConstructorUsedError;

  /// [note] Comments made about the event by the performer, subject or other
  ///  participants.
  List<Annotation>? get note => throw _privateConstructorUsedError;

  /// [supportingInformation] Further information supporting this charge.
  List<Reference>? get supportingInformation =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChargeItemCopyWith<ChargeItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChargeItemCopyWith<$Res> {
  factory $ChargeItemCopyWith(
          ChargeItem value, $Res Function(ChargeItem) then) =
      _$ChargeItemCopyWithImpl<$Res, ChargeItem>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.ChargeItem)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      List<FhirUri>? definitionUri,
      @JsonKey(name: '_definitionUri') List<Element>? definitionUriElement,
      List<FhirCanonical>? definitionCanonical,
      FhirCode? status,
      @JsonKey(name: '_status') Element? statusElement,
      List<Reference>? partOf,
      CodeableConcept code,
      Reference subject,
      Reference? encounter,
      FhirDateTime? occurrenceDateTime,
      @JsonKey(name: '_occurrenceDateTime') Element? occurrenceDateTimeElement,
      Period? occurrencePeriod,
      Timing? occurrenceTiming,
      List<ChargeItemPerformer>? performer,
      Reference? performingOrganization,
      Reference? requestingOrganization,
      Reference? costCenter,
      Quantity? quantity,
      List<CodeableConcept>? bodysite,
      MonetaryComponent? unitPriceComponent,
      MonetaryComponent? totalPriceComponent,
      CodeableConcept? overrideReason,
      Reference? enterer,
      FhirDateTime? enteredDate,
      @JsonKey(name: '_enteredDate') Element? enteredDateElement,
      List<CodeableConcept>? reason,
      List<CodeableReference>? service,
      List<CodeableReference>? product,
      List<Reference>? account,
      List<Annotation>? note,
      List<Reference>? supportingInformation});

  $FhirMetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get statusElement;
  $CodeableConceptCopyWith<$Res> get code;
  $ReferenceCopyWith<$Res> get subject;
  $ReferenceCopyWith<$Res>? get encounter;
  $ElementCopyWith<$Res>? get occurrenceDateTimeElement;
  $PeriodCopyWith<$Res>? get occurrencePeriod;
  $TimingCopyWith<$Res>? get occurrenceTiming;
  $ReferenceCopyWith<$Res>? get performingOrganization;
  $ReferenceCopyWith<$Res>? get requestingOrganization;
  $ReferenceCopyWith<$Res>? get costCenter;
  $QuantityCopyWith<$Res>? get quantity;
  $MonetaryComponentCopyWith<$Res>? get unitPriceComponent;
  $MonetaryComponentCopyWith<$Res>? get totalPriceComponent;
  $CodeableConceptCopyWith<$Res>? get overrideReason;
  $ReferenceCopyWith<$Res>? get enterer;
  $ElementCopyWith<$Res>? get enteredDateElement;
}

/// @nodoc
class _$ChargeItemCopyWithImpl<$Res, $Val extends ChargeItem>
    implements $ChargeItemCopyWith<$Res> {
  _$ChargeItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? definitionUri = freezed,
    Object? definitionUriElement = freezed,
    Object? definitionCanonical = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? partOf = freezed,
    Object? code = null,
    Object? subject = null,
    Object? encounter = freezed,
    Object? occurrenceDateTime = freezed,
    Object? occurrenceDateTimeElement = freezed,
    Object? occurrencePeriod = freezed,
    Object? occurrenceTiming = freezed,
    Object? performer = freezed,
    Object? performingOrganization = freezed,
    Object? requestingOrganization = freezed,
    Object? costCenter = freezed,
    Object? quantity = freezed,
    Object? bodysite = freezed,
    Object? unitPriceComponent = freezed,
    Object? totalPriceComponent = freezed,
    Object? overrideReason = freezed,
    Object? enterer = freezed,
    Object? enteredDate = freezed,
    Object? enteredDateElement = freezed,
    Object? reason = freezed,
    Object? service = freezed,
    Object? product = freezed,
    Object? account = freezed,
    Object? note = freezed,
    Object? supportingInformation = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      definitionUri: freezed == definitionUri
          ? _value.definitionUri
          : definitionUri // ignore: cast_nullable_to_non_nullable
              as List<FhirUri>?,
      definitionUriElement: freezed == definitionUriElement
          ? _value.definitionUriElement
          : definitionUriElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      definitionCanonical: freezed == definitionCanonical
          ? _value.definitionCanonical
          : definitionCanonical // ignore: cast_nullable_to_non_nullable
              as List<FhirCanonical>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      partOf: freezed == partOf
          ? _value.partOf
          : partOf // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      subject: null == subject
          ? _value.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as Reference,
      encounter: freezed == encounter
          ? _value.encounter
          : encounter // ignore: cast_nullable_to_non_nullable
              as Reference?,
      occurrenceDateTime: freezed == occurrenceDateTime
          ? _value.occurrenceDateTime
          : occurrenceDateTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      occurrenceDateTimeElement: freezed == occurrenceDateTimeElement
          ? _value.occurrenceDateTimeElement
          : occurrenceDateTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      occurrencePeriod: freezed == occurrencePeriod
          ? _value.occurrencePeriod
          : occurrencePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      occurrenceTiming: freezed == occurrenceTiming
          ? _value.occurrenceTiming
          : occurrenceTiming // ignore: cast_nullable_to_non_nullable
              as Timing?,
      performer: freezed == performer
          ? _value.performer
          : performer // ignore: cast_nullable_to_non_nullable
              as List<ChargeItemPerformer>?,
      performingOrganization: freezed == performingOrganization
          ? _value.performingOrganization
          : performingOrganization // ignore: cast_nullable_to_non_nullable
              as Reference?,
      requestingOrganization: freezed == requestingOrganization
          ? _value.requestingOrganization
          : requestingOrganization // ignore: cast_nullable_to_non_nullable
              as Reference?,
      costCenter: freezed == costCenter
          ? _value.costCenter
          : costCenter // ignore: cast_nullable_to_non_nullable
              as Reference?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      bodysite: freezed == bodysite
          ? _value.bodysite
          : bodysite // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      unitPriceComponent: freezed == unitPriceComponent
          ? _value.unitPriceComponent
          : unitPriceComponent // ignore: cast_nullable_to_non_nullable
              as MonetaryComponent?,
      totalPriceComponent: freezed == totalPriceComponent
          ? _value.totalPriceComponent
          : totalPriceComponent // ignore: cast_nullable_to_non_nullable
              as MonetaryComponent?,
      overrideReason: freezed == overrideReason
          ? _value.overrideReason
          : overrideReason // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      enterer: freezed == enterer
          ? _value.enterer
          : enterer // ignore: cast_nullable_to_non_nullable
              as Reference?,
      enteredDate: freezed == enteredDate
          ? _value.enteredDate
          : enteredDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      enteredDateElement: freezed == enteredDateElement
          ? _value.enteredDateElement
          : enteredDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      service: freezed == service
          ? _value.service
          : service // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      product: freezed == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      account: freezed == account
          ? _value.account
          : account // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      note: freezed == note
          ? _value.note
          : note // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      supportingInformation: freezed == supportingInformation
          ? _value.supportingInformation
          : supportingInformation // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FhirMetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $FhirMetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusElement {
    if (_value.statusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusElement!, (value) {
      return _then(_value.copyWith(statusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get code {
    return $CodeableConceptCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get subject {
    return $ReferenceCopyWith<$Res>(_value.subject, (value) {
      return _then(_value.copyWith(subject: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get encounter {
    if (_value.encounter == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.encounter!, (value) {
      return _then(_value.copyWith(encounter: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get occurrenceDateTimeElement {
    if (_value.occurrenceDateTimeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.occurrenceDateTimeElement!, (value) {
      return _then(_value.copyWith(occurrenceDateTimeElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get occurrencePeriod {
    if (_value.occurrencePeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.occurrencePeriod!, (value) {
      return _then(_value.copyWith(occurrencePeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TimingCopyWith<$Res>? get occurrenceTiming {
    if (_value.occurrenceTiming == null) {
      return null;
    }

    return $TimingCopyWith<$Res>(_value.occurrenceTiming!, (value) {
      return _then(_value.copyWith(occurrenceTiming: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get performingOrganization {
    if (_value.performingOrganization == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.performingOrganization!, (value) {
      return _then(_value.copyWith(performingOrganization: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get requestingOrganization {
    if (_value.requestingOrganization == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.requestingOrganization!, (value) {
      return _then(_value.copyWith(requestingOrganization: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get costCenter {
    if (_value.costCenter == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.costCenter!, (value) {
      return _then(_value.copyWith(costCenter: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get quantity {
    if (_value.quantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.quantity!, (value) {
      return _then(_value.copyWith(quantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MonetaryComponentCopyWith<$Res>? get unitPriceComponent {
    if (_value.unitPriceComponent == null) {
      return null;
    }

    return $MonetaryComponentCopyWith<$Res>(_value.unitPriceComponent!,
        (value) {
      return _then(_value.copyWith(unitPriceComponent: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MonetaryComponentCopyWith<$Res>? get totalPriceComponent {
    if (_value.totalPriceComponent == null) {
      return null;
    }

    return $MonetaryComponentCopyWith<$Res>(_value.totalPriceComponent!,
        (value) {
      return _then(_value.copyWith(totalPriceComponent: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get overrideReason {
    if (_value.overrideReason == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.overrideReason!, (value) {
      return _then(_value.copyWith(overrideReason: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get enterer {
    if (_value.enterer == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.enterer!, (value) {
      return _then(_value.copyWith(enterer: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get enteredDateElement {
    if (_value.enteredDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.enteredDateElement!, (value) {
      return _then(_value.copyWith(enteredDateElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChargeItemImplCopyWith<$Res>
    implements $ChargeItemCopyWith<$Res> {
  factory _$$ChargeItemImplCopyWith(
          _$ChargeItemImpl value, $Res Function(_$ChargeItemImpl) then) =
      __$$ChargeItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.ChargeItem)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      List<FhirUri>? definitionUri,
      @JsonKey(name: '_definitionUri') List<Element>? definitionUriElement,
      List<FhirCanonical>? definitionCanonical,
      FhirCode? status,
      @JsonKey(name: '_status') Element? statusElement,
      List<Reference>? partOf,
      CodeableConcept code,
      Reference subject,
      Reference? encounter,
      FhirDateTime? occurrenceDateTime,
      @JsonKey(name: '_occurrenceDateTime') Element? occurrenceDateTimeElement,
      Period? occurrencePeriod,
      Timing? occurrenceTiming,
      List<ChargeItemPerformer>? performer,
      Reference? performingOrganization,
      Reference? requestingOrganization,
      Reference? costCenter,
      Quantity? quantity,
      List<CodeableConcept>? bodysite,
      MonetaryComponent? unitPriceComponent,
      MonetaryComponent? totalPriceComponent,
      CodeableConcept? overrideReason,
      Reference? enterer,
      FhirDateTime? enteredDate,
      @JsonKey(name: '_enteredDate') Element? enteredDateElement,
      List<CodeableConcept>? reason,
      List<CodeableReference>? service,
      List<CodeableReference>? product,
      List<Reference>? account,
      List<Annotation>? note,
      List<Reference>? supportingInformation});

  @override
  $FhirMetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get statusElement;
  @override
  $CodeableConceptCopyWith<$Res> get code;
  @override
  $ReferenceCopyWith<$Res> get subject;
  @override
  $ReferenceCopyWith<$Res>? get encounter;
  @override
  $ElementCopyWith<$Res>? get occurrenceDateTimeElement;
  @override
  $PeriodCopyWith<$Res>? get occurrencePeriod;
  @override
  $TimingCopyWith<$Res>? get occurrenceTiming;
  @override
  $ReferenceCopyWith<$Res>? get performingOrganization;
  @override
  $ReferenceCopyWith<$Res>? get requestingOrganization;
  @override
  $ReferenceCopyWith<$Res>? get costCenter;
  @override
  $QuantityCopyWith<$Res>? get quantity;
  @override
  $MonetaryComponentCopyWith<$Res>? get unitPriceComponent;
  @override
  $MonetaryComponentCopyWith<$Res>? get totalPriceComponent;
  @override
  $CodeableConceptCopyWith<$Res>? get overrideReason;
  @override
  $ReferenceCopyWith<$Res>? get enterer;
  @override
  $ElementCopyWith<$Res>? get enteredDateElement;
}

/// @nodoc
class __$$ChargeItemImplCopyWithImpl<$Res>
    extends _$ChargeItemCopyWithImpl<$Res, _$ChargeItemImpl>
    implements _$$ChargeItemImplCopyWith<$Res> {
  __$$ChargeItemImplCopyWithImpl(
      _$ChargeItemImpl _value, $Res Function(_$ChargeItemImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? definitionUri = freezed,
    Object? definitionUriElement = freezed,
    Object? definitionCanonical = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? partOf = freezed,
    Object? code = null,
    Object? subject = null,
    Object? encounter = freezed,
    Object? occurrenceDateTime = freezed,
    Object? occurrenceDateTimeElement = freezed,
    Object? occurrencePeriod = freezed,
    Object? occurrenceTiming = freezed,
    Object? performer = freezed,
    Object? performingOrganization = freezed,
    Object? requestingOrganization = freezed,
    Object? costCenter = freezed,
    Object? quantity = freezed,
    Object? bodysite = freezed,
    Object? unitPriceComponent = freezed,
    Object? totalPriceComponent = freezed,
    Object? overrideReason = freezed,
    Object? enterer = freezed,
    Object? enteredDate = freezed,
    Object? enteredDateElement = freezed,
    Object? reason = freezed,
    Object? service = freezed,
    Object? product = freezed,
    Object? account = freezed,
    Object? note = freezed,
    Object? supportingInformation = freezed,
  }) {
    return _then(_$ChargeItemImpl(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      definitionUri: freezed == definitionUri
          ? _value._definitionUri
          : definitionUri // ignore: cast_nullable_to_non_nullable
              as List<FhirUri>?,
      definitionUriElement: freezed == definitionUriElement
          ? _value._definitionUriElement
          : definitionUriElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      definitionCanonical: freezed == definitionCanonical
          ? _value._definitionCanonical
          : definitionCanonical // ignore: cast_nullable_to_non_nullable
              as List<FhirCanonical>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      partOf: freezed == partOf
          ? _value._partOf
          : partOf // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      subject: null == subject
          ? _value.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as Reference,
      encounter: freezed == encounter
          ? _value.encounter
          : encounter // ignore: cast_nullable_to_non_nullable
              as Reference?,
      occurrenceDateTime: freezed == occurrenceDateTime
          ? _value.occurrenceDateTime
          : occurrenceDateTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      occurrenceDateTimeElement: freezed == occurrenceDateTimeElement
          ? _value.occurrenceDateTimeElement
          : occurrenceDateTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      occurrencePeriod: freezed == occurrencePeriod
          ? _value.occurrencePeriod
          : occurrencePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      occurrenceTiming: freezed == occurrenceTiming
          ? _value.occurrenceTiming
          : occurrenceTiming // ignore: cast_nullable_to_non_nullable
              as Timing?,
      performer: freezed == performer
          ? _value._performer
          : performer // ignore: cast_nullable_to_non_nullable
              as List<ChargeItemPerformer>?,
      performingOrganization: freezed == performingOrganization
          ? _value.performingOrganization
          : performingOrganization // ignore: cast_nullable_to_non_nullable
              as Reference?,
      requestingOrganization: freezed == requestingOrganization
          ? _value.requestingOrganization
          : requestingOrganization // ignore: cast_nullable_to_non_nullable
              as Reference?,
      costCenter: freezed == costCenter
          ? _value.costCenter
          : costCenter // ignore: cast_nullable_to_non_nullable
              as Reference?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      bodysite: freezed == bodysite
          ? _value._bodysite
          : bodysite // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      unitPriceComponent: freezed == unitPriceComponent
          ? _value.unitPriceComponent
          : unitPriceComponent // ignore: cast_nullable_to_non_nullable
              as MonetaryComponent?,
      totalPriceComponent: freezed == totalPriceComponent
          ? _value.totalPriceComponent
          : totalPriceComponent // ignore: cast_nullable_to_non_nullable
              as MonetaryComponent?,
      overrideReason: freezed == overrideReason
          ? _value.overrideReason
          : overrideReason // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      enterer: freezed == enterer
          ? _value.enterer
          : enterer // ignore: cast_nullable_to_non_nullable
              as Reference?,
      enteredDate: freezed == enteredDate
          ? _value.enteredDate
          : enteredDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      enteredDateElement: freezed == enteredDateElement
          ? _value.enteredDateElement
          : enteredDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      reason: freezed == reason
          ? _value._reason
          : reason // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      service: freezed == service
          ? _value._service
          : service // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      product: freezed == product
          ? _value._product
          : product // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      account: freezed == account
          ? _value._account
          : account // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      note: freezed == note
          ? _value._note
          : note // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      supportingInformation: freezed == supportingInformation
          ? _value._supportingInformation
          : supportingInformation // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChargeItemImpl extends _ChargeItem {
  const _$ChargeItemImpl(
      {@JsonKey(unknownEnumValue: R6ResourceType.ChargeItem)
      this.resourceType = R6ResourceType.ChargeItem,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final List<FhirUri>? definitionUri,
      @JsonKey(name: '_definitionUri')
      final List<Element>? definitionUriElement,
      final List<FhirCanonical>? definitionCanonical,
      this.status,
      @JsonKey(name: '_status') this.statusElement,
      final List<Reference>? partOf,
      required this.code,
      required this.subject,
      this.encounter,
      this.occurrenceDateTime,
      @JsonKey(name: '_occurrenceDateTime') this.occurrenceDateTimeElement,
      this.occurrencePeriod,
      this.occurrenceTiming,
      final List<ChargeItemPerformer>? performer,
      this.performingOrganization,
      this.requestingOrganization,
      this.costCenter,
      this.quantity,
      final List<CodeableConcept>? bodysite,
      this.unitPriceComponent,
      this.totalPriceComponent,
      this.overrideReason,
      this.enterer,
      this.enteredDate,
      @JsonKey(name: '_enteredDate') this.enteredDateElement,
      final List<CodeableConcept>? reason,
      final List<CodeableReference>? service,
      final List<CodeableReference>? product,
      final List<Reference>? account,
      final List<Annotation>? note,
      final List<Reference>? supportingInformation})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _definitionUri = definitionUri,
        _definitionUriElement = definitionUriElement,
        _definitionCanonical = definitionCanonical,
        _partOf = partOf,
        _performer = performer,
        _bodysite = bodysite,
        _reason = reason,
        _service = service,
        _product = product,
        _account = account,
        _note = note,
        _supportingInformation = supportingInformation,
        super._();

  factory _$ChargeItemImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChargeItemImplFromJson(json);

  /// [resourceType] This is a ChargeItem resource
  @override
  @JsonKey(unknownEnumValue: R6ResourceType.ChargeItem)
  final R6ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  @override
  final FhirMeta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final FhirCode? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Identifiers assigned to this event performer or other
  ///  systems.
  final List<Identifier>? _identifier;

  /// [identifier] Identifiers assigned to this event performer or other
  ///  systems.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [definitionUri] References the (external) source of pricing
  ///  information, rules of application for the code this ChargeItem uses.
  final List<FhirUri>? _definitionUri;

  /// [definitionUri] References the (external) source of pricing
  ///  information, rules of application for the code this ChargeItem uses.
  @override
  List<FhirUri>? get definitionUri {
    final value = _definitionUri;
    if (value == null) return null;
    if (_definitionUri is EqualUnmodifiableListView) return _definitionUri;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [definitionUriElement] ("_definitionUri") Extensions for definitionUri
  final List<Element>? _definitionUriElement;

  /// [definitionUriElement] ("_definitionUri") Extensions for definitionUri
  @override
  @JsonKey(name: '_definitionUri')
  List<Element>? get definitionUriElement {
    final value = _definitionUriElement;
    if (value == null) return null;
    if (_definitionUriElement is EqualUnmodifiableListView)
      return _definitionUriElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [definitionCanonical] References the source of pricing information,
  ///  rules of application for the code this ChargeItem uses.
  final List<FhirCanonical>? _definitionCanonical;

  /// [definitionCanonical] References the source of pricing information,
  ///  rules of application for the code this ChargeItem uses.
  @override
  List<FhirCanonical>? get definitionCanonical {
    final value = _definitionCanonical;
    if (value == null) return null;
    if (_definitionCanonical is EqualUnmodifiableListView)
      return _definitionCanonical;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] The current state of the ChargeItem.
  @override
  final FhirCode? status;

  /// [statusElement] ("_status") Extensions for status
  @override
  @JsonKey(name: '_status')
  final Element? statusElement;

  /// [partOf] ChargeItems can be grouped to larger ChargeItems covering the
  ///  whole set.
  final List<Reference>? _partOf;

  /// [partOf] ChargeItems can be grouped to larger ChargeItems covering the
  ///  whole set.
  @override
  List<Reference>? get partOf {
    final value = _partOf;
    if (value == null) return null;
    if (_partOf is EqualUnmodifiableListView) return _partOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] A code that identifies the charge, like a billing code.
  @override
  final CodeableConcept code;

  /// [subject] The individual or set of individuals the action is being or
  ///  was performed on.
  @override
  final Reference subject;

  /// [encounter] This ChargeItem has the details of how the associated
  ///  Encounter should be billed or otherwise be handled by finance systems.
  @override
  final Reference? encounter;

  /// [occurrenceDateTime] Date/time(s) or duration when the charged service
  ///  was applied.
  @override
  final FhirDateTime? occurrenceDateTime;

  /// [occurrenceDateTimeElement] ("_occurrenceDateTime") Extensions for
  ///  occurrenceDateTime
  @override
  @JsonKey(name: '_occurrenceDateTime')
  final Element? occurrenceDateTimeElement;

  /// [occurrencePeriod] Date/time(s) or duration when the charged service
  ///  was applied.
  @override
  final Period? occurrencePeriod;

  /// [occurrenceTiming] Date/time(s) or duration when the charged service
  ///  was applied.
  @override
  final Timing? occurrenceTiming;

  /// [performer] Indicates who or what performed or participated in the
  ///  charged service.
  final List<ChargeItemPerformer>? _performer;

  /// [performer] Indicates who or what performed or participated in the
  ///  charged service.
  @override
  List<ChargeItemPerformer>? get performer {
    final value = _performer;
    if (value == null) return null;
    if (_performer is EqualUnmodifiableListView) return _performer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [performingOrganization] The organization performing the service.
  @override
  final Reference? performingOrganization;

  /// [requestingOrganization] The organization requesting the service.
  @override
  final Reference? requestingOrganization;

  /// [costCenter] The financial cost center permits the tracking of charge
  ///  attribution.
  @override
  final Reference? costCenter;

  /// [quantity] Quantity of which the charge item has been serviced.
  @override
  final Quantity? quantity;

  /// [bodysite] The anatomical location where the related service has been
  ///  applied.
  final List<CodeableConcept>? _bodysite;

  /// [bodysite] The anatomical location where the related service has been
  ///  applied.
  @override
  List<CodeableConcept>? get bodysite {
    final value = _bodysite;
    if (value == null) return null;
    if (_bodysite is EqualUnmodifiableListView) return _bodysite;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [unitPriceComponent] The unit price of the chargable item.
  @override
  final MonetaryComponent? unitPriceComponent;

  /// [totalPriceComponent] The total price for the chargable item,
  ///  accounting for the quantity.
  @override
  final MonetaryComponent? totalPriceComponent;

  /// [overrideReason] If the list price or the rule-based factor associated
  ///  with the code is overridden, this attribute can capture a text to
  ///  indicate the  reason for this action.
  @override
  final CodeableConcept? overrideReason;

  /// [enterer] The device, practitioner, etc. who entered the charge item.
  @override
  final Reference? enterer;

  /// [enteredDate] Date the charge item was entered.
  @override
  final FhirDateTime? enteredDate;

  /// [enteredDateElement] ("_enteredDate") Extensions for enteredDate
  @override
  @JsonKey(name: '_enteredDate')
  final Element? enteredDateElement;

  /// [reason] Describes why the event occurred in coded or textual form.
  final List<CodeableConcept>? _reason;

  /// [reason] Describes why the event occurred in coded or textual form.
  @override
  List<CodeableConcept>? get reason {
    final value = _reason;
    if (value == null) return null;
    if (_reason is EqualUnmodifiableListView) return _reason;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [service] Indicated the rendered service that caused this charge.
  final List<CodeableReference>? _service;

  /// [service] Indicated the rendered service that caused this charge.
  @override
  List<CodeableReference>? get service {
    final value = _service;
    if (value == null) return null;
    if (_service is EqualUnmodifiableListView) return _service;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [product] Identifies the device, food, drug or other product being
  ///  charged either by type code or reference to an instance.
  final List<CodeableReference>? _product;

  /// [product] Identifies the device, food, drug or other product being
  ///  charged either by type code or reference to an instance.
  @override
  List<CodeableReference>? get product {
    final value = _product;
    if (value == null) return null;
    if (_product is EqualUnmodifiableListView) return _product;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [account] Account into which this ChargeItems belongs.
  final List<Reference>? _account;

  /// [account] Account into which this ChargeItems belongs.
  @override
  List<Reference>? get account {
    final value = _account;
    if (value == null) return null;
    if (_account is EqualUnmodifiableListView) return _account;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [note] Comments made about the event by the performer, subject or other
  ///  participants.
  final List<Annotation>? _note;

  /// [note] Comments made about the event by the performer, subject or other
  ///  participants.
  @override
  List<Annotation>? get note {
    final value = _note;
    if (value == null) return null;
    if (_note is EqualUnmodifiableListView) return _note;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [supportingInformation] Further information supporting this charge.
  final List<Reference>? _supportingInformation;

  /// [supportingInformation] Further information supporting this charge.
  @override
  List<Reference>? get supportingInformation {
    final value = _supportingInformation;
    if (value == null) return null;
    if (_supportingInformation is EqualUnmodifiableListView)
      return _supportingInformation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ChargeItem(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, definitionUri: $definitionUri, definitionUriElement: $definitionUriElement, definitionCanonical: $definitionCanonical, status: $status, statusElement: $statusElement, partOf: $partOf, code: $code, subject: $subject, encounter: $encounter, occurrenceDateTime: $occurrenceDateTime, occurrenceDateTimeElement: $occurrenceDateTimeElement, occurrencePeriod: $occurrencePeriod, occurrenceTiming: $occurrenceTiming, performer: $performer, performingOrganization: $performingOrganization, requestingOrganization: $requestingOrganization, costCenter: $costCenter, quantity: $quantity, bodysite: $bodysite, unitPriceComponent: $unitPriceComponent, totalPriceComponent: $totalPriceComponent, overrideReason: $overrideReason, enterer: $enterer, enteredDate: $enteredDate, enteredDateElement: $enteredDateElement, reason: $reason, service: $service, product: $product, account: $account, note: $note, supportingInformation: $supportingInformation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChargeItemImpl &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            const DeepCollectionEquality()
                .equals(other._definitionUri, _definitionUri) &&
            const DeepCollectionEquality()
                .equals(other._definitionUriElement, _definitionUriElement) &&
            const DeepCollectionEquality()
                .equals(other._definitionCanonical, _definitionCanonical) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusElement, statusElement) ||
                other.statusElement == statusElement) &&
            const DeepCollectionEquality().equals(other._partOf, _partOf) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.subject, subject) || other.subject == subject) &&
            (identical(other.encounter, encounter) ||
                other.encounter == encounter) &&
            (identical(other.occurrenceDateTime, occurrenceDateTime) ||
                other.occurrenceDateTime == occurrenceDateTime) &&
            (identical(other.occurrenceDateTimeElement,
                    occurrenceDateTimeElement) ||
                other.occurrenceDateTimeElement == occurrenceDateTimeElement) &&
            (identical(other.occurrencePeriod, occurrencePeriod) ||
                other.occurrencePeriod == occurrencePeriod) &&
            (identical(other.occurrenceTiming, occurrenceTiming) ||
                other.occurrenceTiming == occurrenceTiming) &&
            const DeepCollectionEquality()
                .equals(other._performer, _performer) &&
            (identical(other.performingOrganization, performingOrganization) ||
                other.performingOrganization == performingOrganization) &&
            (identical(other.requestingOrganization, requestingOrganization) ||
                other.requestingOrganization == requestingOrganization) &&
            (identical(other.costCenter, costCenter) ||
                other.costCenter == costCenter) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            const DeepCollectionEquality().equals(other._bodysite, _bodysite) &&
            (identical(other.unitPriceComponent, unitPriceComponent) ||
                other.unitPriceComponent == unitPriceComponent) &&
            (identical(other.totalPriceComponent, totalPriceComponent) ||
                other.totalPriceComponent == totalPriceComponent) &&
            (identical(other.overrideReason, overrideReason) ||
                other.overrideReason == overrideReason) &&
            (identical(other.enterer, enterer) || other.enterer == enterer) &&
            (identical(other.enteredDate, enteredDate) ||
                other.enteredDate == enteredDate) &&
            (identical(other.enteredDateElement, enteredDateElement) ||
                other.enteredDateElement == enteredDateElement) &&
            const DeepCollectionEquality().equals(other._reason, _reason) &&
            const DeepCollectionEquality().equals(other._service, _service) &&
            const DeepCollectionEquality().equals(other._product, _product) &&
            const DeepCollectionEquality().equals(other._account, _account) &&
            const DeepCollectionEquality().equals(other._note, _note) &&
            const DeepCollectionEquality()
                .equals(other._supportingInformation, _supportingInformation));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        const DeepCollectionEquality().hash(_definitionUri),
        const DeepCollectionEquality().hash(_definitionUriElement),
        const DeepCollectionEquality().hash(_definitionCanonical),
        status,
        statusElement,
        const DeepCollectionEquality().hash(_partOf),
        code,
        subject,
        encounter,
        occurrenceDateTime,
        occurrenceDateTimeElement,
        occurrencePeriod,
        occurrenceTiming,
        const DeepCollectionEquality().hash(_performer),
        performingOrganization,
        requestingOrganization,
        costCenter,
        quantity,
        const DeepCollectionEquality().hash(_bodysite),
        unitPriceComponent,
        totalPriceComponent,
        overrideReason,
        enterer,
        enteredDate,
        enteredDateElement,
        const DeepCollectionEquality().hash(_reason),
        const DeepCollectionEquality().hash(_service),
        const DeepCollectionEquality().hash(_product),
        const DeepCollectionEquality().hash(_account),
        const DeepCollectionEquality().hash(_note),
        const DeepCollectionEquality().hash(_supportingInformation)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChargeItemImplCopyWith<_$ChargeItemImpl> get copyWith =>
      __$$ChargeItemImplCopyWithImpl<_$ChargeItemImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChargeItemImplToJson(
      this,
    );
  }
}

abstract class _ChargeItem extends ChargeItem {
  const factory _ChargeItem(
      {@JsonKey(unknownEnumValue: R6ResourceType.ChargeItem)
      final R6ResourceType resourceType,
      final FhirId? id,
      final FhirMeta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
      final FhirCode? language,
      @JsonKey(name: '_language') final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final List<FhirUri>? definitionUri,
      @JsonKey(name: '_definitionUri')
      final List<Element>? definitionUriElement,
      final List<FhirCanonical>? definitionCanonical,
      final FhirCode? status,
      @JsonKey(name: '_status') final Element? statusElement,
      final List<Reference>? partOf,
      required final CodeableConcept code,
      required final Reference subject,
      final Reference? encounter,
      final FhirDateTime? occurrenceDateTime,
      @JsonKey(name: '_occurrenceDateTime')
      final Element? occurrenceDateTimeElement,
      final Period? occurrencePeriod,
      final Timing? occurrenceTiming,
      final List<ChargeItemPerformer>? performer,
      final Reference? performingOrganization,
      final Reference? requestingOrganization,
      final Reference? costCenter,
      final Quantity? quantity,
      final List<CodeableConcept>? bodysite,
      final MonetaryComponent? unitPriceComponent,
      final MonetaryComponent? totalPriceComponent,
      final CodeableConcept? overrideReason,
      final Reference? enterer,
      final FhirDateTime? enteredDate,
      @JsonKey(name: '_enteredDate') final Element? enteredDateElement,
      final List<CodeableConcept>? reason,
      final List<CodeableReference>? service,
      final List<CodeableReference>? product,
      final List<Reference>? account,
      final List<Annotation>? note,
      final List<Reference>? supportingInformation}) = _$ChargeItemImpl;
  const _ChargeItem._() : super._();

  factory _ChargeItem.fromJson(Map<String, dynamic> json) =
      _$ChargeItemImpl.fromJson;

  @override

  /// [resourceType] This is a ChargeItem resource
  @JsonKey(unknownEnumValue: R6ResourceType.ChargeItem)
  R6ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  FhirMeta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  FhirCode? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Identifiers assigned to this event performer or other
  ///  systems.
  List<Identifier>? get identifier;
  @override

  /// [definitionUri] References the (external) source of pricing
  ///  information, rules of application for the code this ChargeItem uses.
  List<FhirUri>? get definitionUri;
  @override

  /// [definitionUriElement] ("_definitionUri") Extensions for definitionUri
  @JsonKey(name: '_definitionUri')
  List<Element>? get definitionUriElement;
  @override

  /// [definitionCanonical] References the source of pricing information,
  ///  rules of application for the code this ChargeItem uses.
  List<FhirCanonical>? get definitionCanonical;
  @override

  /// [status] The current state of the ChargeItem.
  FhirCode? get status;
  @override

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement;
  @override

  /// [partOf] ChargeItems can be grouped to larger ChargeItems covering the
  ///  whole set.
  List<Reference>? get partOf;
  @override

  /// [code] A code that identifies the charge, like a billing code.
  CodeableConcept get code;
  @override

  /// [subject] The individual or set of individuals the action is being or
  ///  was performed on.
  Reference get subject;
  @override

  /// [encounter] This ChargeItem has the details of how the associated
  ///  Encounter should be billed or otherwise be handled by finance systems.
  Reference? get encounter;
  @override

  /// [occurrenceDateTime] Date/time(s) or duration when the charged service
  ///  was applied.
  FhirDateTime? get occurrenceDateTime;
  @override

  /// [occurrenceDateTimeElement] ("_occurrenceDateTime") Extensions for
  ///  occurrenceDateTime
  @JsonKey(name: '_occurrenceDateTime')
  Element? get occurrenceDateTimeElement;
  @override

  /// [occurrencePeriod] Date/time(s) or duration when the charged service
  ///  was applied.
  Period? get occurrencePeriod;
  @override

  /// [occurrenceTiming] Date/time(s) or duration when the charged service
  ///  was applied.
  Timing? get occurrenceTiming;
  @override

  /// [performer] Indicates who or what performed or participated in the
  ///  charged service.
  List<ChargeItemPerformer>? get performer;
  @override

  /// [performingOrganization] The organization performing the service.
  Reference? get performingOrganization;
  @override

  /// [requestingOrganization] The organization requesting the service.
  Reference? get requestingOrganization;
  @override

  /// [costCenter] The financial cost center permits the tracking of charge
  ///  attribution.
  Reference? get costCenter;
  @override

  /// [quantity] Quantity of which the charge item has been serviced.
  Quantity? get quantity;
  @override

  /// [bodysite] The anatomical location where the related service has been
  ///  applied.
  List<CodeableConcept>? get bodysite;
  @override

  /// [unitPriceComponent] The unit price of the chargable item.
  MonetaryComponent? get unitPriceComponent;
  @override

  /// [totalPriceComponent] The total price for the chargable item,
  ///  accounting for the quantity.
  MonetaryComponent? get totalPriceComponent;
  @override

  /// [overrideReason] If the list price or the rule-based factor associated
  ///  with the code is overridden, this attribute can capture a text to
  ///  indicate the  reason for this action.
  CodeableConcept? get overrideReason;
  @override

  /// [enterer] The device, practitioner, etc. who entered the charge item.
  Reference? get enterer;
  @override

  /// [enteredDate] Date the charge item was entered.
  FhirDateTime? get enteredDate;
  @override

  /// [enteredDateElement] ("_enteredDate") Extensions for enteredDate
  @JsonKey(name: '_enteredDate')
  Element? get enteredDateElement;
  @override

  /// [reason] Describes why the event occurred in coded or textual form.
  List<CodeableConcept>? get reason;
  @override

  /// [service] Indicated the rendered service that caused this charge.
  List<CodeableReference>? get service;
  @override

  /// [product] Identifies the device, food, drug or other product being
  ///  charged either by type code or reference to an instance.
  List<CodeableReference>? get product;
  @override

  /// [account] Account into which this ChargeItems belongs.
  List<Reference>? get account;
  @override

  /// [note] Comments made about the event by the performer, subject or other
  ///  participants.
  List<Annotation>? get note;
  @override

  /// [supportingInformation] Further information supporting this charge.
  List<Reference>? get supportingInformation;
  @override
  @JsonKey(ignore: true)
  _$$ChargeItemImplCopyWith<_$ChargeItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChargeItemPerformer _$ChargeItemPerformerFromJson(Map<String, dynamic> json) {
  return _ChargeItemPerformer.fromJson(json);
}

/// @nodoc
mixin _$ChargeItemPerformer {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [function_] ("function") Describes the type of performance or
  ///  participation(e.g. primary surgeon, anesthesiologiest, etc.).
  @JsonKey(name: 'function')
  CodeableConcept? get function_ => throw _privateConstructorUsedError;

  /// [actor] The device, practitioner, etc. who performed or participated in
  ///  the service.
  Reference get actor => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChargeItemPerformerCopyWith<ChargeItemPerformer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChargeItemPerformerCopyWith<$Res> {
  factory $ChargeItemPerformerCopyWith(
          ChargeItemPerformer value, $Res Function(ChargeItemPerformer) then) =
      _$ChargeItemPerformerCopyWithImpl<$Res, ChargeItemPerformer>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'function') CodeableConcept? function_,
      Reference actor});

  $CodeableConceptCopyWith<$Res>? get function_;
  $ReferenceCopyWith<$Res> get actor;
}

/// @nodoc
class _$ChargeItemPerformerCopyWithImpl<$Res, $Val extends ChargeItemPerformer>
    implements $ChargeItemPerformerCopyWith<$Res> {
  _$ChargeItemPerformerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? function_ = freezed,
    Object? actor = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      function_: freezed == function_
          ? _value.function_
          : function_ // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      actor: null == actor
          ? _value.actor
          : actor // ignore: cast_nullable_to_non_nullable
              as Reference,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get function_ {
    if (_value.function_ == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.function_!, (value) {
      return _then(_value.copyWith(function_: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get actor {
    return $ReferenceCopyWith<$Res>(_value.actor, (value) {
      return _then(_value.copyWith(actor: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChargeItemPerformerImplCopyWith<$Res>
    implements $ChargeItemPerformerCopyWith<$Res> {
  factory _$$ChargeItemPerformerImplCopyWith(_$ChargeItemPerformerImpl value,
          $Res Function(_$ChargeItemPerformerImpl) then) =
      __$$ChargeItemPerformerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'function') CodeableConcept? function_,
      Reference actor});

  @override
  $CodeableConceptCopyWith<$Res>? get function_;
  @override
  $ReferenceCopyWith<$Res> get actor;
}

/// @nodoc
class __$$ChargeItemPerformerImplCopyWithImpl<$Res>
    extends _$ChargeItemPerformerCopyWithImpl<$Res, _$ChargeItemPerformerImpl>
    implements _$$ChargeItemPerformerImplCopyWith<$Res> {
  __$$ChargeItemPerformerImplCopyWithImpl(_$ChargeItemPerformerImpl _value,
      $Res Function(_$ChargeItemPerformerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? function_ = freezed,
    Object? actor = null,
  }) {
    return _then(_$ChargeItemPerformerImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      function_: freezed == function_
          ? _value.function_
          : function_ // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      actor: null == actor
          ? _value.actor
          : actor // ignore: cast_nullable_to_non_nullable
              as Reference,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChargeItemPerformerImpl extends _ChargeItemPerformer {
  const _$ChargeItemPerformerImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'function') this.function_,
      required this.actor})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ChargeItemPerformerImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChargeItemPerformerImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [function_] ("function") Describes the type of performance or
  ///  participation(e.g. primary surgeon, anesthesiologiest, etc.).
  @override
  @JsonKey(name: 'function')
  final CodeableConcept? function_;

  /// [actor] The device, practitioner, etc. who performed or participated in
  ///  the service.
  @override
  final Reference actor;

  @override
  String toString() {
    return 'ChargeItemPerformer(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, function_: $function_, actor: $actor)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChargeItemPerformerImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.function_, function_) ||
                other.function_ == function_) &&
            (identical(other.actor, actor) || other.actor == actor));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      function_,
      actor);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChargeItemPerformerImplCopyWith<_$ChargeItemPerformerImpl> get copyWith =>
      __$$ChargeItemPerformerImplCopyWithImpl<_$ChargeItemPerformerImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChargeItemPerformerImplToJson(
      this,
    );
  }
}

abstract class _ChargeItemPerformer extends ChargeItemPerformer {
  const factory _ChargeItemPerformer(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      @JsonKey(name: 'function') final CodeableConcept? function_,
      required final Reference actor}) = _$ChargeItemPerformerImpl;
  const _ChargeItemPerformer._() : super._();

  factory _ChargeItemPerformer.fromJson(Map<String, dynamic> json) =
      _$ChargeItemPerformerImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [function_] ("function") Describes the type of performance or
  ///  participation(e.g. primary surgeon, anesthesiologiest, etc.).
  @JsonKey(name: 'function')
  CodeableConcept? get function_;
  @override

  /// [actor] The device, practitioner, etc. who performed or participated in
  ///  the service.
  Reference get actor;
  @override
  @JsonKey(ignore: true)
  _$$ChargeItemPerformerImplCopyWith<_$ChargeItemPerformerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChargeItemDefinition _$ChargeItemDefinitionFromJson(Map<String, dynamic> json) {
  return _ChargeItemDefinition.fromJson(json);
}

/// @nodoc
mixin _$ChargeItemDefinition {
  /// [resourceType] This is a ChargeItemDefinition resource
  @JsonKey(unknownEnumValue: R6ResourceType.ChargeItemDefinition)
  R6ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  FhirMeta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  FhirCode? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [url] An absolute URI that is used to identify this charge item
  ///  definition when it is referenced in a specification, model, design or
  ///  an instance; also called its canonical identifier. This SHOULD be
  ///  globally unique and SHOULD be a literal address at which an
  ///  authoritative instance of this charge item definition is (or will be)
  ///  published. This URL can be the target of a canonical reference. It
  ///  SHALL remain the same when the charge item definition is stored on
  ///  different servers.
  FhirUri? get url => throw _privateConstructorUsedError;

  /// [urlElement] ("_url") Extensions for url
  @JsonKey(name: '_url')
  Element? get urlElement => throw _privateConstructorUsedError;

  /// [identifier] A formal identifier that is used to identify this charge
  ///  item definition when it is represented in other formats, or referenced
  ///  in a specification, model, design or an instance.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [version] The identifier that is used to identify this version of the
  ///  charge item definition when it is referenced in a specification,
  ///  model, design or instance. This is an arbitrary value managed by the
  ///  charge item definition author and is not expected to be globally
  ///  unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
  ///  managed version is not available. There is also no expectation that
  ///  versions can be placed in a lexicographical sequence. To provide a
  ///  version consistent with the Decision Support Service specification,
  ///  use the format Major.Minor.Revision (e.g. 1.0.0). For more information
  ///  on versioning knowledge assets, refer to the Decision Support Service
  ///  specification. Note that a version is required for non-experimental
  ///  active assets.
  String? get version => throw _privateConstructorUsedError;

  /// [versionElement] ("_version") Extensions for version
  @JsonKey(name: '_version')
  Element? get versionElement => throw _privateConstructorUsedError;

  /// [versionAlgorithmString] Indicates the mechanism used to compare
  ///  versions to determine which is more current.
  String? get versionAlgorithmString => throw _privateConstructorUsedError;

  /// [versionAlgorithmStringElement] ("_versionAlgorithmString") Extensions
  ///  for versionAlgorithmString
  @JsonKey(name: '_versionAlgorithmString')
  Element? get versionAlgorithmStringElement =>
      throw _privateConstructorUsedError;

  /// [versionAlgorithmCoding] Indicates the mechanism used to compare
  ///  versions to determine which is more current.
  Coding? get versionAlgorithmCoding => throw _privateConstructorUsedError;

  /// [name] A natural language name identifying the ChargeItemDefinition.
  ///  This name should be usable as an identifier for the module by machine
  ///  processing applications such as code generation.
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [title] A short, descriptive, user-friendly title for the charge item
  ///  definition.
  String? get title => throw _privateConstructorUsedError;

  /// [titleElement] ("_title") Extensions for title
  @JsonKey(name: '_title')
  Element? get titleElement => throw _privateConstructorUsedError;

  /// [status] The current state of the ChargeItemDefinition.
  FhirCode? get status => throw _privateConstructorUsedError;

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement => throw _privateConstructorUsedError;

  /// [experimental] A Boolean value to indicate that this charge item
  ///  definition is authored for testing purposes (or
  ///  education/evaluation/marketing) and is not intended to be used for
  ///  genuine usage.
  FhirBoolean? get experimental => throw _privateConstructorUsedError;

  /// [experimentalElement] ("_experimental") Extensions for experimental
  @JsonKey(name: '_experimental')
  Element? get experimentalElement => throw _privateConstructorUsedError;

  /// [date] The date  (and optionally time) when the charge item definition
  ///  was last significantly changed. The date must change when the business
  ///  version changes and it must change if the status code changes. In
  ///  addition, it should change when the substantive content of the charge
  ///  item definition changes.
  FhirDateTime? get date => throw _privateConstructorUsedError;

  /// [dateElement] ("_date") Extensions for date
  @JsonKey(name: '_date')
  Element? get dateElement => throw _privateConstructorUsedError;

  /// [publisher] The name of the organization or individual responsible for
  ///  the release and ongoing maintenance of the charge item definition.
  String? get publisher => throw _privateConstructorUsedError;

  /// [publisherElement] ("_publisher") Extensions for publisher
  @JsonKey(name: '_publisher')
  Element? get publisherElement => throw _privateConstructorUsedError;

  /// [contact] Contact details to assist a user in finding and communicating
  ///  with the publisher.
  List<ContactDetail>? get contact => throw _privateConstructorUsedError;

  /// [description] A free text natural language description of the charge
  ///  item definition from a consumer's perspective.
  FhirMarkdown? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [useContext] The content was developed with a focus and intent of
  ///  supporting the contexts that are listed. These contexts may be general
  ///  categories (gender, age, ...) or may be references to specific
  ///  programs (insurance plans, studies, ...) and may be used to assist
  ///  with indexing and searching for appropriate charge item definition
  ///  instances.
  List<UsageContext>? get useContext => throw _privateConstructorUsedError;

  /// [jurisdiction] A legal or geographic region in which the charge item
  ///  definition is intended to be used.
  List<CodeableConcept>? get jurisdiction => throw _privateConstructorUsedError;

  /// [purpose] Explanation of why this charge item definition is needed and
  ///  why it has been designed as it has.
  FhirMarkdown? get purpose => throw _privateConstructorUsedError;

  /// [purposeElement] ("_purpose") Extensions for purpose
  @JsonKey(name: '_purpose')
  Element? get purposeElement => throw _privateConstructorUsedError;

  /// [copyright] A copyright statement relating to the charge item
  ///  definition and/or its contents. Copyright statements are generally
  ///  legal restrictions on the use and publishing of the charge item
  ///  definition.
  FhirMarkdown? get copyright => throw _privateConstructorUsedError;

  /// [copyrightElement] ("_copyright") Extensions for copyright
  @JsonKey(name: '_copyright')
  Element? get copyrightElement => throw _privateConstructorUsedError;

  /// [copyrightLabel] A short string (<50 characters), suitable for
  ///  inclusion in a page footer that identifies the copyright holder,
  ///  effective period, and optionally whether rights are resctricted. (e.g.
  ///  'All rights reserved', 'Some rights reserved').
  String? get copyrightLabel => throw _privateConstructorUsedError;

  /// [copyrightLabelElement] ("_copyrightLabel") Extensions for
  ///  copyrightLabel
  @JsonKey(name: '_copyrightLabel')
  Element? get copyrightLabelElement => throw _privateConstructorUsedError;

  /// [approvalDate] The date on which the resource content was approved by
  ///  the publisher. Approval happens once when the content is officially
  ///  approved for usage.
  FhirDate? get approvalDate => throw _privateConstructorUsedError;

  /// [approvalDateElement] ("_approvalDate") Extensions for approvalDate
  @JsonKey(name: '_approvalDate')
  Element? get approvalDateElement => throw _privateConstructorUsedError;

  /// [lastReviewDate] The date on which the resource content was last
  ///  reviewed. Review happens periodically after approval but does not
  ///  change the original approval date.
  FhirDate? get lastReviewDate => throw _privateConstructorUsedError;

  /// [lastReviewDateElement] ("_lastReviewDate") Extensions for
  ///  lastReviewDate
  @JsonKey(name: '_lastReviewDate')
  Element? get lastReviewDateElement => throw _privateConstructorUsedError;

  /// [effectivePeriod] The period during which the {{title}} content was or
  ///  is planned to be in active use.
  Period? get effectivePeriod => throw _privateConstructorUsedError;

  /// [topic] Descriptive topics related to the content of the {{title}}.
  ///  Topics provide a high-level categorization as well as keywords for the
  ///  {{title}} that can be useful for filtering and searching.
  List<CodeableConcept>? get topic => throw _privateConstructorUsedError;

  /// [author] An individiual or organization primarily involved in the
  ///  creation and maintenance of the {{title}}.
  List<ContactDetail>? get author => throw _privateConstructorUsedError;

  /// [editor] An individual or organization primarily responsible for
  ///  internal coherence of the {{title}}.
  List<ContactDetail>? get editor => throw _privateConstructorUsedError;

  /// [reviewer] An individual or organization asserted by the publisher to
  ///  be primarily responsible for review of some aspect of the {{title}}.
  List<ContactDetail>? get reviewer => throw _privateConstructorUsedError;

  /// [endorser] An individual or organization asserted by the publisher to
  ///  be responsible for officially endorsing the {{title}} for use in some
  ///  setting.
  List<ContactDetail>? get endorser => throw _privateConstructorUsedError;

  /// [relatedArtifact] Related artifacts such as additional documentation,
  ///  justification, dependencies, bibliographic references, and predecessor
  ///  and successor artifacts.
  List<RelatedArtifact>? get relatedArtifact =>
      throw _privateConstructorUsedError;

  /// [derivedFromUri] The URL pointing to an externally-defined charge item
  ///  definition that is adhered to in whole or in part by this definition.
  List<FhirUri>? get derivedFromUri => throw _privateConstructorUsedError;

  /// [derivedFromUriElement] ("_derivedFromUri") Extensions for
  ///  derivedFromUri
  @JsonKey(name: '_derivedFromUri')
  List<Element>? get derivedFromUriElement =>
      throw _privateConstructorUsedError;

  /// [partOf] A larger definition of which this particular definition is a
  ///  component or step.
  List<FhirCanonical>? get partOf => throw _privateConstructorUsedError;

  /// [replaces] As new versions of a protocol or guideline are defined,
  ///  allows identification of what versions are replaced by a new instance.
  List<FhirCanonical>? get replaces => throw _privateConstructorUsedError;

  /// [code] The defined billing details in this resource pertain to the
  ///  given billing code.
  CodeableConcept? get code => throw _privateConstructorUsedError;

  /// [instance] The defined billing details in this resource pertain to the
  ///  given product instance(s).
  List<Reference>? get instance => throw _privateConstructorUsedError;

  /// [applicability] Expressions that describe applicability criteria for
  ///  the billing code.
  List<ChargeItemDefinitionApplicability>? get applicability =>
      throw _privateConstructorUsedError;

  /// [propertyGroup] Group of properties which are applicable under the same
  ///  conditions. If no applicability rules are established for the group,
  ///  then all properties always apply.
  List<ChargeItemDefinitionPropertyGroup>? get propertyGroup =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChargeItemDefinitionCopyWith<ChargeItemDefinition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChargeItemDefinitionCopyWith<$Res> {
  factory $ChargeItemDefinitionCopyWith(ChargeItemDefinition value,
          $Res Function(ChargeItemDefinition) then) =
      _$ChargeItemDefinitionCopyWithImpl<$Res, ChargeItemDefinition>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.ChargeItemDefinition)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirUri? url,
      @JsonKey(name: '_url') Element? urlElement,
      List<Identifier>? identifier,
      String? version,
      @JsonKey(name: '_version') Element? versionElement,
      String? versionAlgorithmString,
      @JsonKey(name: '_versionAlgorithmString')
      Element? versionAlgorithmStringElement,
      Coding? versionAlgorithmCoding,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      String? title,
      @JsonKey(name: '_title') Element? titleElement,
      FhirCode? status,
      @JsonKey(name: '_status') Element? statusElement,
      FhirBoolean? experimental,
      @JsonKey(name: '_experimental') Element? experimentalElement,
      FhirDateTime? date,
      @JsonKey(name: '_date') Element? dateElement,
      String? publisher,
      @JsonKey(name: '_publisher') Element? publisherElement,
      List<ContactDetail>? contact,
      FhirMarkdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      List<UsageContext>? useContext,
      List<CodeableConcept>? jurisdiction,
      FhirMarkdown? purpose,
      @JsonKey(name: '_purpose') Element? purposeElement,
      FhirMarkdown? copyright,
      @JsonKey(name: '_copyright') Element? copyrightElement,
      String? copyrightLabel,
      @JsonKey(name: '_copyrightLabel') Element? copyrightLabelElement,
      FhirDate? approvalDate,
      @JsonKey(name: '_approvalDate') Element? approvalDateElement,
      FhirDate? lastReviewDate,
      @JsonKey(name: '_lastReviewDate') Element? lastReviewDateElement,
      Period? effectivePeriod,
      List<CodeableConcept>? topic,
      List<ContactDetail>? author,
      List<ContactDetail>? editor,
      List<ContactDetail>? reviewer,
      List<ContactDetail>? endorser,
      List<RelatedArtifact>? relatedArtifact,
      List<FhirUri>? derivedFromUri,
      @JsonKey(name: '_derivedFromUri') List<Element>? derivedFromUriElement,
      List<FhirCanonical>? partOf,
      List<FhirCanonical>? replaces,
      CodeableConcept? code,
      List<Reference>? instance,
      List<ChargeItemDefinitionApplicability>? applicability,
      List<ChargeItemDefinitionPropertyGroup>? propertyGroup});

  $FhirMetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get urlElement;
  $ElementCopyWith<$Res>? get versionElement;
  $ElementCopyWith<$Res>? get versionAlgorithmStringElement;
  $CodingCopyWith<$Res>? get versionAlgorithmCoding;
  $ElementCopyWith<$Res>? get nameElement;
  $ElementCopyWith<$Res>? get titleElement;
  $ElementCopyWith<$Res>? get statusElement;
  $ElementCopyWith<$Res>? get experimentalElement;
  $ElementCopyWith<$Res>? get dateElement;
  $ElementCopyWith<$Res>? get publisherElement;
  $ElementCopyWith<$Res>? get descriptionElement;
  $ElementCopyWith<$Res>? get purposeElement;
  $ElementCopyWith<$Res>? get copyrightElement;
  $ElementCopyWith<$Res>? get copyrightLabelElement;
  $ElementCopyWith<$Res>? get approvalDateElement;
  $ElementCopyWith<$Res>? get lastReviewDateElement;
  $PeriodCopyWith<$Res>? get effectivePeriod;
  $CodeableConceptCopyWith<$Res>? get code;
}

/// @nodoc
class _$ChargeItemDefinitionCopyWithImpl<$Res,
        $Val extends ChargeItemDefinition>
    implements $ChargeItemDefinitionCopyWith<$Res> {
  _$ChargeItemDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? url = freezed,
    Object? urlElement = freezed,
    Object? identifier = freezed,
    Object? version = freezed,
    Object? versionElement = freezed,
    Object? versionAlgorithmString = freezed,
    Object? versionAlgorithmStringElement = freezed,
    Object? versionAlgorithmCoding = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? title = freezed,
    Object? titleElement = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? experimental = freezed,
    Object? experimentalElement = freezed,
    Object? date = freezed,
    Object? dateElement = freezed,
    Object? publisher = freezed,
    Object? publisherElement = freezed,
    Object? contact = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? useContext = freezed,
    Object? jurisdiction = freezed,
    Object? purpose = freezed,
    Object? purposeElement = freezed,
    Object? copyright = freezed,
    Object? copyrightElement = freezed,
    Object? copyrightLabel = freezed,
    Object? copyrightLabelElement = freezed,
    Object? approvalDate = freezed,
    Object? approvalDateElement = freezed,
    Object? lastReviewDate = freezed,
    Object? lastReviewDateElement = freezed,
    Object? effectivePeriod = freezed,
    Object? topic = freezed,
    Object? author = freezed,
    Object? editor = freezed,
    Object? reviewer = freezed,
    Object? endorser = freezed,
    Object? relatedArtifact = freezed,
    Object? derivedFromUri = freezed,
    Object? derivedFromUriElement = freezed,
    Object? partOf = freezed,
    Object? replaces = freezed,
    Object? code = freezed,
    Object? instance = freezed,
    Object? applicability = freezed,
    Object? propertyGroup = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      urlElement: freezed == urlElement
          ? _value.urlElement
          : urlElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      versionElement: freezed == versionElement
          ? _value.versionElement
          : versionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      versionAlgorithmString: freezed == versionAlgorithmString
          ? _value.versionAlgorithmString
          : versionAlgorithmString // ignore: cast_nullable_to_non_nullable
              as String?,
      versionAlgorithmStringElement: freezed == versionAlgorithmStringElement
          ? _value.versionAlgorithmStringElement
          : versionAlgorithmStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      versionAlgorithmCoding: freezed == versionAlgorithmCoding
          ? _value.versionAlgorithmCoding
          : versionAlgorithmCoding // ignore: cast_nullable_to_non_nullable
              as Coding?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      titleElement: freezed == titleElement
          ? _value.titleElement
          : titleElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      experimental: freezed == experimental
          ? _value.experimental
          : experimental // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      experimentalElement: freezed == experimentalElement
          ? _value.experimentalElement
          : experimentalElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateElement: freezed == dateElement
          ? _value.dateElement
          : dateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      publisher: freezed == publisher
          ? _value.publisher
          : publisher // ignore: cast_nullable_to_non_nullable
              as String?,
      publisherElement: freezed == publisherElement
          ? _value.publisherElement
          : publisherElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      contact: freezed == contact
          ? _value.contact
          : contact // ignore: cast_nullable_to_non_nullable
              as List<ContactDetail>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as FhirMarkdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      useContext: freezed == useContext
          ? _value.useContext
          : useContext // ignore: cast_nullable_to_non_nullable
              as List<UsageContext>?,
      jurisdiction: freezed == jurisdiction
          ? _value.jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      purpose: freezed == purpose
          ? _value.purpose
          : purpose // ignore: cast_nullable_to_non_nullable
              as FhirMarkdown?,
      purposeElement: freezed == purposeElement
          ? _value.purposeElement
          : purposeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      copyright: freezed == copyright
          ? _value.copyright
          : copyright // ignore: cast_nullable_to_non_nullable
              as FhirMarkdown?,
      copyrightElement: freezed == copyrightElement
          ? _value.copyrightElement
          : copyrightElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      copyrightLabel: freezed == copyrightLabel
          ? _value.copyrightLabel
          : copyrightLabel // ignore: cast_nullable_to_non_nullable
              as String?,
      copyrightLabelElement: freezed == copyrightLabelElement
          ? _value.copyrightLabelElement
          : copyrightLabelElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      approvalDate: freezed == approvalDate
          ? _value.approvalDate
          : approvalDate // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      approvalDateElement: freezed == approvalDateElement
          ? _value.approvalDateElement
          : approvalDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      lastReviewDate: freezed == lastReviewDate
          ? _value.lastReviewDate
          : lastReviewDate // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      lastReviewDateElement: freezed == lastReviewDateElement
          ? _value.lastReviewDateElement
          : lastReviewDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      effectivePeriod: freezed == effectivePeriod
          ? _value.effectivePeriod
          : effectivePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      topic: freezed == topic
          ? _value.topic
          : topic // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      author: freezed == author
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as List<ContactDetail>?,
      editor: freezed == editor
          ? _value.editor
          : editor // ignore: cast_nullable_to_non_nullable
              as List<ContactDetail>?,
      reviewer: freezed == reviewer
          ? _value.reviewer
          : reviewer // ignore: cast_nullable_to_non_nullable
              as List<ContactDetail>?,
      endorser: freezed == endorser
          ? _value.endorser
          : endorser // ignore: cast_nullable_to_non_nullable
              as List<ContactDetail>?,
      relatedArtifact: freezed == relatedArtifact
          ? _value.relatedArtifact
          : relatedArtifact // ignore: cast_nullable_to_non_nullable
              as List<RelatedArtifact>?,
      derivedFromUri: freezed == derivedFromUri
          ? _value.derivedFromUri
          : derivedFromUri // ignore: cast_nullable_to_non_nullable
              as List<FhirUri>?,
      derivedFromUriElement: freezed == derivedFromUriElement
          ? _value.derivedFromUriElement
          : derivedFromUriElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      partOf: freezed == partOf
          ? _value.partOf
          : partOf // ignore: cast_nullable_to_non_nullable
              as List<FhirCanonical>?,
      replaces: freezed == replaces
          ? _value.replaces
          : replaces // ignore: cast_nullable_to_non_nullable
              as List<FhirCanonical>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      instance: freezed == instance
          ? _value.instance
          : instance // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      applicability: freezed == applicability
          ? _value.applicability
          : applicability // ignore: cast_nullable_to_non_nullable
              as List<ChargeItemDefinitionApplicability>?,
      propertyGroup: freezed == propertyGroup
          ? _value.propertyGroup
          : propertyGroup // ignore: cast_nullable_to_non_nullable
              as List<ChargeItemDefinitionPropertyGroup>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FhirMetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $FhirMetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get urlElement {
    if (_value.urlElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.urlElement!, (value) {
      return _then(_value.copyWith(urlElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get versionElement {
    if (_value.versionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.versionElement!, (value) {
      return _then(_value.copyWith(versionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get versionAlgorithmStringElement {
    if (_value.versionAlgorithmStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.versionAlgorithmStringElement!,
        (value) {
      return _then(
          _value.copyWith(versionAlgorithmStringElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodingCopyWith<$Res>? get versionAlgorithmCoding {
    if (_value.versionAlgorithmCoding == null) {
      return null;
    }

    return $CodingCopyWith<$Res>(_value.versionAlgorithmCoding!, (value) {
      return _then(_value.copyWith(versionAlgorithmCoding: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get titleElement {
    if (_value.titleElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.titleElement!, (value) {
      return _then(_value.copyWith(titleElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusElement {
    if (_value.statusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusElement!, (value) {
      return _then(_value.copyWith(statusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get experimentalElement {
    if (_value.experimentalElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.experimentalElement!, (value) {
      return _then(_value.copyWith(experimentalElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get dateElement {
    if (_value.dateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.dateElement!, (value) {
      return _then(_value.copyWith(dateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get publisherElement {
    if (_value.publisherElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.publisherElement!, (value) {
      return _then(_value.copyWith(publisherElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get purposeElement {
    if (_value.purposeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.purposeElement!, (value) {
      return _then(_value.copyWith(purposeElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get copyrightElement {
    if (_value.copyrightElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.copyrightElement!, (value) {
      return _then(_value.copyWith(copyrightElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get copyrightLabelElement {
    if (_value.copyrightLabelElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.copyrightLabelElement!, (value) {
      return _then(_value.copyWith(copyrightLabelElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get approvalDateElement {
    if (_value.approvalDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.approvalDateElement!, (value) {
      return _then(_value.copyWith(approvalDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get lastReviewDateElement {
    if (_value.lastReviewDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.lastReviewDateElement!, (value) {
      return _then(_value.copyWith(lastReviewDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.effectivePeriod!, (value) {
      return _then(_value.copyWith(effectivePeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get code {
    if (_value.code == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.code!, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChargeItemDefinitionImplCopyWith<$Res>
    implements $ChargeItemDefinitionCopyWith<$Res> {
  factory _$$ChargeItemDefinitionImplCopyWith(_$ChargeItemDefinitionImpl value,
          $Res Function(_$ChargeItemDefinitionImpl) then) =
      __$$ChargeItemDefinitionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.ChargeItemDefinition)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirUri? url,
      @JsonKey(name: '_url') Element? urlElement,
      List<Identifier>? identifier,
      String? version,
      @JsonKey(name: '_version') Element? versionElement,
      String? versionAlgorithmString,
      @JsonKey(name: '_versionAlgorithmString')
      Element? versionAlgorithmStringElement,
      Coding? versionAlgorithmCoding,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      String? title,
      @JsonKey(name: '_title') Element? titleElement,
      FhirCode? status,
      @JsonKey(name: '_status') Element? statusElement,
      FhirBoolean? experimental,
      @JsonKey(name: '_experimental') Element? experimentalElement,
      FhirDateTime? date,
      @JsonKey(name: '_date') Element? dateElement,
      String? publisher,
      @JsonKey(name: '_publisher') Element? publisherElement,
      List<ContactDetail>? contact,
      FhirMarkdown? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      List<UsageContext>? useContext,
      List<CodeableConcept>? jurisdiction,
      FhirMarkdown? purpose,
      @JsonKey(name: '_purpose') Element? purposeElement,
      FhirMarkdown? copyright,
      @JsonKey(name: '_copyright') Element? copyrightElement,
      String? copyrightLabel,
      @JsonKey(name: '_copyrightLabel') Element? copyrightLabelElement,
      FhirDate? approvalDate,
      @JsonKey(name: '_approvalDate') Element? approvalDateElement,
      FhirDate? lastReviewDate,
      @JsonKey(name: '_lastReviewDate') Element? lastReviewDateElement,
      Period? effectivePeriod,
      List<CodeableConcept>? topic,
      List<ContactDetail>? author,
      List<ContactDetail>? editor,
      List<ContactDetail>? reviewer,
      List<ContactDetail>? endorser,
      List<RelatedArtifact>? relatedArtifact,
      List<FhirUri>? derivedFromUri,
      @JsonKey(name: '_derivedFromUri') List<Element>? derivedFromUriElement,
      List<FhirCanonical>? partOf,
      List<FhirCanonical>? replaces,
      CodeableConcept? code,
      List<Reference>? instance,
      List<ChargeItemDefinitionApplicability>? applicability,
      List<ChargeItemDefinitionPropertyGroup>? propertyGroup});

  @override
  $FhirMetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get urlElement;
  @override
  $ElementCopyWith<$Res>? get versionElement;
  @override
  $ElementCopyWith<$Res>? get versionAlgorithmStringElement;
  @override
  $CodingCopyWith<$Res>? get versionAlgorithmCoding;
  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $ElementCopyWith<$Res>? get titleElement;
  @override
  $ElementCopyWith<$Res>? get statusElement;
  @override
  $ElementCopyWith<$Res>? get experimentalElement;
  @override
  $ElementCopyWith<$Res>? get dateElement;
  @override
  $ElementCopyWith<$Res>? get publisherElement;
  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $ElementCopyWith<$Res>? get purposeElement;
  @override
  $ElementCopyWith<$Res>? get copyrightElement;
  @override
  $ElementCopyWith<$Res>? get copyrightLabelElement;
  @override
  $ElementCopyWith<$Res>? get approvalDateElement;
  @override
  $ElementCopyWith<$Res>? get lastReviewDateElement;
  @override
  $PeriodCopyWith<$Res>? get effectivePeriod;
  @override
  $CodeableConceptCopyWith<$Res>? get code;
}

/// @nodoc
class __$$ChargeItemDefinitionImplCopyWithImpl<$Res>
    extends _$ChargeItemDefinitionCopyWithImpl<$Res, _$ChargeItemDefinitionImpl>
    implements _$$ChargeItemDefinitionImplCopyWith<$Res> {
  __$$ChargeItemDefinitionImplCopyWithImpl(_$ChargeItemDefinitionImpl _value,
      $Res Function(_$ChargeItemDefinitionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? url = freezed,
    Object? urlElement = freezed,
    Object? identifier = freezed,
    Object? version = freezed,
    Object? versionElement = freezed,
    Object? versionAlgorithmString = freezed,
    Object? versionAlgorithmStringElement = freezed,
    Object? versionAlgorithmCoding = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? title = freezed,
    Object? titleElement = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? experimental = freezed,
    Object? experimentalElement = freezed,
    Object? date = freezed,
    Object? dateElement = freezed,
    Object? publisher = freezed,
    Object? publisherElement = freezed,
    Object? contact = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? useContext = freezed,
    Object? jurisdiction = freezed,
    Object? purpose = freezed,
    Object? purposeElement = freezed,
    Object? copyright = freezed,
    Object? copyrightElement = freezed,
    Object? copyrightLabel = freezed,
    Object? copyrightLabelElement = freezed,
    Object? approvalDate = freezed,
    Object? approvalDateElement = freezed,
    Object? lastReviewDate = freezed,
    Object? lastReviewDateElement = freezed,
    Object? effectivePeriod = freezed,
    Object? topic = freezed,
    Object? author = freezed,
    Object? editor = freezed,
    Object? reviewer = freezed,
    Object? endorser = freezed,
    Object? relatedArtifact = freezed,
    Object? derivedFromUri = freezed,
    Object? derivedFromUriElement = freezed,
    Object? partOf = freezed,
    Object? replaces = freezed,
    Object? code = freezed,
    Object? instance = freezed,
    Object? applicability = freezed,
    Object? propertyGroup = freezed,
  }) {
    return _then(_$ChargeItemDefinitionImpl(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      urlElement: freezed == urlElement
          ? _value.urlElement
          : urlElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      versionElement: freezed == versionElement
          ? _value.versionElement
          : versionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      versionAlgorithmString: freezed == versionAlgorithmString
          ? _value.versionAlgorithmString
          : versionAlgorithmString // ignore: cast_nullable_to_non_nullable
              as String?,
      versionAlgorithmStringElement: freezed == versionAlgorithmStringElement
          ? _value.versionAlgorithmStringElement
          : versionAlgorithmStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      versionAlgorithmCoding: freezed == versionAlgorithmCoding
          ? _value.versionAlgorithmCoding
          : versionAlgorithmCoding // ignore: cast_nullable_to_non_nullable
              as Coding?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      titleElement: freezed == titleElement
          ? _value.titleElement
          : titleElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      experimental: freezed == experimental
          ? _value.experimental
          : experimental // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      experimentalElement: freezed == experimentalElement
          ? _value.experimentalElement
          : experimentalElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateElement: freezed == dateElement
          ? _value.dateElement
          : dateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      publisher: freezed == publisher
          ? _value.publisher
          : publisher // ignore: cast_nullable_to_non_nullable
              as String?,
      publisherElement: freezed == publisherElement
          ? _value.publisherElement
          : publisherElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      contact: freezed == contact
          ? _value._contact
          : contact // ignore: cast_nullable_to_non_nullable
              as List<ContactDetail>?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as FhirMarkdown?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      useContext: freezed == useContext
          ? _value._useContext
          : useContext // ignore: cast_nullable_to_non_nullable
              as List<UsageContext>?,
      jurisdiction: freezed == jurisdiction
          ? _value._jurisdiction
          : jurisdiction // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      purpose: freezed == purpose
          ? _value.purpose
          : purpose // ignore: cast_nullable_to_non_nullable
              as FhirMarkdown?,
      purposeElement: freezed == purposeElement
          ? _value.purposeElement
          : purposeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      copyright: freezed == copyright
          ? _value.copyright
          : copyright // ignore: cast_nullable_to_non_nullable
              as FhirMarkdown?,
      copyrightElement: freezed == copyrightElement
          ? _value.copyrightElement
          : copyrightElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      copyrightLabel: freezed == copyrightLabel
          ? _value.copyrightLabel
          : copyrightLabel // ignore: cast_nullable_to_non_nullable
              as String?,
      copyrightLabelElement: freezed == copyrightLabelElement
          ? _value.copyrightLabelElement
          : copyrightLabelElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      approvalDate: freezed == approvalDate
          ? _value.approvalDate
          : approvalDate // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      approvalDateElement: freezed == approvalDateElement
          ? _value.approvalDateElement
          : approvalDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      lastReviewDate: freezed == lastReviewDate
          ? _value.lastReviewDate
          : lastReviewDate // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      lastReviewDateElement: freezed == lastReviewDateElement
          ? _value.lastReviewDateElement
          : lastReviewDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      effectivePeriod: freezed == effectivePeriod
          ? _value.effectivePeriod
          : effectivePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      topic: freezed == topic
          ? _value._topic
          : topic // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      author: freezed == author
          ? _value._author
          : author // ignore: cast_nullable_to_non_nullable
              as List<ContactDetail>?,
      editor: freezed == editor
          ? _value._editor
          : editor // ignore: cast_nullable_to_non_nullable
              as List<ContactDetail>?,
      reviewer: freezed == reviewer
          ? _value._reviewer
          : reviewer // ignore: cast_nullable_to_non_nullable
              as List<ContactDetail>?,
      endorser: freezed == endorser
          ? _value._endorser
          : endorser // ignore: cast_nullable_to_non_nullable
              as List<ContactDetail>?,
      relatedArtifact: freezed == relatedArtifact
          ? _value._relatedArtifact
          : relatedArtifact // ignore: cast_nullable_to_non_nullable
              as List<RelatedArtifact>?,
      derivedFromUri: freezed == derivedFromUri
          ? _value._derivedFromUri
          : derivedFromUri // ignore: cast_nullable_to_non_nullable
              as List<FhirUri>?,
      derivedFromUriElement: freezed == derivedFromUriElement
          ? _value._derivedFromUriElement
          : derivedFromUriElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      partOf: freezed == partOf
          ? _value._partOf
          : partOf // ignore: cast_nullable_to_non_nullable
              as List<FhirCanonical>?,
      replaces: freezed == replaces
          ? _value._replaces
          : replaces // ignore: cast_nullable_to_non_nullable
              as List<FhirCanonical>?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      instance: freezed == instance
          ? _value._instance
          : instance // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      applicability: freezed == applicability
          ? _value._applicability
          : applicability // ignore: cast_nullable_to_non_nullable
              as List<ChargeItemDefinitionApplicability>?,
      propertyGroup: freezed == propertyGroup
          ? _value._propertyGroup
          : propertyGroup // ignore: cast_nullable_to_non_nullable
              as List<ChargeItemDefinitionPropertyGroup>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChargeItemDefinitionImpl extends _ChargeItemDefinition {
  const _$ChargeItemDefinitionImpl(
      {@JsonKey(unknownEnumValue: R6ResourceType.ChargeItemDefinition)
      this.resourceType = R6ResourceType.ChargeItemDefinition,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.url,
      @JsonKey(name: '_url') this.urlElement,
      final List<Identifier>? identifier,
      this.version,
      @JsonKey(name: '_version') this.versionElement,
      this.versionAlgorithmString,
      @JsonKey(name: '_versionAlgorithmString')
      this.versionAlgorithmStringElement,
      this.versionAlgorithmCoding,
      this.name,
      @JsonKey(name: '_name') this.nameElement,
      this.title,
      @JsonKey(name: '_title') this.titleElement,
      this.status,
      @JsonKey(name: '_status') this.statusElement,
      this.experimental,
      @JsonKey(name: '_experimental') this.experimentalElement,
      this.date,
      @JsonKey(name: '_date') this.dateElement,
      this.publisher,
      @JsonKey(name: '_publisher') this.publisherElement,
      final List<ContactDetail>? contact,
      this.description,
      @JsonKey(name: '_description') this.descriptionElement,
      final List<UsageContext>? useContext,
      final List<CodeableConcept>? jurisdiction,
      this.purpose,
      @JsonKey(name: '_purpose') this.purposeElement,
      this.copyright,
      @JsonKey(name: '_copyright') this.copyrightElement,
      this.copyrightLabel,
      @JsonKey(name: '_copyrightLabel') this.copyrightLabelElement,
      this.approvalDate,
      @JsonKey(name: '_approvalDate') this.approvalDateElement,
      this.lastReviewDate,
      @JsonKey(name: '_lastReviewDate') this.lastReviewDateElement,
      this.effectivePeriod,
      final List<CodeableConcept>? topic,
      final List<ContactDetail>? author,
      final List<ContactDetail>? editor,
      final List<ContactDetail>? reviewer,
      final List<ContactDetail>? endorser,
      final List<RelatedArtifact>? relatedArtifact,
      final List<FhirUri>? derivedFromUri,
      @JsonKey(name: '_derivedFromUri')
      final List<Element>? derivedFromUriElement,
      final List<FhirCanonical>? partOf,
      final List<FhirCanonical>? replaces,
      this.code,
      final List<Reference>? instance,
      final List<ChargeItemDefinitionApplicability>? applicability,
      final List<ChargeItemDefinitionPropertyGroup>? propertyGroup})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _contact = contact,
        _useContext = useContext,
        _jurisdiction = jurisdiction,
        _topic = topic,
        _author = author,
        _editor = editor,
        _reviewer = reviewer,
        _endorser = endorser,
        _relatedArtifact = relatedArtifact,
        _derivedFromUri = derivedFromUri,
        _derivedFromUriElement = derivedFromUriElement,
        _partOf = partOf,
        _replaces = replaces,
        _instance = instance,
        _applicability = applicability,
        _propertyGroup = propertyGroup,
        super._();

  factory _$ChargeItemDefinitionImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChargeItemDefinitionImplFromJson(json);

  /// [resourceType] This is a ChargeItemDefinition resource
  @override
  @JsonKey(unknownEnumValue: R6ResourceType.ChargeItemDefinition)
  final R6ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  @override
  final FhirMeta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final FhirCode? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [url] An absolute URI that is used to identify this charge item
  ///  definition when it is referenced in a specification, model, design or
  ///  an instance; also called its canonical identifier. This SHOULD be
  ///  globally unique and SHOULD be a literal address at which an
  ///  authoritative instance of this charge item definition is (or will be)
  ///  published. This URL can be the target of a canonical reference. It
  ///  SHALL remain the same when the charge item definition is stored on
  ///  different servers.
  @override
  final FhirUri? url;

  /// [urlElement] ("_url") Extensions for url
  @override
  @JsonKey(name: '_url')
  final Element? urlElement;

  /// [identifier] A formal identifier that is used to identify this charge
  ///  item definition when it is represented in other formats, or referenced
  ///  in a specification, model, design or an instance.
  final List<Identifier>? _identifier;

  /// [identifier] A formal identifier that is used to identify this charge
  ///  item definition when it is represented in other formats, or referenced
  ///  in a specification, model, design or an instance.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [version] The identifier that is used to identify this version of the
  ///  charge item definition when it is referenced in a specification,
  ///  model, design or instance. This is an arbitrary value managed by the
  ///  charge item definition author and is not expected to be globally
  ///  unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
  ///  managed version is not available. There is also no expectation that
  ///  versions can be placed in a lexicographical sequence. To provide a
  ///  version consistent with the Decision Support Service specification,
  ///  use the format Major.Minor.Revision (e.g. 1.0.0). For more information
  ///  on versioning knowledge assets, refer to the Decision Support Service
  ///  specification. Note that a version is required for non-experimental
  ///  active assets.
  @override
  final String? version;

  /// [versionElement] ("_version") Extensions for version
  @override
  @JsonKey(name: '_version')
  final Element? versionElement;

  /// [versionAlgorithmString] Indicates the mechanism used to compare
  ///  versions to determine which is more current.
  @override
  final String? versionAlgorithmString;

  /// [versionAlgorithmStringElement] ("_versionAlgorithmString") Extensions
  ///  for versionAlgorithmString
  @override
  @JsonKey(name: '_versionAlgorithmString')
  final Element? versionAlgorithmStringElement;

  /// [versionAlgorithmCoding] Indicates the mechanism used to compare
  ///  versions to determine which is more current.
  @override
  final Coding? versionAlgorithmCoding;

  /// [name] A natural language name identifying the ChargeItemDefinition.
  ///  This name should be usable as an identifier for the module by machine
  ///  processing applications such as code generation.
  @override
  final String? name;

  /// [nameElement] ("_name") Extensions for name
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [title] A short, descriptive, user-friendly title for the charge item
  ///  definition.
  @override
  final String? title;

  /// [titleElement] ("_title") Extensions for title
  @override
  @JsonKey(name: '_title')
  final Element? titleElement;

  /// [status] The current state of the ChargeItemDefinition.
  @override
  final FhirCode? status;

  /// [statusElement] ("_status") Extensions for status
  @override
  @JsonKey(name: '_status')
  final Element? statusElement;

  /// [experimental] A Boolean value to indicate that this charge item
  ///  definition is authored for testing purposes (or
  ///  education/evaluation/marketing) and is not intended to be used for
  ///  genuine usage.
  @override
  final FhirBoolean? experimental;

  /// [experimentalElement] ("_experimental") Extensions for experimental
  @override
  @JsonKey(name: '_experimental')
  final Element? experimentalElement;

  /// [date] The date  (and optionally time) when the charge item definition
  ///  was last significantly changed. The date must change when the business
  ///  version changes and it must change if the status code changes. In
  ///  addition, it should change when the substantive content of the charge
  ///  item definition changes.
  @override
  final FhirDateTime? date;

  /// [dateElement] ("_date") Extensions for date
  @override
  @JsonKey(name: '_date')
  final Element? dateElement;

  /// [publisher] The name of the organization or individual responsible for
  ///  the release and ongoing maintenance of the charge item definition.
  @override
  final String? publisher;

  /// [publisherElement] ("_publisher") Extensions for publisher
  @override
  @JsonKey(name: '_publisher')
  final Element? publisherElement;

  /// [contact] Contact details to assist a user in finding and communicating
  ///  with the publisher.
  final List<ContactDetail>? _contact;

  /// [contact] Contact details to assist a user in finding and communicating
  ///  with the publisher.
  @override
  List<ContactDetail>? get contact {
    final value = _contact;
    if (value == null) return null;
    if (_contact is EqualUnmodifiableListView) return _contact;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [description] A free text natural language description of the charge
  ///  item definition from a consumer's perspective.
  @override
  final FhirMarkdown? description;

  /// [descriptionElement] ("_description") Extensions for description
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [useContext] The content was developed with a focus and intent of
  ///  supporting the contexts that are listed. These contexts may be general
  ///  categories (gender, age, ...) or may be references to specific
  ///  programs (insurance plans, studies, ...) and may be used to assist
  ///  with indexing and searching for appropriate charge item definition
  ///  instances.
  final List<UsageContext>? _useContext;

  /// [useContext] The content was developed with a focus and intent of
  ///  supporting the contexts that are listed. These contexts may be general
  ///  categories (gender, age, ...) or may be references to specific
  ///  programs (insurance plans, studies, ...) and may be used to assist
  ///  with indexing and searching for appropriate charge item definition
  ///  instances.
  @override
  List<UsageContext>? get useContext {
    final value = _useContext;
    if (value == null) return null;
    if (_useContext is EqualUnmodifiableListView) return _useContext;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [jurisdiction] A legal or geographic region in which the charge item
  ///  definition is intended to be used.
  final List<CodeableConcept>? _jurisdiction;

  /// [jurisdiction] A legal or geographic region in which the charge item
  ///  definition is intended to be used.
  @override
  List<CodeableConcept>? get jurisdiction {
    final value = _jurisdiction;
    if (value == null) return null;
    if (_jurisdiction is EqualUnmodifiableListView) return _jurisdiction;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [purpose] Explanation of why this charge item definition is needed and
  ///  why it has been designed as it has.
  @override
  final FhirMarkdown? purpose;

  /// [purposeElement] ("_purpose") Extensions for purpose
  @override
  @JsonKey(name: '_purpose')
  final Element? purposeElement;

  /// [copyright] A copyright statement relating to the charge item
  ///  definition and/or its contents. Copyright statements are generally
  ///  legal restrictions on the use and publishing of the charge item
  ///  definition.
  @override
  final FhirMarkdown? copyright;

  /// [copyrightElement] ("_copyright") Extensions for copyright
  @override
  @JsonKey(name: '_copyright')
  final Element? copyrightElement;

  /// [copyrightLabel] A short string (<50 characters), suitable for
  ///  inclusion in a page footer that identifies the copyright holder,
  ///  effective period, and optionally whether rights are resctricted. (e.g.
  ///  'All rights reserved', 'Some rights reserved').
  @override
  final String? copyrightLabel;

  /// [copyrightLabelElement] ("_copyrightLabel") Extensions for
  ///  copyrightLabel
  @override
  @JsonKey(name: '_copyrightLabel')
  final Element? copyrightLabelElement;

  /// [approvalDate] The date on which the resource content was approved by
  ///  the publisher. Approval happens once when the content is officially
  ///  approved for usage.
  @override
  final FhirDate? approvalDate;

  /// [approvalDateElement] ("_approvalDate") Extensions for approvalDate
  @override
  @JsonKey(name: '_approvalDate')
  final Element? approvalDateElement;

  /// [lastReviewDate] The date on which the resource content was last
  ///  reviewed. Review happens periodically after approval but does not
  ///  change the original approval date.
  @override
  final FhirDate? lastReviewDate;

  /// [lastReviewDateElement] ("_lastReviewDate") Extensions for
  ///  lastReviewDate
  @override
  @JsonKey(name: '_lastReviewDate')
  final Element? lastReviewDateElement;

  /// [effectivePeriod] The period during which the {{title}} content was or
  ///  is planned to be in active use.
  @override
  final Period? effectivePeriod;

  /// [topic] Descriptive topics related to the content of the {{title}}.
  ///  Topics provide a high-level categorization as well as keywords for the
  ///  {{title}} that can be useful for filtering and searching.
  final List<CodeableConcept>? _topic;

  /// [topic] Descriptive topics related to the content of the {{title}}.
  ///  Topics provide a high-level categorization as well as keywords for the
  ///  {{title}} that can be useful for filtering and searching.
  @override
  List<CodeableConcept>? get topic {
    final value = _topic;
    if (value == null) return null;
    if (_topic is EqualUnmodifiableListView) return _topic;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [author] An individiual or organization primarily involved in the
  ///  creation and maintenance of the {{title}}.
  final List<ContactDetail>? _author;

  /// [author] An individiual or organization primarily involved in the
  ///  creation and maintenance of the {{title}}.
  @override
  List<ContactDetail>? get author {
    final value = _author;
    if (value == null) return null;
    if (_author is EqualUnmodifiableListView) return _author;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [editor] An individual or organization primarily responsible for
  ///  internal coherence of the {{title}}.
  final List<ContactDetail>? _editor;

  /// [editor] An individual or organization primarily responsible for
  ///  internal coherence of the {{title}}.
  @override
  List<ContactDetail>? get editor {
    final value = _editor;
    if (value == null) return null;
    if (_editor is EqualUnmodifiableListView) return _editor;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reviewer] An individual or organization asserted by the publisher to
  ///  be primarily responsible for review of some aspect of the {{title}}.
  final List<ContactDetail>? _reviewer;

  /// [reviewer] An individual or organization asserted by the publisher to
  ///  be primarily responsible for review of some aspect of the {{title}}.
  @override
  List<ContactDetail>? get reviewer {
    final value = _reviewer;
    if (value == null) return null;
    if (_reviewer is EqualUnmodifiableListView) return _reviewer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [endorser] An individual or organization asserted by the publisher to
  ///  be responsible for officially endorsing the {{title}} for use in some
  ///  setting.
  final List<ContactDetail>? _endorser;

  /// [endorser] An individual or organization asserted by the publisher to
  ///  be responsible for officially endorsing the {{title}} for use in some
  ///  setting.
  @override
  List<ContactDetail>? get endorser {
    final value = _endorser;
    if (value == null) return null;
    if (_endorser is EqualUnmodifiableListView) return _endorser;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [relatedArtifact] Related artifacts such as additional documentation,
  ///  justification, dependencies, bibliographic references, and predecessor
  ///  and successor artifacts.
  final List<RelatedArtifact>? _relatedArtifact;

  /// [relatedArtifact] Related artifacts such as additional documentation,
  ///  justification, dependencies, bibliographic references, and predecessor
  ///  and successor artifacts.
  @override
  List<RelatedArtifact>? get relatedArtifact {
    final value = _relatedArtifact;
    if (value == null) return null;
    if (_relatedArtifact is EqualUnmodifiableListView) return _relatedArtifact;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [derivedFromUri] The URL pointing to an externally-defined charge item
  ///  definition that is adhered to in whole or in part by this definition.
  final List<FhirUri>? _derivedFromUri;

  /// [derivedFromUri] The URL pointing to an externally-defined charge item
  ///  definition that is adhered to in whole or in part by this definition.
  @override
  List<FhirUri>? get derivedFromUri {
    final value = _derivedFromUri;
    if (value == null) return null;
    if (_derivedFromUri is EqualUnmodifiableListView) return _derivedFromUri;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [derivedFromUriElement] ("_derivedFromUri") Extensions for
  ///  derivedFromUri
  final List<Element>? _derivedFromUriElement;

  /// [derivedFromUriElement] ("_derivedFromUri") Extensions for
  ///  derivedFromUri
  @override
  @JsonKey(name: '_derivedFromUri')
  List<Element>? get derivedFromUriElement {
    final value = _derivedFromUriElement;
    if (value == null) return null;
    if (_derivedFromUriElement is EqualUnmodifiableListView)
      return _derivedFromUriElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [partOf] A larger definition of which this particular definition is a
  ///  component or step.
  final List<FhirCanonical>? _partOf;

  /// [partOf] A larger definition of which this particular definition is a
  ///  component or step.
  @override
  List<FhirCanonical>? get partOf {
    final value = _partOf;
    if (value == null) return null;
    if (_partOf is EqualUnmodifiableListView) return _partOf;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [replaces] As new versions of a protocol or guideline are defined,
  ///  allows identification of what versions are replaced by a new instance.
  final List<FhirCanonical>? _replaces;

  /// [replaces] As new versions of a protocol or guideline are defined,
  ///  allows identification of what versions are replaced by a new instance.
  @override
  List<FhirCanonical>? get replaces {
    final value = _replaces;
    if (value == null) return null;
    if (_replaces is EqualUnmodifiableListView) return _replaces;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [code] The defined billing details in this resource pertain to the
  ///  given billing code.
  @override
  final CodeableConcept? code;

  /// [instance] The defined billing details in this resource pertain to the
  ///  given product instance(s).
  final List<Reference>? _instance;

  /// [instance] The defined billing details in this resource pertain to the
  ///  given product instance(s).
  @override
  List<Reference>? get instance {
    final value = _instance;
    if (value == null) return null;
    if (_instance is EqualUnmodifiableListView) return _instance;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [applicability] Expressions that describe applicability criteria for
  ///  the billing code.
  final List<ChargeItemDefinitionApplicability>? _applicability;

  /// [applicability] Expressions that describe applicability criteria for
  ///  the billing code.
  @override
  List<ChargeItemDefinitionApplicability>? get applicability {
    final value = _applicability;
    if (value == null) return null;
    if (_applicability is EqualUnmodifiableListView) return _applicability;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [propertyGroup] Group of properties which are applicable under the same
  ///  conditions. If no applicability rules are established for the group,
  ///  then all properties always apply.
  final List<ChargeItemDefinitionPropertyGroup>? _propertyGroup;

  /// [propertyGroup] Group of properties which are applicable under the same
  ///  conditions. If no applicability rules are established for the group,
  ///  then all properties always apply.
  @override
  List<ChargeItemDefinitionPropertyGroup>? get propertyGroup {
    final value = _propertyGroup;
    if (value == null) return null;
    if (_propertyGroup is EqualUnmodifiableListView) return _propertyGroup;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ChargeItemDefinition(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, url: $url, urlElement: $urlElement, identifier: $identifier, version: $version, versionElement: $versionElement, versionAlgorithmString: $versionAlgorithmString, versionAlgorithmStringElement: $versionAlgorithmStringElement, versionAlgorithmCoding: $versionAlgorithmCoding, name: $name, nameElement: $nameElement, title: $title, titleElement: $titleElement, status: $status, statusElement: $statusElement, experimental: $experimental, experimentalElement: $experimentalElement, date: $date, dateElement: $dateElement, publisher: $publisher, publisherElement: $publisherElement, contact: $contact, description: $description, descriptionElement: $descriptionElement, useContext: $useContext, jurisdiction: $jurisdiction, purpose: $purpose, purposeElement: $purposeElement, copyright: $copyright, copyrightElement: $copyrightElement, copyrightLabel: $copyrightLabel, copyrightLabelElement: $copyrightLabelElement, approvalDate: $approvalDate, approvalDateElement: $approvalDateElement, lastReviewDate: $lastReviewDate, lastReviewDateElement: $lastReviewDateElement, effectivePeriod: $effectivePeriod, topic: $topic, author: $author, editor: $editor, reviewer: $reviewer, endorser: $endorser, relatedArtifact: $relatedArtifact, derivedFromUri: $derivedFromUri, derivedFromUriElement: $derivedFromUriElement, partOf: $partOf, replaces: $replaces, code: $code, instance: $instance, applicability: $applicability, propertyGroup: $propertyGroup)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChargeItemDefinitionImpl &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.urlElement, urlElement) ||
                other.urlElement == urlElement) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.version, version) || other.version == version) &&
            (identical(other.versionElement, versionElement) ||
                other.versionElement == versionElement) &&
            (identical(other.versionAlgorithmString, versionAlgorithmString) ||
                other.versionAlgorithmString == versionAlgorithmString) &&
            (identical(other.versionAlgorithmStringElement, versionAlgorithmStringElement) ||
                other.versionAlgorithmStringElement ==
                    versionAlgorithmStringElement) &&
            (identical(other.versionAlgorithmCoding, versionAlgorithmCoding) ||
                other.versionAlgorithmCoding == versionAlgorithmCoding) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.titleElement, titleElement) ||
                other.titleElement == titleElement) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusElement, statusElement) ||
                other.statusElement == statusElement) &&
            (identical(other.experimental, experimental) ||
                other.experimental == experimental) &&
            (identical(other.experimentalElement, experimentalElement) ||
                other.experimentalElement == experimentalElement) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.dateElement, dateElement) ||
                other.dateElement == dateElement) &&
            (identical(other.publisher, publisher) ||
                other.publisher == publisher) &&
            (identical(other.publisherElement, publisherElement) ||
                other.publisherElement == publisherElement) &&
            const DeepCollectionEquality().equals(other._contact, _contact) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            const DeepCollectionEquality()
                .equals(other._useContext, _useContext) &&
            const DeepCollectionEquality()
                .equals(other._jurisdiction, _jurisdiction) &&
            (identical(other.purpose, purpose) || other.purpose == purpose) &&
            (identical(other.purposeElement, purposeElement) ||
                other.purposeElement == purposeElement) &&
            (identical(other.copyright, copyright) ||
                other.copyright == copyright) &&
            (identical(other.copyrightElement, copyrightElement) ||
                other.copyrightElement == copyrightElement) &&
            (identical(other.copyrightLabel, copyrightLabel) ||
                other.copyrightLabel == copyrightLabel) &&
            (identical(other.copyrightLabelElement, copyrightLabelElement) ||
                other.copyrightLabelElement == copyrightLabelElement) &&
            (identical(other.approvalDate, approvalDate) ||
                other.approvalDate == approvalDate) &&
            (identical(other.approvalDateElement, approvalDateElement) ||
                other.approvalDateElement == approvalDateElement) &&
            (identical(other.lastReviewDate, lastReviewDate) ||
                other.lastReviewDate == lastReviewDate) &&
            (identical(other.lastReviewDateElement, lastReviewDateElement) ||
                other.lastReviewDateElement == lastReviewDateElement) &&
            (identical(other.effectivePeriod, effectivePeriod) ||
                other.effectivePeriod == effectivePeriod) &&
            const DeepCollectionEquality().equals(other._topic, _topic) &&
            const DeepCollectionEquality().equals(other._author, _author) &&
            const DeepCollectionEquality().equals(other._editor, _editor) &&
            const DeepCollectionEquality().equals(other._reviewer, _reviewer) &&
            const DeepCollectionEquality().equals(other._endorser, _endorser) &&
            const DeepCollectionEquality().equals(other._relatedArtifact, _relatedArtifact) &&
            const DeepCollectionEquality().equals(other._derivedFromUri, _derivedFromUri) &&
            const DeepCollectionEquality().equals(other._derivedFromUriElement, _derivedFromUriElement) &&
            const DeepCollectionEquality().equals(other._partOf, _partOf) &&
            const DeepCollectionEquality().equals(other._replaces, _replaces) &&
            (identical(other.code, code) || other.code == code) &&
            const DeepCollectionEquality().equals(other._instance, _instance) &&
            const DeepCollectionEquality().equals(other._applicability, _applicability) &&
            const DeepCollectionEquality().equals(other._propertyGroup, _propertyGroup));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        url,
        urlElement,
        const DeepCollectionEquality().hash(_identifier),
        version,
        versionElement,
        versionAlgorithmString,
        versionAlgorithmStringElement,
        versionAlgorithmCoding,
        name,
        nameElement,
        title,
        titleElement,
        status,
        statusElement,
        experimental,
        experimentalElement,
        date,
        dateElement,
        publisher,
        publisherElement,
        const DeepCollectionEquality().hash(_contact),
        description,
        descriptionElement,
        const DeepCollectionEquality().hash(_useContext),
        const DeepCollectionEquality().hash(_jurisdiction),
        purpose,
        purposeElement,
        copyright,
        copyrightElement,
        copyrightLabel,
        copyrightLabelElement,
        approvalDate,
        approvalDateElement,
        lastReviewDate,
        lastReviewDateElement,
        effectivePeriod,
        const DeepCollectionEquality().hash(_topic),
        const DeepCollectionEquality().hash(_author),
        const DeepCollectionEquality().hash(_editor),
        const DeepCollectionEquality().hash(_reviewer),
        const DeepCollectionEquality().hash(_endorser),
        const DeepCollectionEquality().hash(_relatedArtifact),
        const DeepCollectionEquality().hash(_derivedFromUri),
        const DeepCollectionEquality().hash(_derivedFromUriElement),
        const DeepCollectionEquality().hash(_partOf),
        const DeepCollectionEquality().hash(_replaces),
        code,
        const DeepCollectionEquality().hash(_instance),
        const DeepCollectionEquality().hash(_applicability),
        const DeepCollectionEquality().hash(_propertyGroup)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChargeItemDefinitionImplCopyWith<_$ChargeItemDefinitionImpl>
      get copyWith =>
          __$$ChargeItemDefinitionImplCopyWithImpl<_$ChargeItemDefinitionImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChargeItemDefinitionImplToJson(
      this,
    );
  }
}

abstract class _ChargeItemDefinition extends ChargeItemDefinition {
  const factory _ChargeItemDefinition(
      {@JsonKey(unknownEnumValue: R6ResourceType.ChargeItemDefinition)
      final R6ResourceType resourceType,
      final FhirId? id,
      final FhirMeta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
      final FhirCode? language,
      @JsonKey(name: '_language') final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final FhirUri? url,
      @JsonKey(name: '_url') final Element? urlElement,
      final List<Identifier>? identifier,
      final String? version,
      @JsonKey(name: '_version') final Element? versionElement,
      final String? versionAlgorithmString,
      @JsonKey(name: '_versionAlgorithmString')
      final Element? versionAlgorithmStringElement,
      final Coding? versionAlgorithmCoding,
      final String? name,
      @JsonKey(name: '_name') final Element? nameElement,
      final String? title,
      @JsonKey(name: '_title') final Element? titleElement,
      final FhirCode? status,
      @JsonKey(name: '_status') final Element? statusElement,
      final FhirBoolean? experimental,
      @JsonKey(name: '_experimental') final Element? experimentalElement,
      final FhirDateTime? date,
      @JsonKey(name: '_date') final Element? dateElement,
      final String? publisher,
      @JsonKey(name: '_publisher') final Element? publisherElement,
      final List<ContactDetail>? contact,
      final FhirMarkdown? description,
      @JsonKey(name: '_description') final Element? descriptionElement,
      final List<UsageContext>? useContext,
      final List<CodeableConcept>? jurisdiction,
      final FhirMarkdown? purpose,
      @JsonKey(name: '_purpose') final Element? purposeElement,
      final FhirMarkdown? copyright,
      @JsonKey(name: '_copyright') final Element? copyrightElement,
      final String? copyrightLabel,
      @JsonKey(name: '_copyrightLabel') final Element? copyrightLabelElement,
      final FhirDate? approvalDate,
      @JsonKey(name: '_approvalDate') final Element? approvalDateElement,
      final FhirDate? lastReviewDate,
      @JsonKey(name: '_lastReviewDate') final Element? lastReviewDateElement,
      final Period? effectivePeriod,
      final List<CodeableConcept>? topic,
      final List<ContactDetail>? author,
      final List<ContactDetail>? editor,
      final List<ContactDetail>? reviewer,
      final List<ContactDetail>? endorser,
      final List<RelatedArtifact>? relatedArtifact,
      final List<FhirUri>? derivedFromUri,
      @JsonKey(name: '_derivedFromUri')
      final List<Element>? derivedFromUriElement,
      final List<FhirCanonical>? partOf,
      final List<FhirCanonical>? replaces,
      final CodeableConcept? code,
      final List<Reference>? instance,
      final List<ChargeItemDefinitionApplicability>? applicability,
      final List<ChargeItemDefinitionPropertyGroup>?
          propertyGroup}) = _$ChargeItemDefinitionImpl;
  const _ChargeItemDefinition._() : super._();

  factory _ChargeItemDefinition.fromJson(Map<String, dynamic> json) =
      _$ChargeItemDefinitionImpl.fromJson;

  @override

  /// [resourceType] This is a ChargeItemDefinition resource
  @JsonKey(unknownEnumValue: R6ResourceType.ChargeItemDefinition)
  R6ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  FhirMeta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  FhirCode? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [url] An absolute URI that is used to identify this charge item
  ///  definition when it is referenced in a specification, model, design or
  ///  an instance; also called its canonical identifier. This SHOULD be
  ///  globally unique and SHOULD be a literal address at which an
  ///  authoritative instance of this charge item definition is (or will be)
  ///  published. This URL can be the target of a canonical reference. It
  ///  SHALL remain the same when the charge item definition is stored on
  ///  different servers.
  FhirUri? get url;
  @override

  /// [urlElement] ("_url") Extensions for url
  @JsonKey(name: '_url')
  Element? get urlElement;
  @override

  /// [identifier] A formal identifier that is used to identify this charge
  ///  item definition when it is represented in other formats, or referenced
  ///  in a specification, model, design or an instance.
  List<Identifier>? get identifier;
  @override

  /// [version] The identifier that is used to identify this version of the
  ///  charge item definition when it is referenced in a specification,
  ///  model, design or instance. This is an arbitrary value managed by the
  ///  charge item definition author and is not expected to be globally
  ///  unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
  ///  managed version is not available. There is also no expectation that
  ///  versions can be placed in a lexicographical sequence. To provide a
  ///  version consistent with the Decision Support Service specification,
  ///  use the format Major.Minor.Revision (e.g. 1.0.0). For more information
  ///  on versioning knowledge assets, refer to the Decision Support Service
  ///  specification. Note that a version is required for non-experimental
  ///  active assets.
  String? get version;
  @override

  /// [versionElement] ("_version") Extensions for version
  @JsonKey(name: '_version')
  Element? get versionElement;
  @override

  /// [versionAlgorithmString] Indicates the mechanism used to compare
  ///  versions to determine which is more current.
  String? get versionAlgorithmString;
  @override

  /// [versionAlgorithmStringElement] ("_versionAlgorithmString") Extensions
  ///  for versionAlgorithmString
  @JsonKey(name: '_versionAlgorithmString')
  Element? get versionAlgorithmStringElement;
  @override

  /// [versionAlgorithmCoding] Indicates the mechanism used to compare
  ///  versions to determine which is more current.
  Coding? get versionAlgorithmCoding;
  @override

  /// [name] A natural language name identifying the ChargeItemDefinition.
  ///  This name should be usable as an identifier for the module by machine
  ///  processing applications such as code generation.
  String? get name;
  @override

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [title] A short, descriptive, user-friendly title for the charge item
  ///  definition.
  String? get title;
  @override

  /// [titleElement] ("_title") Extensions for title
  @JsonKey(name: '_title')
  Element? get titleElement;
  @override

  /// [status] The current state of the ChargeItemDefinition.
  FhirCode? get status;
  @override

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement;
  @override

  /// [experimental] A Boolean value to indicate that this charge item
  ///  definition is authored for testing purposes (or
  ///  education/evaluation/marketing) and is not intended to be used for
  ///  genuine usage.
  FhirBoolean? get experimental;
  @override

  /// [experimentalElement] ("_experimental") Extensions for experimental
  @JsonKey(name: '_experimental')
  Element? get experimentalElement;
  @override

  /// [date] The date  (and optionally time) when the charge item definition
  ///  was last significantly changed. The date must change when the business
  ///  version changes and it must change if the status code changes. In
  ///  addition, it should change when the substantive content of the charge
  ///  item definition changes.
  FhirDateTime? get date;
  @override

  /// [dateElement] ("_date") Extensions for date
  @JsonKey(name: '_date')
  Element? get dateElement;
  @override

  /// [publisher] The name of the organization or individual responsible for
  ///  the release and ongoing maintenance of the charge item definition.
  String? get publisher;
  @override

  /// [publisherElement] ("_publisher") Extensions for publisher
  @JsonKey(name: '_publisher')
  Element? get publisherElement;
  @override

  /// [contact] Contact details to assist a user in finding and communicating
  ///  with the publisher.
  List<ContactDetail>? get contact;
  @override

  /// [description] A free text natural language description of the charge
  ///  item definition from a consumer's perspective.
  FhirMarkdown? get description;
  @override

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [useContext] The content was developed with a focus and intent of
  ///  supporting the contexts that are listed. These contexts may be general
  ///  categories (gender, age, ...) or may be references to specific
  ///  programs (insurance plans, studies, ...) and may be used to assist
  ///  with indexing and searching for appropriate charge item definition
  ///  instances.
  List<UsageContext>? get useContext;
  @override

  /// [jurisdiction] A legal or geographic region in which the charge item
  ///  definition is intended to be used.
  List<CodeableConcept>? get jurisdiction;
  @override

  /// [purpose] Explanation of why this charge item definition is needed and
  ///  why it has been designed as it has.
  FhirMarkdown? get purpose;
  @override

  /// [purposeElement] ("_purpose") Extensions for purpose
  @JsonKey(name: '_purpose')
  Element? get purposeElement;
  @override

  /// [copyright] A copyright statement relating to the charge item
  ///  definition and/or its contents. Copyright statements are generally
  ///  legal restrictions on the use and publishing of the charge item
  ///  definition.
  FhirMarkdown? get copyright;
  @override

  /// [copyrightElement] ("_copyright") Extensions for copyright
  @JsonKey(name: '_copyright')
  Element? get copyrightElement;
  @override

  /// [copyrightLabel] A short string (<50 characters), suitable for
  ///  inclusion in a page footer that identifies the copyright holder,
  ///  effective period, and optionally whether rights are resctricted. (e.g.
  ///  'All rights reserved', 'Some rights reserved').
  String? get copyrightLabel;
  @override

  /// [copyrightLabelElement] ("_copyrightLabel") Extensions for
  ///  copyrightLabel
  @JsonKey(name: '_copyrightLabel')
  Element? get copyrightLabelElement;
  @override

  /// [approvalDate] The date on which the resource content was approved by
  ///  the publisher. Approval happens once when the content is officially
  ///  approved for usage.
  FhirDate? get approvalDate;
  @override

  /// [approvalDateElement] ("_approvalDate") Extensions for approvalDate
  @JsonKey(name: '_approvalDate')
  Element? get approvalDateElement;
  @override

  /// [lastReviewDate] The date on which the resource content was last
  ///  reviewed. Review happens periodically after approval but does not
  ///  change the original approval date.
  FhirDate? get lastReviewDate;
  @override

  /// [lastReviewDateElement] ("_lastReviewDate") Extensions for
  ///  lastReviewDate
  @JsonKey(name: '_lastReviewDate')
  Element? get lastReviewDateElement;
  @override

  /// [effectivePeriod] The period during which the {{title}} content was or
  ///  is planned to be in active use.
  Period? get effectivePeriod;
  @override

  /// [topic] Descriptive topics related to the content of the {{title}}.
  ///  Topics provide a high-level categorization as well as keywords for the
  ///  {{title}} that can be useful for filtering and searching.
  List<CodeableConcept>? get topic;
  @override

  /// [author] An individiual or organization primarily involved in the
  ///  creation and maintenance of the {{title}}.
  List<ContactDetail>? get author;
  @override

  /// [editor] An individual or organization primarily responsible for
  ///  internal coherence of the {{title}}.
  List<ContactDetail>? get editor;
  @override

  /// [reviewer] An individual or organization asserted by the publisher to
  ///  be primarily responsible for review of some aspect of the {{title}}.
  List<ContactDetail>? get reviewer;
  @override

  /// [endorser] An individual or organization asserted by the publisher to
  ///  be responsible for officially endorsing the {{title}} for use in some
  ///  setting.
  List<ContactDetail>? get endorser;
  @override

  /// [relatedArtifact] Related artifacts such as additional documentation,
  ///  justification, dependencies, bibliographic references, and predecessor
  ///  and successor artifacts.
  List<RelatedArtifact>? get relatedArtifact;
  @override

  /// [derivedFromUri] The URL pointing to an externally-defined charge item
  ///  definition that is adhered to in whole or in part by this definition.
  List<FhirUri>? get derivedFromUri;
  @override

  /// [derivedFromUriElement] ("_derivedFromUri") Extensions for
  ///  derivedFromUri
  @JsonKey(name: '_derivedFromUri')
  List<Element>? get derivedFromUriElement;
  @override

  /// [partOf] A larger definition of which this particular definition is a
  ///  component or step.
  List<FhirCanonical>? get partOf;
  @override

  /// [replaces] As new versions of a protocol or guideline are defined,
  ///  allows identification of what versions are replaced by a new instance.
  List<FhirCanonical>? get replaces;
  @override

  /// [code] The defined billing details in this resource pertain to the
  ///  given billing code.
  CodeableConcept? get code;
  @override

  /// [instance] The defined billing details in this resource pertain to the
  ///  given product instance(s).
  List<Reference>? get instance;
  @override

  /// [applicability] Expressions that describe applicability criteria for
  ///  the billing code.
  List<ChargeItemDefinitionApplicability>? get applicability;
  @override

  /// [propertyGroup] Group of properties which are applicable under the same
  ///  conditions. If no applicability rules are established for the group,
  ///  then all properties always apply.
  List<ChargeItemDefinitionPropertyGroup>? get propertyGroup;
  @override
  @JsonKey(ignore: true)
  _$$ChargeItemDefinitionImplCopyWith<_$ChargeItemDefinitionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChargeItemDefinitionApplicability _$ChargeItemDefinitionApplicabilityFromJson(
    Map<String, dynamic> json) {
  return _ChargeItemDefinitionApplicability.fromJson(json);
}

/// @nodoc
mixin _$ChargeItemDefinitionApplicability {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [condition] An expression that returns true or false, indicating
  ///  whether the condition is satisfied. When using FHIRPath expressions,
  ///  the %context environment variable must be replaced at runtime with the
  ///  ChargeItem resource to which this definition is applied.
  FhirExpression? get condition => throw _privateConstructorUsedError;

  /// [effectivePeriod] The period during which the charge item definition
  ///  content was or is planned to be in active use.
  Period? get effectivePeriod => throw _privateConstructorUsedError;

  /// [relatedArtifact] Reference to / quotation of the external source of
  ///  the group of properties.
  RelatedArtifact? get relatedArtifact => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChargeItemDefinitionApplicabilityCopyWith<ChargeItemDefinitionApplicability>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChargeItemDefinitionApplicabilityCopyWith<$Res> {
  factory $ChargeItemDefinitionApplicabilityCopyWith(
          ChargeItemDefinitionApplicability value,
          $Res Function(ChargeItemDefinitionApplicability) then) =
      _$ChargeItemDefinitionApplicabilityCopyWithImpl<$Res,
          ChargeItemDefinitionApplicability>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirExpression? condition,
      Period? effectivePeriod,
      RelatedArtifact? relatedArtifact});

  $FhirExpressionCopyWith<$Res>? get condition;
  $PeriodCopyWith<$Res>? get effectivePeriod;
  $RelatedArtifactCopyWith<$Res>? get relatedArtifact;
}

/// @nodoc
class _$ChargeItemDefinitionApplicabilityCopyWithImpl<$Res,
        $Val extends ChargeItemDefinitionApplicability>
    implements $ChargeItemDefinitionApplicabilityCopyWith<$Res> {
  _$ChargeItemDefinitionApplicabilityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? condition = freezed,
    Object? effectivePeriod = freezed,
    Object? relatedArtifact = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as FhirExpression?,
      effectivePeriod: freezed == effectivePeriod
          ? _value.effectivePeriod
          : effectivePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      relatedArtifact: freezed == relatedArtifact
          ? _value.relatedArtifact
          : relatedArtifact // ignore: cast_nullable_to_non_nullable
              as RelatedArtifact?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FhirExpressionCopyWith<$Res>? get condition {
    if (_value.condition == null) {
      return null;
    }

    return $FhirExpressionCopyWith<$Res>(_value.condition!, (value) {
      return _then(_value.copyWith(condition: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get effectivePeriod {
    if (_value.effectivePeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.effectivePeriod!, (value) {
      return _then(_value.copyWith(effectivePeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RelatedArtifactCopyWith<$Res>? get relatedArtifact {
    if (_value.relatedArtifact == null) {
      return null;
    }

    return $RelatedArtifactCopyWith<$Res>(_value.relatedArtifact!, (value) {
      return _then(_value.copyWith(relatedArtifact: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChargeItemDefinitionApplicabilityImplCopyWith<$Res>
    implements $ChargeItemDefinitionApplicabilityCopyWith<$Res> {
  factory _$$ChargeItemDefinitionApplicabilityImplCopyWith(
          _$ChargeItemDefinitionApplicabilityImpl value,
          $Res Function(_$ChargeItemDefinitionApplicabilityImpl) then) =
      __$$ChargeItemDefinitionApplicabilityImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirExpression? condition,
      Period? effectivePeriod,
      RelatedArtifact? relatedArtifact});

  @override
  $FhirExpressionCopyWith<$Res>? get condition;
  @override
  $PeriodCopyWith<$Res>? get effectivePeriod;
  @override
  $RelatedArtifactCopyWith<$Res>? get relatedArtifact;
}

/// @nodoc
class __$$ChargeItemDefinitionApplicabilityImplCopyWithImpl<$Res>
    extends _$ChargeItemDefinitionApplicabilityCopyWithImpl<$Res,
        _$ChargeItemDefinitionApplicabilityImpl>
    implements _$$ChargeItemDefinitionApplicabilityImplCopyWith<$Res> {
  __$$ChargeItemDefinitionApplicabilityImplCopyWithImpl(
      _$ChargeItemDefinitionApplicabilityImpl _value,
      $Res Function(_$ChargeItemDefinitionApplicabilityImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? condition = freezed,
    Object? effectivePeriod = freezed,
    Object? relatedArtifact = freezed,
  }) {
    return _then(_$ChargeItemDefinitionApplicabilityImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as FhirExpression?,
      effectivePeriod: freezed == effectivePeriod
          ? _value.effectivePeriod
          : effectivePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      relatedArtifact: freezed == relatedArtifact
          ? _value.relatedArtifact
          : relatedArtifact // ignore: cast_nullable_to_non_nullable
              as RelatedArtifact?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChargeItemDefinitionApplicabilityImpl
    extends _ChargeItemDefinitionApplicability {
  const _$ChargeItemDefinitionApplicabilityImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.condition,
      this.effectivePeriod,
      this.relatedArtifact})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ChargeItemDefinitionApplicabilityImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChargeItemDefinitionApplicabilityImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [condition] An expression that returns true or false, indicating
  ///  whether the condition is satisfied. When using FHIRPath expressions,
  ///  the %context environment variable must be replaced at runtime with the
  ///  ChargeItem resource to which this definition is applied.
  @override
  final FhirExpression? condition;

  /// [effectivePeriod] The period during which the charge item definition
  ///  content was or is planned to be in active use.
  @override
  final Period? effectivePeriod;

  /// [relatedArtifact] Reference to / quotation of the external source of
  ///  the group of properties.
  @override
  final RelatedArtifact? relatedArtifact;

  @override
  String toString() {
    return 'ChargeItemDefinitionApplicability(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, condition: $condition, effectivePeriod: $effectivePeriod, relatedArtifact: $relatedArtifact)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChargeItemDefinitionApplicabilityImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.condition, condition) ||
                other.condition == condition) &&
            (identical(other.effectivePeriod, effectivePeriod) ||
                other.effectivePeriod == effectivePeriod) &&
            (identical(other.relatedArtifact, relatedArtifact) ||
                other.relatedArtifact == relatedArtifact));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      condition,
      effectivePeriod,
      relatedArtifact);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChargeItemDefinitionApplicabilityImplCopyWith<
          _$ChargeItemDefinitionApplicabilityImpl>
      get copyWith => __$$ChargeItemDefinitionApplicabilityImplCopyWithImpl<
          _$ChargeItemDefinitionApplicabilityImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChargeItemDefinitionApplicabilityImplToJson(
      this,
    );
  }
}

abstract class _ChargeItemDefinitionApplicability
    extends ChargeItemDefinitionApplicability {
  const factory _ChargeItemDefinitionApplicability(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final FhirExpression? condition,
          final Period? effectivePeriod,
          final RelatedArtifact? relatedArtifact}) =
      _$ChargeItemDefinitionApplicabilityImpl;
  const _ChargeItemDefinitionApplicability._() : super._();

  factory _ChargeItemDefinitionApplicability.fromJson(
          Map<String, dynamic> json) =
      _$ChargeItemDefinitionApplicabilityImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [condition] An expression that returns true or false, indicating
  ///  whether the condition is satisfied. When using FHIRPath expressions,
  ///  the %context environment variable must be replaced at runtime with the
  ///  ChargeItem resource to which this definition is applied.
  FhirExpression? get condition;
  @override

  /// [effectivePeriod] The period during which the charge item definition
  ///  content was or is planned to be in active use.
  Period? get effectivePeriod;
  @override

  /// [relatedArtifact] Reference to / quotation of the external source of
  ///  the group of properties.
  RelatedArtifact? get relatedArtifact;
  @override
  @JsonKey(ignore: true)
  _$$ChargeItemDefinitionApplicabilityImplCopyWith<
          _$ChargeItemDefinitionApplicabilityImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChargeItemDefinitionPropertyGroup _$ChargeItemDefinitionPropertyGroupFromJson(
    Map<String, dynamic> json) {
  return _ChargeItemDefinitionPropertyGroup.fromJson(json);
}

/// @nodoc
mixin _$ChargeItemDefinitionPropertyGroup {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [applicability] Expressions that describe applicability criteria for
  ///  the priceComponent.
  List<ChargeItemDefinitionApplicability>? get applicability =>
      throw _privateConstructorUsedError;

  /// [priceComponent] The price for a ChargeItem may be calculated as a base
  ///  price with surcharges/deductions that apply in certain conditions. A
  ///  ChargeItemDefinition resource that defines the prices, factors and
  ///  conditions that apply to a billing code is currently under
  ///  development. The priceComponent element can be used to offer
  ///  transparency to the recipient of the Invoice of how the prices have
  ///  been calculated.
  List<MonetaryComponent>? get priceComponent =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChargeItemDefinitionPropertyGroupCopyWith<ChargeItemDefinitionPropertyGroup>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChargeItemDefinitionPropertyGroupCopyWith<$Res> {
  factory $ChargeItemDefinitionPropertyGroupCopyWith(
          ChargeItemDefinitionPropertyGroup value,
          $Res Function(ChargeItemDefinitionPropertyGroup) then) =
      _$ChargeItemDefinitionPropertyGroupCopyWithImpl<$Res,
          ChargeItemDefinitionPropertyGroup>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<ChargeItemDefinitionApplicability>? applicability,
      List<MonetaryComponent>? priceComponent});
}

/// @nodoc
class _$ChargeItemDefinitionPropertyGroupCopyWithImpl<$Res,
        $Val extends ChargeItemDefinitionPropertyGroup>
    implements $ChargeItemDefinitionPropertyGroupCopyWith<$Res> {
  _$ChargeItemDefinitionPropertyGroupCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? applicability = freezed,
    Object? priceComponent = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      applicability: freezed == applicability
          ? _value.applicability
          : applicability // ignore: cast_nullable_to_non_nullable
              as List<ChargeItemDefinitionApplicability>?,
      priceComponent: freezed == priceComponent
          ? _value.priceComponent
          : priceComponent // ignore: cast_nullable_to_non_nullable
              as List<MonetaryComponent>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChargeItemDefinitionPropertyGroupImplCopyWith<$Res>
    implements $ChargeItemDefinitionPropertyGroupCopyWith<$Res> {
  factory _$$ChargeItemDefinitionPropertyGroupImplCopyWith(
          _$ChargeItemDefinitionPropertyGroupImpl value,
          $Res Function(_$ChargeItemDefinitionPropertyGroupImpl) then) =
      __$$ChargeItemDefinitionPropertyGroupImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<ChargeItemDefinitionApplicability>? applicability,
      List<MonetaryComponent>? priceComponent});
}

/// @nodoc
class __$$ChargeItemDefinitionPropertyGroupImplCopyWithImpl<$Res>
    extends _$ChargeItemDefinitionPropertyGroupCopyWithImpl<$Res,
        _$ChargeItemDefinitionPropertyGroupImpl>
    implements _$$ChargeItemDefinitionPropertyGroupImplCopyWith<$Res> {
  __$$ChargeItemDefinitionPropertyGroupImplCopyWithImpl(
      _$ChargeItemDefinitionPropertyGroupImpl _value,
      $Res Function(_$ChargeItemDefinitionPropertyGroupImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? applicability = freezed,
    Object? priceComponent = freezed,
  }) {
    return _then(_$ChargeItemDefinitionPropertyGroupImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      applicability: freezed == applicability
          ? _value._applicability
          : applicability // ignore: cast_nullable_to_non_nullable
              as List<ChargeItemDefinitionApplicability>?,
      priceComponent: freezed == priceComponent
          ? _value._priceComponent
          : priceComponent // ignore: cast_nullable_to_non_nullable
              as List<MonetaryComponent>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChargeItemDefinitionPropertyGroupImpl
    extends _ChargeItemDefinitionPropertyGroup {
  const _$ChargeItemDefinitionPropertyGroupImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<ChargeItemDefinitionApplicability>? applicability,
      final List<MonetaryComponent>? priceComponent})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _applicability = applicability,
        _priceComponent = priceComponent,
        super._();

  factory _$ChargeItemDefinitionPropertyGroupImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ChargeItemDefinitionPropertyGroupImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [applicability] Expressions that describe applicability criteria for
  ///  the priceComponent.
  final List<ChargeItemDefinitionApplicability>? _applicability;

  /// [applicability] Expressions that describe applicability criteria for
  ///  the priceComponent.
  @override
  List<ChargeItemDefinitionApplicability>? get applicability {
    final value = _applicability;
    if (value == null) return null;
    if (_applicability is EqualUnmodifiableListView) return _applicability;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [priceComponent] The price for a ChargeItem may be calculated as a base
  ///  price with surcharges/deductions that apply in certain conditions. A
  ///  ChargeItemDefinition resource that defines the prices, factors and
  ///  conditions that apply to a billing code is currently under
  ///  development. The priceComponent element can be used to offer
  ///  transparency to the recipient of the Invoice of how the prices have
  ///  been calculated.
  final List<MonetaryComponent>? _priceComponent;

  /// [priceComponent] The price for a ChargeItem may be calculated as a base
  ///  price with surcharges/deductions that apply in certain conditions. A
  ///  ChargeItemDefinition resource that defines the prices, factors and
  ///  conditions that apply to a billing code is currently under
  ///  development. The priceComponent element can be used to offer
  ///  transparency to the recipient of the Invoice of how the prices have
  ///  been calculated.
  @override
  List<MonetaryComponent>? get priceComponent {
    final value = _priceComponent;
    if (value == null) return null;
    if (_priceComponent is EqualUnmodifiableListView) return _priceComponent;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ChargeItemDefinitionPropertyGroup(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, applicability: $applicability, priceComponent: $priceComponent)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChargeItemDefinitionPropertyGroupImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._applicability, _applicability) &&
            const DeepCollectionEquality()
                .equals(other._priceComponent, _priceComponent));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_applicability),
      const DeepCollectionEquality().hash(_priceComponent));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChargeItemDefinitionPropertyGroupImplCopyWith<
          _$ChargeItemDefinitionPropertyGroupImpl>
      get copyWith => __$$ChargeItemDefinitionPropertyGroupImplCopyWithImpl<
          _$ChargeItemDefinitionPropertyGroupImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChargeItemDefinitionPropertyGroupImplToJson(
      this,
    );
  }
}

abstract class _ChargeItemDefinitionPropertyGroup
    extends ChargeItemDefinitionPropertyGroup {
  const factory _ChargeItemDefinitionPropertyGroup(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<ChargeItemDefinitionApplicability>? applicability,
          final List<MonetaryComponent>? priceComponent}) =
      _$ChargeItemDefinitionPropertyGroupImpl;
  const _ChargeItemDefinitionPropertyGroup._() : super._();

  factory _ChargeItemDefinitionPropertyGroup.fromJson(
          Map<String, dynamic> json) =
      _$ChargeItemDefinitionPropertyGroupImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [applicability] Expressions that describe applicability criteria for
  ///  the priceComponent.
  List<ChargeItemDefinitionApplicability>? get applicability;
  @override

  /// [priceComponent] The price for a ChargeItem may be calculated as a base
  ///  price with surcharges/deductions that apply in certain conditions. A
  ///  ChargeItemDefinition resource that defines the prices, factors and
  ///  conditions that apply to a billing code is currently under
  ///  development. The priceComponent element can be used to offer
  ///  transparency to the recipient of the Invoice of how the prices have
  ///  been calculated.
  List<MonetaryComponent>? get priceComponent;
  @override
  @JsonKey(ignore: true)
  _$$ChargeItemDefinitionPropertyGroupImplCopyWith<
          _$ChargeItemDefinitionPropertyGroupImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Contract _$ContractFromJson(Map<String, dynamic> json) {
  return _Contract.fromJson(json);
}

/// @nodoc
mixin _$Contract {
  /// [resourceType] This is a Contract resource
  @JsonKey(unknownEnumValue: R6ResourceType.Contract)
  R6ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  FhirMeta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  FhirCode? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Unique identifier for this Contract or a derivative that
  ///  references a Source Contract.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [url] Canonical identifier for this contract, represented as a URI
  ///  (globally unique).
  FhirUri? get url => throw _privateConstructorUsedError;

  /// [urlElement] ("_url") Extensions for url
  @JsonKey(name: '_url')
  Element? get urlElement => throw _privateConstructorUsedError;

  /// [version] An edition identifier used for business purposes to label
  ///  business significant variants.
  String? get version => throw _privateConstructorUsedError;

  /// [versionElement] ("_version") Extensions for version
  @JsonKey(name: '_version')
  Element? get versionElement => throw _privateConstructorUsedError;

  /// [status] The status of the resource instance.
  FhirCode? get status => throw _privateConstructorUsedError;

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement => throw _privateConstructorUsedError;

  /// [legalState] Legal states of the formation of a legal instrument, which
  ///  is a formally executed written document that can be formally
  ///  attributed to its author, records and formally expresses a legally
  ///  enforceable act, process, or contractual duty, obligation, or right,
  ///  and therefore evidences that act, process, or agreement.
  CodeableConcept? get legalState => throw _privateConstructorUsedError;

  /// [instantiatesCanonical] The URL pointing to a FHIR-defined Contract
  ///  Definition that is adhered to in whole or part by this Contract.
  Reference? get instantiatesCanonical => throw _privateConstructorUsedError;

  /// [instantiatesUri] The URL pointing to an externally maintained
  ///  definition that is adhered to in whole or in part by this Contract.
  FhirUri? get instantiatesUri => throw _privateConstructorUsedError;

  /// [instantiatesUriElement] ("_instantiatesUri") Extensions for
  ///  instantiatesUri
  @JsonKey(name: '_instantiatesUri')
  Element? get instantiatesUriElement => throw _privateConstructorUsedError;

  /// [contentDerivative] The minimal content derived from the basal
  ///  information source at a specific stage in its lifecycle.
  CodeableConcept? get contentDerivative => throw _privateConstructorUsedError;

  /// [issued] When this  Contract was issued.
  FhirDateTime? get issued => throw _privateConstructorUsedError;

  /// [issuedElement] ("_issued") Extensions for issued
  @JsonKey(name: '_issued')
  Element? get issuedElement => throw _privateConstructorUsedError;

  /// [applies] Relevant time or time-period when this Contract is applicable.
  Period? get applies => throw _privateConstructorUsedError;

  /// [expirationType] Event resulting in discontinuation or termination of
  ///  this Contract instance by one or more parties to the contract.
  CodeableConcept? get expirationType => throw _privateConstructorUsedError;

  /// [subject] The target entity impacted by or of interest to parties to
  ///  the agreement.
  List<Reference>? get subject => throw _privateConstructorUsedError;

  /// [authority] A formally or informally recognized grouping of people,
  ///  principals, organizations, or jurisdictions formed for the purpose of
  ///  achieving some form of collective action such as the promulgation,
  ///  administration and enforcement of contracts and policies.
  List<Reference>? get authority => throw _privateConstructorUsedError;

  /// [domain] Recognized governance framework or system operating with a
  ///  circumscribed scope in accordance with specified principles, policies,
  ///  processes or procedures for managing rights, actions, or behaviors of
  ///  parties or principals relative to resources.
  List<Reference>? get domain => throw _privateConstructorUsedError;

  /// [site] Sites in which the contract is complied with,  exercised, or in
  ///  force.
  List<Reference>? get site => throw _privateConstructorUsedError;

  /// [name] A natural language name identifying this Contract definition,
  ///  derivative, or instance in any legal state. Provides additional
  ///  information about its content. This name should be usable as an
  ///  identifier for the module by machine processing applications such as
  ///  code generation.
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [title] A short, descriptive, user-friendly title for this Contract
  ///  definition, derivative, or instance in any legal state.
  String? get title => throw _privateConstructorUsedError;

  /// [titleElement] ("_title") Extensions for title
  @JsonKey(name: '_title')
  Element? get titleElement => throw _privateConstructorUsedError;

  /// [subtitle] A more detailed or qualifying explanatory or alternate
  ///  user-friendly title for this Contract definition, derivative, or
  ///  instance in any legal state.
  String? get subtitle => throw _privateConstructorUsedError;

  /// [subtitleElement] ("_subtitle") Extensions for subtitle
  @JsonKey(name: '_subtitle')
  Element? get subtitleElement => throw _privateConstructorUsedError;

  /// [alias] Alternative representation of the title for this Contract
  ///  definition, derivative, or instance in any legal state., e.g., a
  ///  domain specific contract number related to legislation.
  List<String>? get alias => throw _privateConstructorUsedError;

  /// [aliasElement] ("_alias") Extensions for alias
  @JsonKey(name: '_alias')
  List<Element>? get aliasElement => throw _privateConstructorUsedError;

  /// [author] The individual or organization that authored the Contract
  ///  definition, derivative, or instance in any legal state.
  Reference? get author => throw _privateConstructorUsedError;

  /// [scope] A selector of legal concerns for this Contract definition,
  ///  derivative, or instance in any legal state.
  CodeableConcept? get scope => throw _privateConstructorUsedError;

  /// [topicCodeableConcept] Narrows the range of legal concerns to focus on
  ///  the achievement of specific contractual objectives.
  CodeableConcept? get topicCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [topicReference] Narrows the range of legal concerns to focus on the
  ///  achievement of specific contractual objectives.
  Reference? get topicReference => throw _privateConstructorUsedError;

  /// [type] A high-level category for the legal instrument, whether
  ///  constructed as a Contract definition, derivative, or instance in any
  ///  legal state.  Provides additional information about its content within
  ///  the context of the Contract's scope to distinguish the kinds of
  ///  systems that would be interested in the contract.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [subType] Sub-category for the Contract that distinguishes the kinds of
  ///  systems that would be interested in the Contract within the context of
  ///  the Contract's scope.
  List<CodeableConcept>? get subType => throw _privateConstructorUsedError;

  /// [contentDefinition] Precusory content developed with a focus and intent
  ///  of supporting the formation a Contract instance, which may be
  ///  associated with and transformable into a Contract.
  ContractContentDefinition? get contentDefinition =>
      throw _privateConstructorUsedError;

  /// [term] One or more Contract Provisions, which may be related and
  ///  conveyed as a group, and may contain nested groups.
  List<ContractTerm>? get term => throw _privateConstructorUsedError;

  /// [supportingInfo] Information that may be needed by/relevant to the
  ///  performer in their execution of this term action.
  List<Reference>? get supportingInfo => throw _privateConstructorUsedError;

  /// [relevantHistory] Links to Provenance records for past versions of this
  ///  Contract definition, derivative, or instance, which identify key state
  ///  transitions or updates that are likely to be relevant to a user
  ///  looking at the current version of the Contract.  The Provenance.entity
  ///  indicates the target that was changed in the update (see
  ///  [Provenance.entity](provenance-definitions.html#Provenance.entity)).
  List<Reference>? get relevantHistory => throw _privateConstructorUsedError;

  /// [signer] Parties with legal standing in the Contract, including the
  ///  principal parties, the grantor(s) and grantee(s), which are any person
  ///  or organization bound by the contract, and any ancillary parties,
  ///  which facilitate the execution of the contract such as a notary or
  ///  witness.
  List<ContractSigner>? get signer => throw _privateConstructorUsedError;

  /// [friendly] The "patient friendly language" versionof the Contract in
  ///  whole or in parts. "Patient friendly language" means the
  ///  representation of the Contract and Contract Provisions in a manner
  ///  that is readily accessible and understandable by a layperson in
  ///  accordance with best practices for communication styles that ensure
  ///  that those agreeing to or signing the Contract understand the roles,
  ///  actions, obligations, responsibilities, and implication of the
  ///  agreement.
  List<ContractFriendly>? get friendly => throw _privateConstructorUsedError;

  /// [legal] List of Legal expressions or representations of this Contract.
  List<ContractLegal>? get legal => throw _privateConstructorUsedError;

  /// [rule] List of Computable Policy Rule Language Representations of this
  ///  Contract.
  List<ContractRule>? get rule => throw _privateConstructorUsedError;

  /// [legallyBindingAttachment] Legally binding Contract: This is the signed
  ///  and legally recognized representation of the Contract, which is
  ///  considered the "source of truth" and which would be the basis for
  ///  legal action related to enforcement of this Contract.
  Attachment? get legallyBindingAttachment =>
      throw _privateConstructorUsedError;

  /// [legallyBindingReference] Legally binding Contract: This is the signed
  ///  and legally recognized representation of the Contract, which is
  ///  considered the "source of truth" and which would be the basis for
  ///  legal action related to enforcement of this Contract.
  Reference? get legallyBindingReference => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractCopyWith<Contract> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractCopyWith<$Res> {
  factory $ContractCopyWith(Contract value, $Res Function(Contract) then) =
      _$ContractCopyWithImpl<$Res, Contract>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.Contract)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      FhirUri? url,
      @JsonKey(name: '_url') Element? urlElement,
      String? version,
      @JsonKey(name: '_version') Element? versionElement,
      FhirCode? status,
      @JsonKey(name: '_status') Element? statusElement,
      CodeableConcept? legalState,
      Reference? instantiatesCanonical,
      FhirUri? instantiatesUri,
      @JsonKey(name: '_instantiatesUri') Element? instantiatesUriElement,
      CodeableConcept? contentDerivative,
      FhirDateTime? issued,
      @JsonKey(name: '_issued') Element? issuedElement,
      Period? applies,
      CodeableConcept? expirationType,
      List<Reference>? subject,
      List<Reference>? authority,
      List<Reference>? domain,
      List<Reference>? site,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      String? title,
      @JsonKey(name: '_title') Element? titleElement,
      String? subtitle,
      @JsonKey(name: '_subtitle') Element? subtitleElement,
      List<String>? alias,
      @JsonKey(name: '_alias') List<Element>? aliasElement,
      Reference? author,
      CodeableConcept? scope,
      CodeableConcept? topicCodeableConcept,
      Reference? topicReference,
      CodeableConcept? type,
      List<CodeableConcept>? subType,
      ContractContentDefinition? contentDefinition,
      List<ContractTerm>? term,
      List<Reference>? supportingInfo,
      List<Reference>? relevantHistory,
      List<ContractSigner>? signer,
      List<ContractFriendly>? friendly,
      List<ContractLegal>? legal,
      List<ContractRule>? rule,
      Attachment? legallyBindingAttachment,
      Reference? legallyBindingReference});

  $FhirMetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get urlElement;
  $ElementCopyWith<$Res>? get versionElement;
  $ElementCopyWith<$Res>? get statusElement;
  $CodeableConceptCopyWith<$Res>? get legalState;
  $ReferenceCopyWith<$Res>? get instantiatesCanonical;
  $ElementCopyWith<$Res>? get instantiatesUriElement;
  $CodeableConceptCopyWith<$Res>? get contentDerivative;
  $ElementCopyWith<$Res>? get issuedElement;
  $PeriodCopyWith<$Res>? get applies;
  $CodeableConceptCopyWith<$Res>? get expirationType;
  $ElementCopyWith<$Res>? get nameElement;
  $ElementCopyWith<$Res>? get titleElement;
  $ElementCopyWith<$Res>? get subtitleElement;
  $ReferenceCopyWith<$Res>? get author;
  $CodeableConceptCopyWith<$Res>? get scope;
  $CodeableConceptCopyWith<$Res>? get topicCodeableConcept;
  $ReferenceCopyWith<$Res>? get topicReference;
  $CodeableConceptCopyWith<$Res>? get type;
  $ContractContentDefinitionCopyWith<$Res>? get contentDefinition;
  $AttachmentCopyWith<$Res>? get legallyBindingAttachment;
  $ReferenceCopyWith<$Res>? get legallyBindingReference;
}

/// @nodoc
class _$ContractCopyWithImpl<$Res, $Val extends Contract>
    implements $ContractCopyWith<$Res> {
  _$ContractCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? url = freezed,
    Object? urlElement = freezed,
    Object? version = freezed,
    Object? versionElement = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? legalState = freezed,
    Object? instantiatesCanonical = freezed,
    Object? instantiatesUri = freezed,
    Object? instantiatesUriElement = freezed,
    Object? contentDerivative = freezed,
    Object? issued = freezed,
    Object? issuedElement = freezed,
    Object? applies = freezed,
    Object? expirationType = freezed,
    Object? subject = freezed,
    Object? authority = freezed,
    Object? domain = freezed,
    Object? site = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? title = freezed,
    Object? titleElement = freezed,
    Object? subtitle = freezed,
    Object? subtitleElement = freezed,
    Object? alias = freezed,
    Object? aliasElement = freezed,
    Object? author = freezed,
    Object? scope = freezed,
    Object? topicCodeableConcept = freezed,
    Object? topicReference = freezed,
    Object? type = freezed,
    Object? subType = freezed,
    Object? contentDefinition = freezed,
    Object? term = freezed,
    Object? supportingInfo = freezed,
    Object? relevantHistory = freezed,
    Object? signer = freezed,
    Object? friendly = freezed,
    Object? legal = freezed,
    Object? rule = freezed,
    Object? legallyBindingAttachment = freezed,
    Object? legallyBindingReference = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      urlElement: freezed == urlElement
          ? _value.urlElement
          : urlElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      versionElement: freezed == versionElement
          ? _value.versionElement
          : versionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      legalState: freezed == legalState
          ? _value.legalState
          : legalState // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      instantiatesCanonical: freezed == instantiatesCanonical
          ? _value.instantiatesCanonical
          : instantiatesCanonical // ignore: cast_nullable_to_non_nullable
              as Reference?,
      instantiatesUri: freezed == instantiatesUri
          ? _value.instantiatesUri
          : instantiatesUri // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      instantiatesUriElement: freezed == instantiatesUriElement
          ? _value.instantiatesUriElement
          : instantiatesUriElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      contentDerivative: freezed == contentDerivative
          ? _value.contentDerivative
          : contentDerivative // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      issued: freezed == issued
          ? _value.issued
          : issued // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      issuedElement: freezed == issuedElement
          ? _value.issuedElement
          : issuedElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      applies: freezed == applies
          ? _value.applies
          : applies // ignore: cast_nullable_to_non_nullable
              as Period?,
      expirationType: freezed == expirationType
          ? _value.expirationType
          : expirationType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      subject: freezed == subject
          ? _value.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      authority: freezed == authority
          ? _value.authority
          : authority // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      domain: freezed == domain
          ? _value.domain
          : domain // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      site: freezed == site
          ? _value.site
          : site // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      titleElement: freezed == titleElement
          ? _value.titleElement
          : titleElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      subtitle: freezed == subtitle
          ? _value.subtitle
          : subtitle // ignore: cast_nullable_to_non_nullable
              as String?,
      subtitleElement: freezed == subtitleElement
          ? _value.subtitleElement
          : subtitleElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      alias: freezed == alias
          ? _value.alias
          : alias // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      aliasElement: freezed == aliasElement
          ? _value.aliasElement
          : aliasElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      author: freezed == author
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as Reference?,
      scope: freezed == scope
          ? _value.scope
          : scope // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      topicCodeableConcept: freezed == topicCodeableConcept
          ? _value.topicCodeableConcept
          : topicCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      topicReference: freezed == topicReference
          ? _value.topicReference
          : topicReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      subType: freezed == subType
          ? _value.subType
          : subType // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      contentDefinition: freezed == contentDefinition
          ? _value.contentDefinition
          : contentDefinition // ignore: cast_nullable_to_non_nullable
              as ContractContentDefinition?,
      term: freezed == term
          ? _value.term
          : term // ignore: cast_nullable_to_non_nullable
              as List<ContractTerm>?,
      supportingInfo: freezed == supportingInfo
          ? _value.supportingInfo
          : supportingInfo // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      relevantHistory: freezed == relevantHistory
          ? _value.relevantHistory
          : relevantHistory // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      signer: freezed == signer
          ? _value.signer
          : signer // ignore: cast_nullable_to_non_nullable
              as List<ContractSigner>?,
      friendly: freezed == friendly
          ? _value.friendly
          : friendly // ignore: cast_nullable_to_non_nullable
              as List<ContractFriendly>?,
      legal: freezed == legal
          ? _value.legal
          : legal // ignore: cast_nullable_to_non_nullable
              as List<ContractLegal>?,
      rule: freezed == rule
          ? _value.rule
          : rule // ignore: cast_nullable_to_non_nullable
              as List<ContractRule>?,
      legallyBindingAttachment: freezed == legallyBindingAttachment
          ? _value.legallyBindingAttachment
          : legallyBindingAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      legallyBindingReference: freezed == legallyBindingReference
          ? _value.legallyBindingReference
          : legallyBindingReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FhirMetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $FhirMetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get urlElement {
    if (_value.urlElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.urlElement!, (value) {
      return _then(_value.copyWith(urlElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get versionElement {
    if (_value.versionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.versionElement!, (value) {
      return _then(_value.copyWith(versionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusElement {
    if (_value.statusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusElement!, (value) {
      return _then(_value.copyWith(statusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get legalState {
    if (_value.legalState == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.legalState!, (value) {
      return _then(_value.copyWith(legalState: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get instantiatesCanonical {
    if (_value.instantiatesCanonical == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.instantiatesCanonical!, (value) {
      return _then(_value.copyWith(instantiatesCanonical: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get instantiatesUriElement {
    if (_value.instantiatesUriElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.instantiatesUriElement!, (value) {
      return _then(_value.copyWith(instantiatesUriElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get contentDerivative {
    if (_value.contentDerivative == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.contentDerivative!, (value) {
      return _then(_value.copyWith(contentDerivative: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get issuedElement {
    if (_value.issuedElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.issuedElement!, (value) {
      return _then(_value.copyWith(issuedElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get applies {
    if (_value.applies == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.applies!, (value) {
      return _then(_value.copyWith(applies: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get expirationType {
    if (_value.expirationType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.expirationType!, (value) {
      return _then(_value.copyWith(expirationType: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get titleElement {
    if (_value.titleElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.titleElement!, (value) {
      return _then(_value.copyWith(titleElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get subtitleElement {
    if (_value.subtitleElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.subtitleElement!, (value) {
      return _then(_value.copyWith(subtitleElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get author {
    if (_value.author == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.author!, (value) {
      return _then(_value.copyWith(author: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get scope {
    if (_value.scope == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.scope!, (value) {
      return _then(_value.copyWith(scope: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get topicCodeableConcept {
    if (_value.topicCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.topicCodeableConcept!,
        (value) {
      return _then(_value.copyWith(topicCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get topicReference {
    if (_value.topicReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.topicReference!, (value) {
      return _then(_value.copyWith(topicReference: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ContractContentDefinitionCopyWith<$Res>? get contentDefinition {
    if (_value.contentDefinition == null) {
      return null;
    }

    return $ContractContentDefinitionCopyWith<$Res>(_value.contentDefinition!,
        (value) {
      return _then(_value.copyWith(contentDefinition: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get legallyBindingAttachment {
    if (_value.legallyBindingAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.legallyBindingAttachment!, (value) {
      return _then(_value.copyWith(legallyBindingAttachment: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get legallyBindingReference {
    if (_value.legallyBindingReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.legallyBindingReference!, (value) {
      return _then(_value.copyWith(legallyBindingReference: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractImplCopyWith<$Res>
    implements $ContractCopyWith<$Res> {
  factory _$$ContractImplCopyWith(
          _$ContractImpl value, $Res Function(_$ContractImpl) then) =
      __$$ContractImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.Contract)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      FhirUri? url,
      @JsonKey(name: '_url') Element? urlElement,
      String? version,
      @JsonKey(name: '_version') Element? versionElement,
      FhirCode? status,
      @JsonKey(name: '_status') Element? statusElement,
      CodeableConcept? legalState,
      Reference? instantiatesCanonical,
      FhirUri? instantiatesUri,
      @JsonKey(name: '_instantiatesUri') Element? instantiatesUriElement,
      CodeableConcept? contentDerivative,
      FhirDateTime? issued,
      @JsonKey(name: '_issued') Element? issuedElement,
      Period? applies,
      CodeableConcept? expirationType,
      List<Reference>? subject,
      List<Reference>? authority,
      List<Reference>? domain,
      List<Reference>? site,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      String? title,
      @JsonKey(name: '_title') Element? titleElement,
      String? subtitle,
      @JsonKey(name: '_subtitle') Element? subtitleElement,
      List<String>? alias,
      @JsonKey(name: '_alias') List<Element>? aliasElement,
      Reference? author,
      CodeableConcept? scope,
      CodeableConcept? topicCodeableConcept,
      Reference? topicReference,
      CodeableConcept? type,
      List<CodeableConcept>? subType,
      ContractContentDefinition? contentDefinition,
      List<ContractTerm>? term,
      List<Reference>? supportingInfo,
      List<Reference>? relevantHistory,
      List<ContractSigner>? signer,
      List<ContractFriendly>? friendly,
      List<ContractLegal>? legal,
      List<ContractRule>? rule,
      Attachment? legallyBindingAttachment,
      Reference? legallyBindingReference});

  @override
  $FhirMetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get urlElement;
  @override
  $ElementCopyWith<$Res>? get versionElement;
  @override
  $ElementCopyWith<$Res>? get statusElement;
  @override
  $CodeableConceptCopyWith<$Res>? get legalState;
  @override
  $ReferenceCopyWith<$Res>? get instantiatesCanonical;
  @override
  $ElementCopyWith<$Res>? get instantiatesUriElement;
  @override
  $CodeableConceptCopyWith<$Res>? get contentDerivative;
  @override
  $ElementCopyWith<$Res>? get issuedElement;
  @override
  $PeriodCopyWith<$Res>? get applies;
  @override
  $CodeableConceptCopyWith<$Res>? get expirationType;
  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $ElementCopyWith<$Res>? get titleElement;
  @override
  $ElementCopyWith<$Res>? get subtitleElement;
  @override
  $ReferenceCopyWith<$Res>? get author;
  @override
  $CodeableConceptCopyWith<$Res>? get scope;
  @override
  $CodeableConceptCopyWith<$Res>? get topicCodeableConcept;
  @override
  $ReferenceCopyWith<$Res>? get topicReference;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ContractContentDefinitionCopyWith<$Res>? get contentDefinition;
  @override
  $AttachmentCopyWith<$Res>? get legallyBindingAttachment;
  @override
  $ReferenceCopyWith<$Res>? get legallyBindingReference;
}

/// @nodoc
class __$$ContractImplCopyWithImpl<$Res>
    extends _$ContractCopyWithImpl<$Res, _$ContractImpl>
    implements _$$ContractImplCopyWith<$Res> {
  __$$ContractImplCopyWithImpl(
      _$ContractImpl _value, $Res Function(_$ContractImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? url = freezed,
    Object? urlElement = freezed,
    Object? version = freezed,
    Object? versionElement = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? legalState = freezed,
    Object? instantiatesCanonical = freezed,
    Object? instantiatesUri = freezed,
    Object? instantiatesUriElement = freezed,
    Object? contentDerivative = freezed,
    Object? issued = freezed,
    Object? issuedElement = freezed,
    Object? applies = freezed,
    Object? expirationType = freezed,
    Object? subject = freezed,
    Object? authority = freezed,
    Object? domain = freezed,
    Object? site = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? title = freezed,
    Object? titleElement = freezed,
    Object? subtitle = freezed,
    Object? subtitleElement = freezed,
    Object? alias = freezed,
    Object? aliasElement = freezed,
    Object? author = freezed,
    Object? scope = freezed,
    Object? topicCodeableConcept = freezed,
    Object? topicReference = freezed,
    Object? type = freezed,
    Object? subType = freezed,
    Object? contentDefinition = freezed,
    Object? term = freezed,
    Object? supportingInfo = freezed,
    Object? relevantHistory = freezed,
    Object? signer = freezed,
    Object? friendly = freezed,
    Object? legal = freezed,
    Object? rule = freezed,
    Object? legallyBindingAttachment = freezed,
    Object? legallyBindingReference = freezed,
  }) {
    return _then(_$ContractImpl(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      urlElement: freezed == urlElement
          ? _value.urlElement
          : urlElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      version: freezed == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as String?,
      versionElement: freezed == versionElement
          ? _value.versionElement
          : versionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      legalState: freezed == legalState
          ? _value.legalState
          : legalState // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      instantiatesCanonical: freezed == instantiatesCanonical
          ? _value.instantiatesCanonical
          : instantiatesCanonical // ignore: cast_nullable_to_non_nullable
              as Reference?,
      instantiatesUri: freezed == instantiatesUri
          ? _value.instantiatesUri
          : instantiatesUri // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      instantiatesUriElement: freezed == instantiatesUriElement
          ? _value.instantiatesUriElement
          : instantiatesUriElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      contentDerivative: freezed == contentDerivative
          ? _value.contentDerivative
          : contentDerivative // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      issued: freezed == issued
          ? _value.issued
          : issued // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      issuedElement: freezed == issuedElement
          ? _value.issuedElement
          : issuedElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      applies: freezed == applies
          ? _value.applies
          : applies // ignore: cast_nullable_to_non_nullable
              as Period?,
      expirationType: freezed == expirationType
          ? _value.expirationType
          : expirationType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      subject: freezed == subject
          ? _value._subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      authority: freezed == authority
          ? _value._authority
          : authority // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      domain: freezed == domain
          ? _value._domain
          : domain // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      site: freezed == site
          ? _value._site
          : site // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      titleElement: freezed == titleElement
          ? _value.titleElement
          : titleElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      subtitle: freezed == subtitle
          ? _value.subtitle
          : subtitle // ignore: cast_nullable_to_non_nullable
              as String?,
      subtitleElement: freezed == subtitleElement
          ? _value.subtitleElement
          : subtitleElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      alias: freezed == alias
          ? _value._alias
          : alias // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      aliasElement: freezed == aliasElement
          ? _value._aliasElement
          : aliasElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      author: freezed == author
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as Reference?,
      scope: freezed == scope
          ? _value.scope
          : scope // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      topicCodeableConcept: freezed == topicCodeableConcept
          ? _value.topicCodeableConcept
          : topicCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      topicReference: freezed == topicReference
          ? _value.topicReference
          : topicReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      subType: freezed == subType
          ? _value._subType
          : subType // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      contentDefinition: freezed == contentDefinition
          ? _value.contentDefinition
          : contentDefinition // ignore: cast_nullable_to_non_nullable
              as ContractContentDefinition?,
      term: freezed == term
          ? _value._term
          : term // ignore: cast_nullable_to_non_nullable
              as List<ContractTerm>?,
      supportingInfo: freezed == supportingInfo
          ? _value._supportingInfo
          : supportingInfo // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      relevantHistory: freezed == relevantHistory
          ? _value._relevantHistory
          : relevantHistory // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      signer: freezed == signer
          ? _value._signer
          : signer // ignore: cast_nullable_to_non_nullable
              as List<ContractSigner>?,
      friendly: freezed == friendly
          ? _value._friendly
          : friendly // ignore: cast_nullable_to_non_nullable
              as List<ContractFriendly>?,
      legal: freezed == legal
          ? _value._legal
          : legal // ignore: cast_nullable_to_non_nullable
              as List<ContractLegal>?,
      rule: freezed == rule
          ? _value._rule
          : rule // ignore: cast_nullable_to_non_nullable
              as List<ContractRule>?,
      legallyBindingAttachment: freezed == legallyBindingAttachment
          ? _value.legallyBindingAttachment
          : legallyBindingAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      legallyBindingReference: freezed == legallyBindingReference
          ? _value.legallyBindingReference
          : legallyBindingReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractImpl extends _Contract {
  const _$ContractImpl(
      {@JsonKey(unknownEnumValue: R6ResourceType.Contract)
      this.resourceType = R6ResourceType.Contract,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.url,
      @JsonKey(name: '_url') this.urlElement,
      this.version,
      @JsonKey(name: '_version') this.versionElement,
      this.status,
      @JsonKey(name: '_status') this.statusElement,
      this.legalState,
      this.instantiatesCanonical,
      this.instantiatesUri,
      @JsonKey(name: '_instantiatesUri') this.instantiatesUriElement,
      this.contentDerivative,
      this.issued,
      @JsonKey(name: '_issued') this.issuedElement,
      this.applies,
      this.expirationType,
      final List<Reference>? subject,
      final List<Reference>? authority,
      final List<Reference>? domain,
      final List<Reference>? site,
      this.name,
      @JsonKey(name: '_name') this.nameElement,
      this.title,
      @JsonKey(name: '_title') this.titleElement,
      this.subtitle,
      @JsonKey(name: '_subtitle') this.subtitleElement,
      final List<String>? alias,
      @JsonKey(name: '_alias') final List<Element>? aliasElement,
      this.author,
      this.scope,
      this.topicCodeableConcept,
      this.topicReference,
      this.type,
      final List<CodeableConcept>? subType,
      this.contentDefinition,
      final List<ContractTerm>? term,
      final List<Reference>? supportingInfo,
      final List<Reference>? relevantHistory,
      final List<ContractSigner>? signer,
      final List<ContractFriendly>? friendly,
      final List<ContractLegal>? legal,
      final List<ContractRule>? rule,
      this.legallyBindingAttachment,
      this.legallyBindingReference})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _subject = subject,
        _authority = authority,
        _domain = domain,
        _site = site,
        _alias = alias,
        _aliasElement = aliasElement,
        _subType = subType,
        _term = term,
        _supportingInfo = supportingInfo,
        _relevantHistory = relevantHistory,
        _signer = signer,
        _friendly = friendly,
        _legal = legal,
        _rule = rule,
        super._();

  factory _$ContractImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractImplFromJson(json);

  /// [resourceType] This is a Contract resource
  @override
  @JsonKey(unknownEnumValue: R6ResourceType.Contract)
  final R6ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  @override
  final FhirMeta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final FhirCode? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Unique identifier for this Contract or a derivative that
  ///  references a Source Contract.
  final List<Identifier>? _identifier;

  /// [identifier] Unique identifier for this Contract or a derivative that
  ///  references a Source Contract.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [url] Canonical identifier for this contract, represented as a URI
  ///  (globally unique).
  @override
  final FhirUri? url;

  /// [urlElement] ("_url") Extensions for url
  @override
  @JsonKey(name: '_url')
  final Element? urlElement;

  /// [version] An edition identifier used for business purposes to label
  ///  business significant variants.
  @override
  final String? version;

  /// [versionElement] ("_version") Extensions for version
  @override
  @JsonKey(name: '_version')
  final Element? versionElement;

  /// [status] The status of the resource instance.
  @override
  final FhirCode? status;

  /// [statusElement] ("_status") Extensions for status
  @override
  @JsonKey(name: '_status')
  final Element? statusElement;

  /// [legalState] Legal states of the formation of a legal instrument, which
  ///  is a formally executed written document that can be formally
  ///  attributed to its author, records and formally expresses a legally
  ///  enforceable act, process, or contractual duty, obligation, or right,
  ///  and therefore evidences that act, process, or agreement.
  @override
  final CodeableConcept? legalState;

  /// [instantiatesCanonical] The URL pointing to a FHIR-defined Contract
  ///  Definition that is adhered to in whole or part by this Contract.
  @override
  final Reference? instantiatesCanonical;

  /// [instantiatesUri] The URL pointing to an externally maintained
  ///  definition that is adhered to in whole or in part by this Contract.
  @override
  final FhirUri? instantiatesUri;

  /// [instantiatesUriElement] ("_instantiatesUri") Extensions for
  ///  instantiatesUri
  @override
  @JsonKey(name: '_instantiatesUri')
  final Element? instantiatesUriElement;

  /// [contentDerivative] The minimal content derived from the basal
  ///  information source at a specific stage in its lifecycle.
  @override
  final CodeableConcept? contentDerivative;

  /// [issued] When this  Contract was issued.
  @override
  final FhirDateTime? issued;

  /// [issuedElement] ("_issued") Extensions for issued
  @override
  @JsonKey(name: '_issued')
  final Element? issuedElement;

  /// [applies] Relevant time or time-period when this Contract is applicable.
  @override
  final Period? applies;

  /// [expirationType] Event resulting in discontinuation or termination of
  ///  this Contract instance by one or more parties to the contract.
  @override
  final CodeableConcept? expirationType;

  /// [subject] The target entity impacted by or of interest to parties to
  ///  the agreement.
  final List<Reference>? _subject;

  /// [subject] The target entity impacted by or of interest to parties to
  ///  the agreement.
  @override
  List<Reference>? get subject {
    final value = _subject;
    if (value == null) return null;
    if (_subject is EqualUnmodifiableListView) return _subject;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [authority] A formally or informally recognized grouping of people,
  ///  principals, organizations, or jurisdictions formed for the purpose of
  ///  achieving some form of collective action such as the promulgation,
  ///  administration and enforcement of contracts and policies.
  final List<Reference>? _authority;

  /// [authority] A formally or informally recognized grouping of people,
  ///  principals, organizations, or jurisdictions formed for the purpose of
  ///  achieving some form of collective action such as the promulgation,
  ///  administration and enforcement of contracts and policies.
  @override
  List<Reference>? get authority {
    final value = _authority;
    if (value == null) return null;
    if (_authority is EqualUnmodifiableListView) return _authority;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [domain] Recognized governance framework or system operating with a
  ///  circumscribed scope in accordance with specified principles, policies,
  ///  processes or procedures for managing rights, actions, or behaviors of
  ///  parties or principals relative to resources.
  final List<Reference>? _domain;

  /// [domain] Recognized governance framework or system operating with a
  ///  circumscribed scope in accordance with specified principles, policies,
  ///  processes or procedures for managing rights, actions, or behaviors of
  ///  parties or principals relative to resources.
  @override
  List<Reference>? get domain {
    final value = _domain;
    if (value == null) return null;
    if (_domain is EqualUnmodifiableListView) return _domain;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [site] Sites in which the contract is complied with,  exercised, or in
  ///  force.
  final List<Reference>? _site;

  /// [site] Sites in which the contract is complied with,  exercised, or in
  ///  force.
  @override
  List<Reference>? get site {
    final value = _site;
    if (value == null) return null;
    if (_site is EqualUnmodifiableListView) return _site;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [name] A natural language name identifying this Contract definition,
  ///  derivative, or instance in any legal state. Provides additional
  ///  information about its content. This name should be usable as an
  ///  identifier for the module by machine processing applications such as
  ///  code generation.
  @override
  final String? name;

  /// [nameElement] ("_name") Extensions for name
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [title] A short, descriptive, user-friendly title for this Contract
  ///  definition, derivative, or instance in any legal state.
  @override
  final String? title;

  /// [titleElement] ("_title") Extensions for title
  @override
  @JsonKey(name: '_title')
  final Element? titleElement;

  /// [subtitle] A more detailed or qualifying explanatory or alternate
  ///  user-friendly title for this Contract definition, derivative, or
  ///  instance in any legal state.
  @override
  final String? subtitle;

  /// [subtitleElement] ("_subtitle") Extensions for subtitle
  @override
  @JsonKey(name: '_subtitle')
  final Element? subtitleElement;

  /// [alias] Alternative representation of the title for this Contract
  ///  definition, derivative, or instance in any legal state., e.g., a
  ///  domain specific contract number related to legislation.
  final List<String>? _alias;

  /// [alias] Alternative representation of the title for this Contract
  ///  definition, derivative, or instance in any legal state., e.g., a
  ///  domain specific contract number related to legislation.
  @override
  List<String>? get alias {
    final value = _alias;
    if (value == null) return null;
    if (_alias is EqualUnmodifiableListView) return _alias;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [aliasElement] ("_alias") Extensions for alias
  final List<Element>? _aliasElement;

  /// [aliasElement] ("_alias") Extensions for alias
  @override
  @JsonKey(name: '_alias')
  List<Element>? get aliasElement {
    final value = _aliasElement;
    if (value == null) return null;
    if (_aliasElement is EqualUnmodifiableListView) return _aliasElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [author] The individual or organization that authored the Contract
  ///  definition, derivative, or instance in any legal state.
  @override
  final Reference? author;

  /// [scope] A selector of legal concerns for this Contract definition,
  ///  derivative, or instance in any legal state.
  @override
  final CodeableConcept? scope;

  /// [topicCodeableConcept] Narrows the range of legal concerns to focus on
  ///  the achievement of specific contractual objectives.
  @override
  final CodeableConcept? topicCodeableConcept;

  /// [topicReference] Narrows the range of legal concerns to focus on the
  ///  achievement of specific contractual objectives.
  @override
  final Reference? topicReference;

  /// [type] A high-level category for the legal instrument, whether
  ///  constructed as a Contract definition, derivative, or instance in any
  ///  legal state.  Provides additional information about its content within
  ///  the context of the Contract's scope to distinguish the kinds of
  ///  systems that would be interested in the contract.
  @override
  final CodeableConcept? type;

  /// [subType] Sub-category for the Contract that distinguishes the kinds of
  ///  systems that would be interested in the Contract within the context of
  ///  the Contract's scope.
  final List<CodeableConcept>? _subType;

  /// [subType] Sub-category for the Contract that distinguishes the kinds of
  ///  systems that would be interested in the Contract within the context of
  ///  the Contract's scope.
  @override
  List<CodeableConcept>? get subType {
    final value = _subType;
    if (value == null) return null;
    if (_subType is EqualUnmodifiableListView) return _subType;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [contentDefinition] Precusory content developed with a focus and intent
  ///  of supporting the formation a Contract instance, which may be
  ///  associated with and transformable into a Contract.
  @override
  final ContractContentDefinition? contentDefinition;

  /// [term] One or more Contract Provisions, which may be related and
  ///  conveyed as a group, and may contain nested groups.
  final List<ContractTerm>? _term;

  /// [term] One or more Contract Provisions, which may be related and
  ///  conveyed as a group, and may contain nested groups.
  @override
  List<ContractTerm>? get term {
    final value = _term;
    if (value == null) return null;
    if (_term is EqualUnmodifiableListView) return _term;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [supportingInfo] Information that may be needed by/relevant to the
  ///  performer in their execution of this term action.
  final List<Reference>? _supportingInfo;

  /// [supportingInfo] Information that may be needed by/relevant to the
  ///  performer in their execution of this term action.
  @override
  List<Reference>? get supportingInfo {
    final value = _supportingInfo;
    if (value == null) return null;
    if (_supportingInfo is EqualUnmodifiableListView) return _supportingInfo;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [relevantHistory] Links to Provenance records for past versions of this
  ///  Contract definition, derivative, or instance, which identify key state
  ///  transitions or updates that are likely to be relevant to a user
  ///  looking at the current version of the Contract.  The Provenance.entity
  ///  indicates the target that was changed in the update (see
  ///  [Provenance.entity](provenance-definitions.html#Provenance.entity)).
  final List<Reference>? _relevantHistory;

  /// [relevantHistory] Links to Provenance records for past versions of this
  ///  Contract definition, derivative, or instance, which identify key state
  ///  transitions or updates that are likely to be relevant to a user
  ///  looking at the current version of the Contract.  The Provenance.entity
  ///  indicates the target that was changed in the update (see
  ///  [Provenance.entity](provenance-definitions.html#Provenance.entity)).
  @override
  List<Reference>? get relevantHistory {
    final value = _relevantHistory;
    if (value == null) return null;
    if (_relevantHistory is EqualUnmodifiableListView) return _relevantHistory;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [signer] Parties with legal standing in the Contract, including the
  ///  principal parties, the grantor(s) and grantee(s), which are any person
  ///  or organization bound by the contract, and any ancillary parties,
  ///  which facilitate the execution of the contract such as a notary or
  ///  witness.
  final List<ContractSigner>? _signer;

  /// [signer] Parties with legal standing in the Contract, including the
  ///  principal parties, the grantor(s) and grantee(s), which are any person
  ///  or organization bound by the contract, and any ancillary parties,
  ///  which facilitate the execution of the contract such as a notary or
  ///  witness.
  @override
  List<ContractSigner>? get signer {
    final value = _signer;
    if (value == null) return null;
    if (_signer is EqualUnmodifiableListView) return _signer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [friendly] The "patient friendly language" versionof the Contract in
  ///  whole or in parts. "Patient friendly language" means the
  ///  representation of the Contract and Contract Provisions in a manner
  ///  that is readily accessible and understandable by a layperson in
  ///  accordance with best practices for communication styles that ensure
  ///  that those agreeing to or signing the Contract understand the roles,
  ///  actions, obligations, responsibilities, and implication of the
  ///  agreement.
  final List<ContractFriendly>? _friendly;

  /// [friendly] The "patient friendly language" versionof the Contract in
  ///  whole or in parts. "Patient friendly language" means the
  ///  representation of the Contract and Contract Provisions in a manner
  ///  that is readily accessible and understandable by a layperson in
  ///  accordance with best practices for communication styles that ensure
  ///  that those agreeing to or signing the Contract understand the roles,
  ///  actions, obligations, responsibilities, and implication of the
  ///  agreement.
  @override
  List<ContractFriendly>? get friendly {
    final value = _friendly;
    if (value == null) return null;
    if (_friendly is EqualUnmodifiableListView) return _friendly;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [legal] List of Legal expressions or representations of this Contract.
  final List<ContractLegal>? _legal;

  /// [legal] List of Legal expressions or representations of this Contract.
  @override
  List<ContractLegal>? get legal {
    final value = _legal;
    if (value == null) return null;
    if (_legal is EqualUnmodifiableListView) return _legal;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [rule] List of Computable Policy Rule Language Representations of this
  ///  Contract.
  final List<ContractRule>? _rule;

  /// [rule] List of Computable Policy Rule Language Representations of this
  ///  Contract.
  @override
  List<ContractRule>? get rule {
    final value = _rule;
    if (value == null) return null;
    if (_rule is EqualUnmodifiableListView) return _rule;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [legallyBindingAttachment] Legally binding Contract: This is the signed
  ///  and legally recognized representation of the Contract, which is
  ///  considered the "source of truth" and which would be the basis for
  ///  legal action related to enforcement of this Contract.
  @override
  final Attachment? legallyBindingAttachment;

  /// [legallyBindingReference] Legally binding Contract: This is the signed
  ///  and legally recognized representation of the Contract, which is
  ///  considered the "source of truth" and which would be the basis for
  ///  legal action related to enforcement of this Contract.
  @override
  final Reference? legallyBindingReference;

  @override
  String toString() {
    return 'Contract(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, url: $url, urlElement: $urlElement, version: $version, versionElement: $versionElement, status: $status, statusElement: $statusElement, legalState: $legalState, instantiatesCanonical: $instantiatesCanonical, instantiatesUri: $instantiatesUri, instantiatesUriElement: $instantiatesUriElement, contentDerivative: $contentDerivative, issued: $issued, issuedElement: $issuedElement, applies: $applies, expirationType: $expirationType, subject: $subject, authority: $authority, domain: $domain, site: $site, name: $name, nameElement: $nameElement, title: $title, titleElement: $titleElement, subtitle: $subtitle, subtitleElement: $subtitleElement, alias: $alias, aliasElement: $aliasElement, author: $author, scope: $scope, topicCodeableConcept: $topicCodeableConcept, topicReference: $topicReference, type: $type, subType: $subType, contentDefinition: $contentDefinition, term: $term, supportingInfo: $supportingInfo, relevantHistory: $relevantHistory, signer: $signer, friendly: $friendly, legal: $legal, rule: $rule, legallyBindingAttachment: $legallyBindingAttachment, legallyBindingReference: $legallyBindingReference)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractImpl &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.urlElement, urlElement) ||
                other.urlElement == urlElement) &&
            (identical(other.version, version) || other.version == version) &&
            (identical(other.versionElement, versionElement) ||
                other.versionElement == versionElement) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusElement, statusElement) ||
                other.statusElement == statusElement) &&
            (identical(other.legalState, legalState) ||
                other.legalState == legalState) &&
            (identical(other.instantiatesCanonical, instantiatesCanonical) ||
                other.instantiatesCanonical == instantiatesCanonical) &&
            (identical(other.instantiatesUri, instantiatesUri) ||
                other.instantiatesUri == instantiatesUri) &&
            (identical(other.instantiatesUriElement, instantiatesUriElement) ||
                other.instantiatesUriElement == instantiatesUriElement) &&
            (identical(other.contentDerivative, contentDerivative) ||
                other.contentDerivative == contentDerivative) &&
            (identical(other.issued, issued) || other.issued == issued) &&
            (identical(other.issuedElement, issuedElement) ||
                other.issuedElement == issuedElement) &&
            (identical(other.applies, applies) || other.applies == applies) &&
            (identical(other.expirationType, expirationType) ||
                other.expirationType == expirationType) &&
            const DeepCollectionEquality().equals(other._subject, _subject) &&
            const DeepCollectionEquality()
                .equals(other._authority, _authority) &&
            const DeepCollectionEquality().equals(other._domain, _domain) &&
            const DeepCollectionEquality().equals(other._site, _site) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.titleElement, titleElement) ||
                other.titleElement == titleElement) &&
            (identical(other.subtitle, subtitle) ||
                other.subtitle == subtitle) &&
            (identical(other.subtitleElement, subtitleElement) ||
                other.subtitleElement == subtitleElement) &&
            const DeepCollectionEquality().equals(other._alias, _alias) &&
            const DeepCollectionEquality()
                .equals(other._aliasElement, _aliasElement) &&
            (identical(other.author, author) || other.author == author) &&
            (identical(other.scope, scope) || other.scope == scope) &&
            (identical(other.topicCodeableConcept, topicCodeableConcept) ||
                other.topicCodeableConcept == topicCodeableConcept) &&
            (identical(other.topicReference, topicReference) ||
                other.topicReference == topicReference) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality().equals(other._subType, _subType) &&
            (identical(other.contentDefinition, contentDefinition) ||
                other.contentDefinition == contentDefinition) &&
            const DeepCollectionEquality().equals(other._term, _term) &&
            const DeepCollectionEquality()
                .equals(other._supportingInfo, _supportingInfo) &&
            const DeepCollectionEquality()
                .equals(other._relevantHistory, _relevantHistory) &&
            const DeepCollectionEquality().equals(other._signer, _signer) &&
            const DeepCollectionEquality().equals(other._friendly, _friendly) &&
            const DeepCollectionEquality().equals(other._legal, _legal) &&
            const DeepCollectionEquality().equals(other._rule, _rule) &&
            (identical(
                    other.legallyBindingAttachment, legallyBindingAttachment) ||
                other.legallyBindingAttachment == legallyBindingAttachment) &&
            (identical(
                    other.legallyBindingReference, legallyBindingReference) ||
                other.legallyBindingReference == legallyBindingReference));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        url,
        urlElement,
        version,
        versionElement,
        status,
        statusElement,
        legalState,
        instantiatesCanonical,
        instantiatesUri,
        instantiatesUriElement,
        contentDerivative,
        issued,
        issuedElement,
        applies,
        expirationType,
        const DeepCollectionEquality().hash(_subject),
        const DeepCollectionEquality().hash(_authority),
        const DeepCollectionEquality().hash(_domain),
        const DeepCollectionEquality().hash(_site),
        name,
        nameElement,
        title,
        titleElement,
        subtitle,
        subtitleElement,
        const DeepCollectionEquality().hash(_alias),
        const DeepCollectionEquality().hash(_aliasElement),
        author,
        scope,
        topicCodeableConcept,
        topicReference,
        type,
        const DeepCollectionEquality().hash(_subType),
        contentDefinition,
        const DeepCollectionEquality().hash(_term),
        const DeepCollectionEquality().hash(_supportingInfo),
        const DeepCollectionEquality().hash(_relevantHistory),
        const DeepCollectionEquality().hash(_signer),
        const DeepCollectionEquality().hash(_friendly),
        const DeepCollectionEquality().hash(_legal),
        const DeepCollectionEquality().hash(_rule),
        legallyBindingAttachment,
        legallyBindingReference
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractImplCopyWith<_$ContractImpl> get copyWith =>
      __$$ContractImplCopyWithImpl<_$ContractImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractImplToJson(
      this,
    );
  }
}

abstract class _Contract extends Contract {
  const factory _Contract(
      {@JsonKey(unknownEnumValue: R6ResourceType.Contract)
      final R6ResourceType resourceType,
      final FhirId? id,
      final FhirMeta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
      final FhirCode? language,
      @JsonKey(name: '_language') final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final FhirUri? url,
      @JsonKey(name: '_url') final Element? urlElement,
      final String? version,
      @JsonKey(name: '_version') final Element? versionElement,
      final FhirCode? status,
      @JsonKey(name: '_status') final Element? statusElement,
      final CodeableConcept? legalState,
      final Reference? instantiatesCanonical,
      final FhirUri? instantiatesUri,
      @JsonKey(name: '_instantiatesUri') final Element? instantiatesUriElement,
      final CodeableConcept? contentDerivative,
      final FhirDateTime? issued,
      @JsonKey(name: '_issued') final Element? issuedElement,
      final Period? applies,
      final CodeableConcept? expirationType,
      final List<Reference>? subject,
      final List<Reference>? authority,
      final List<Reference>? domain,
      final List<Reference>? site,
      final String? name,
      @JsonKey(name: '_name') final Element? nameElement,
      final String? title,
      @JsonKey(name: '_title') final Element? titleElement,
      final String? subtitle,
      @JsonKey(name: '_subtitle') final Element? subtitleElement,
      final List<String>? alias,
      @JsonKey(name: '_alias') final List<Element>? aliasElement,
      final Reference? author,
      final CodeableConcept? scope,
      final CodeableConcept? topicCodeableConcept,
      final Reference? topicReference,
      final CodeableConcept? type,
      final List<CodeableConcept>? subType,
      final ContractContentDefinition? contentDefinition,
      final List<ContractTerm>? term,
      final List<Reference>? supportingInfo,
      final List<Reference>? relevantHistory,
      final List<ContractSigner>? signer,
      final List<ContractFriendly>? friendly,
      final List<ContractLegal>? legal,
      final List<ContractRule>? rule,
      final Attachment? legallyBindingAttachment,
      final Reference? legallyBindingReference}) = _$ContractImpl;
  const _Contract._() : super._();

  factory _Contract.fromJson(Map<String, dynamic> json) =
      _$ContractImpl.fromJson;

  @override

  /// [resourceType] This is a Contract resource
  @JsonKey(unknownEnumValue: R6ResourceType.Contract)
  R6ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  FhirMeta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  FhirCode? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Unique identifier for this Contract or a derivative that
  ///  references a Source Contract.
  List<Identifier>? get identifier;
  @override

  /// [url] Canonical identifier for this contract, represented as a URI
  ///  (globally unique).
  FhirUri? get url;
  @override

  /// [urlElement] ("_url") Extensions for url
  @JsonKey(name: '_url')
  Element? get urlElement;
  @override

  /// [version] An edition identifier used for business purposes to label
  ///  business significant variants.
  String? get version;
  @override

  /// [versionElement] ("_version") Extensions for version
  @JsonKey(name: '_version')
  Element? get versionElement;
  @override

  /// [status] The status of the resource instance.
  FhirCode? get status;
  @override

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement;
  @override

  /// [legalState] Legal states of the formation of a legal instrument, which
  ///  is a formally executed written document that can be formally
  ///  attributed to its author, records and formally expresses a legally
  ///  enforceable act, process, or contractual duty, obligation, or right,
  ///  and therefore evidences that act, process, or agreement.
  CodeableConcept? get legalState;
  @override

  /// [instantiatesCanonical] The URL pointing to a FHIR-defined Contract
  ///  Definition that is adhered to in whole or part by this Contract.
  Reference? get instantiatesCanonical;
  @override

  /// [instantiatesUri] The URL pointing to an externally maintained
  ///  definition that is adhered to in whole or in part by this Contract.
  FhirUri? get instantiatesUri;
  @override

  /// [instantiatesUriElement] ("_instantiatesUri") Extensions for
  ///  instantiatesUri
  @JsonKey(name: '_instantiatesUri')
  Element? get instantiatesUriElement;
  @override

  /// [contentDerivative] The minimal content derived from the basal
  ///  information source at a specific stage in its lifecycle.
  CodeableConcept? get contentDerivative;
  @override

  /// [issued] When this  Contract was issued.
  FhirDateTime? get issued;
  @override

  /// [issuedElement] ("_issued") Extensions for issued
  @JsonKey(name: '_issued')
  Element? get issuedElement;
  @override

  /// [applies] Relevant time or time-period when this Contract is applicable.
  Period? get applies;
  @override

  /// [expirationType] Event resulting in discontinuation or termination of
  ///  this Contract instance by one or more parties to the contract.
  CodeableConcept? get expirationType;
  @override

  /// [subject] The target entity impacted by or of interest to parties to
  ///  the agreement.
  List<Reference>? get subject;
  @override

  /// [authority] A formally or informally recognized grouping of people,
  ///  principals, organizations, or jurisdictions formed for the purpose of
  ///  achieving some form of collective action such as the promulgation,
  ///  administration and enforcement of contracts and policies.
  List<Reference>? get authority;
  @override

  /// [domain] Recognized governance framework or system operating with a
  ///  circumscribed scope in accordance with specified principles, policies,
  ///  processes or procedures for managing rights, actions, or behaviors of
  ///  parties or principals relative to resources.
  List<Reference>? get domain;
  @override

  /// [site] Sites in which the contract is complied with,  exercised, or in
  ///  force.
  List<Reference>? get site;
  @override

  /// [name] A natural language name identifying this Contract definition,
  ///  derivative, or instance in any legal state. Provides additional
  ///  information about its content. This name should be usable as an
  ///  identifier for the module by machine processing applications such as
  ///  code generation.
  String? get name;
  @override

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [title] A short, descriptive, user-friendly title for this Contract
  ///  definition, derivative, or instance in any legal state.
  String? get title;
  @override

  /// [titleElement] ("_title") Extensions for title
  @JsonKey(name: '_title')
  Element? get titleElement;
  @override

  /// [subtitle] A more detailed or qualifying explanatory or alternate
  ///  user-friendly title for this Contract definition, derivative, or
  ///  instance in any legal state.
  String? get subtitle;
  @override

  /// [subtitleElement] ("_subtitle") Extensions for subtitle
  @JsonKey(name: '_subtitle')
  Element? get subtitleElement;
  @override

  /// [alias] Alternative representation of the title for this Contract
  ///  definition, derivative, or instance in any legal state., e.g., a
  ///  domain specific contract number related to legislation.
  List<String>? get alias;
  @override

  /// [aliasElement] ("_alias") Extensions for alias
  @JsonKey(name: '_alias')
  List<Element>? get aliasElement;
  @override

  /// [author] The individual or organization that authored the Contract
  ///  definition, derivative, or instance in any legal state.
  Reference? get author;
  @override

  /// [scope] A selector of legal concerns for this Contract definition,
  ///  derivative, or instance in any legal state.
  CodeableConcept? get scope;
  @override

  /// [topicCodeableConcept] Narrows the range of legal concerns to focus on
  ///  the achievement of specific contractual objectives.
  CodeableConcept? get topicCodeableConcept;
  @override

  /// [topicReference] Narrows the range of legal concerns to focus on the
  ///  achievement of specific contractual objectives.
  Reference? get topicReference;
  @override

  /// [type] A high-level category for the legal instrument, whether
  ///  constructed as a Contract definition, derivative, or instance in any
  ///  legal state.  Provides additional information about its content within
  ///  the context of the Contract's scope to distinguish the kinds of
  ///  systems that would be interested in the contract.
  CodeableConcept? get type;
  @override

  /// [subType] Sub-category for the Contract that distinguishes the kinds of
  ///  systems that would be interested in the Contract within the context of
  ///  the Contract's scope.
  List<CodeableConcept>? get subType;
  @override

  /// [contentDefinition] Precusory content developed with a focus and intent
  ///  of supporting the formation a Contract instance, which may be
  ///  associated with and transformable into a Contract.
  ContractContentDefinition? get contentDefinition;
  @override

  /// [term] One or more Contract Provisions, which may be related and
  ///  conveyed as a group, and may contain nested groups.
  List<ContractTerm>? get term;
  @override

  /// [supportingInfo] Information that may be needed by/relevant to the
  ///  performer in their execution of this term action.
  List<Reference>? get supportingInfo;
  @override

  /// [relevantHistory] Links to Provenance records for past versions of this
  ///  Contract definition, derivative, or instance, which identify key state
  ///  transitions or updates that are likely to be relevant to a user
  ///  looking at the current version of the Contract.  The Provenance.entity
  ///  indicates the target that was changed in the update (see
  ///  [Provenance.entity](provenance-definitions.html#Provenance.entity)).
  List<Reference>? get relevantHistory;
  @override

  /// [signer] Parties with legal standing in the Contract, including the
  ///  principal parties, the grantor(s) and grantee(s), which are any person
  ///  or organization bound by the contract, and any ancillary parties,
  ///  which facilitate the execution of the contract such as a notary or
  ///  witness.
  List<ContractSigner>? get signer;
  @override

  /// [friendly] The "patient friendly language" versionof the Contract in
  ///  whole or in parts. "Patient friendly language" means the
  ///  representation of the Contract and Contract Provisions in a manner
  ///  that is readily accessible and understandable by a layperson in
  ///  accordance with best practices for communication styles that ensure
  ///  that those agreeing to or signing the Contract understand the roles,
  ///  actions, obligations, responsibilities, and implication of the
  ///  agreement.
  List<ContractFriendly>? get friendly;
  @override

  /// [legal] List of Legal expressions or representations of this Contract.
  List<ContractLegal>? get legal;
  @override

  /// [rule] List of Computable Policy Rule Language Representations of this
  ///  Contract.
  List<ContractRule>? get rule;
  @override

  /// [legallyBindingAttachment] Legally binding Contract: This is the signed
  ///  and legally recognized representation of the Contract, which is
  ///  considered the "source of truth" and which would be the basis for
  ///  legal action related to enforcement of this Contract.
  Attachment? get legallyBindingAttachment;
  @override

  /// [legallyBindingReference] Legally binding Contract: This is the signed
  ///  and legally recognized representation of the Contract, which is
  ///  considered the "source of truth" and which would be the basis for
  ///  legal action related to enforcement of this Contract.
  Reference? get legallyBindingReference;
  @override
  @JsonKey(ignore: true)
  _$$ContractImplCopyWith<_$ContractImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractContentDefinition _$ContractContentDefinitionFromJson(
    Map<String, dynamic> json) {
  return _ContractContentDefinition.fromJson(json);
}

/// @nodoc
mixin _$ContractContentDefinition {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Precusory content structure and use, i.e., a boilerplate,
  ///  template, application for a contract such as an insurance policy or
  ///  benefits under a program, e.g., workers compensation.
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [subType] Detailed Precusory content type.
  CodeableConcept? get subType => throw _privateConstructorUsedError;

  /// [publisher] The  individual or organization that published the Contract
  ///  precursor content.
  Reference? get publisher => throw _privateConstructorUsedError;

  /// [publicationDate] The date (and optionally time) when the contract was
  ///  last significantly changed. The date must change when the business
  ///  version changes and it must change if the status code changes. In
  ///  addition, it should change when the substantive content of the
  ///  contract changes.
  FhirDateTime? get publicationDate => throw _privateConstructorUsedError;

  /// [publicationDateElement] ("_publicationDate") Extensions for
  ///  publicationDate
  @JsonKey(name: '_publicationDate')
  Element? get publicationDateElement => throw _privateConstructorUsedError;

  /// [publicationStatus] amended | appended | cancelled | disputed |
  ///  entered-in-error | executable +.
  FhirCode? get publicationStatus => throw _privateConstructorUsedError;

  /// [publicationStatusElement] ("_publicationStatus") Extensions for
  ///  publicationStatus
  @JsonKey(name: '_publicationStatus')
  Element? get publicationStatusElement => throw _privateConstructorUsedError;

  /// [copyright] A copyright statement relating to Contract precursor
  ///  content. Copyright statements are generally legal restrictions on the
  ///  use and publishing of the Contract precursor content.
  FhirMarkdown? get copyright => throw _privateConstructorUsedError;

  /// [copyrightElement] ("_copyright") Extensions for copyright
  @JsonKey(name: '_copyright')
  Element? get copyrightElement => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractContentDefinitionCopyWith<ContractContentDefinition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractContentDefinitionCopyWith<$Res> {
  factory $ContractContentDefinitionCopyWith(ContractContentDefinition value,
          $Res Function(ContractContentDefinition) then) =
      _$ContractContentDefinitionCopyWithImpl<$Res, ContractContentDefinition>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? subType,
      Reference? publisher,
      FhirDateTime? publicationDate,
      @JsonKey(name: '_publicationDate') Element? publicationDateElement,
      FhirCode? publicationStatus,
      @JsonKey(name: '_publicationStatus') Element? publicationStatusElement,
      FhirMarkdown? copyright,
      @JsonKey(name: '_copyright') Element? copyrightElement});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get subType;
  $ReferenceCopyWith<$Res>? get publisher;
  $ElementCopyWith<$Res>? get publicationDateElement;
  $ElementCopyWith<$Res>? get publicationStatusElement;
  $ElementCopyWith<$Res>? get copyrightElement;
}

/// @nodoc
class _$ContractContentDefinitionCopyWithImpl<$Res,
        $Val extends ContractContentDefinition>
    implements $ContractContentDefinitionCopyWith<$Res> {
  _$ContractContentDefinitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? subType = freezed,
    Object? publisher = freezed,
    Object? publicationDate = freezed,
    Object? publicationDateElement = freezed,
    Object? publicationStatus = freezed,
    Object? publicationStatusElement = freezed,
    Object? copyright = freezed,
    Object? copyrightElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      subType: freezed == subType
          ? _value.subType
          : subType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      publisher: freezed == publisher
          ? _value.publisher
          : publisher // ignore: cast_nullable_to_non_nullable
              as Reference?,
      publicationDate: freezed == publicationDate
          ? _value.publicationDate
          : publicationDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      publicationDateElement: freezed == publicationDateElement
          ? _value.publicationDateElement
          : publicationDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      publicationStatus: freezed == publicationStatus
          ? _value.publicationStatus
          : publicationStatus // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      publicationStatusElement: freezed == publicationStatusElement
          ? _value.publicationStatusElement
          : publicationStatusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      copyright: freezed == copyright
          ? _value.copyright
          : copyright // ignore: cast_nullable_to_non_nullable
              as FhirMarkdown?,
      copyrightElement: freezed == copyrightElement
          ? _value.copyrightElement
          : copyrightElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get subType {
    if (_value.subType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.subType!, (value) {
      return _then(_value.copyWith(subType: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get publisher {
    if (_value.publisher == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.publisher!, (value) {
      return _then(_value.copyWith(publisher: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get publicationDateElement {
    if (_value.publicationDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.publicationDateElement!, (value) {
      return _then(_value.copyWith(publicationDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get publicationStatusElement {
    if (_value.publicationStatusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.publicationStatusElement!, (value) {
      return _then(_value.copyWith(publicationStatusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get copyrightElement {
    if (_value.copyrightElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.copyrightElement!, (value) {
      return _then(_value.copyWith(copyrightElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractContentDefinitionImplCopyWith<$Res>
    implements $ContractContentDefinitionCopyWith<$Res> {
  factory _$$ContractContentDefinitionImplCopyWith(
          _$ContractContentDefinitionImpl value,
          $Res Function(_$ContractContentDefinitionImpl) then) =
      __$$ContractContentDefinitionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? subType,
      Reference? publisher,
      FhirDateTime? publicationDate,
      @JsonKey(name: '_publicationDate') Element? publicationDateElement,
      FhirCode? publicationStatus,
      @JsonKey(name: '_publicationStatus') Element? publicationStatusElement,
      FhirMarkdown? copyright,
      @JsonKey(name: '_copyright') Element? copyrightElement});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get subType;
  @override
  $ReferenceCopyWith<$Res>? get publisher;
  @override
  $ElementCopyWith<$Res>? get publicationDateElement;
  @override
  $ElementCopyWith<$Res>? get publicationStatusElement;
  @override
  $ElementCopyWith<$Res>? get copyrightElement;
}

/// @nodoc
class __$$ContractContentDefinitionImplCopyWithImpl<$Res>
    extends _$ContractContentDefinitionCopyWithImpl<$Res,
        _$ContractContentDefinitionImpl>
    implements _$$ContractContentDefinitionImplCopyWith<$Res> {
  __$$ContractContentDefinitionImplCopyWithImpl(
      _$ContractContentDefinitionImpl _value,
      $Res Function(_$ContractContentDefinitionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? subType = freezed,
    Object? publisher = freezed,
    Object? publicationDate = freezed,
    Object? publicationDateElement = freezed,
    Object? publicationStatus = freezed,
    Object? publicationStatusElement = freezed,
    Object? copyright = freezed,
    Object? copyrightElement = freezed,
  }) {
    return _then(_$ContractContentDefinitionImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      subType: freezed == subType
          ? _value.subType
          : subType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      publisher: freezed == publisher
          ? _value.publisher
          : publisher // ignore: cast_nullable_to_non_nullable
              as Reference?,
      publicationDate: freezed == publicationDate
          ? _value.publicationDate
          : publicationDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      publicationDateElement: freezed == publicationDateElement
          ? _value.publicationDateElement
          : publicationDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      publicationStatus: freezed == publicationStatus
          ? _value.publicationStatus
          : publicationStatus // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      publicationStatusElement: freezed == publicationStatusElement
          ? _value.publicationStatusElement
          : publicationStatusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      copyright: freezed == copyright
          ? _value.copyright
          : copyright // ignore: cast_nullable_to_non_nullable
              as FhirMarkdown?,
      copyrightElement: freezed == copyrightElement
          ? _value.copyrightElement
          : copyrightElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractContentDefinitionImpl extends _ContractContentDefinition {
  const _$ContractContentDefinitionImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.subType,
      this.publisher,
      this.publicationDate,
      @JsonKey(name: '_publicationDate') this.publicationDateElement,
      this.publicationStatus,
      @JsonKey(name: '_publicationStatus') this.publicationStatusElement,
      this.copyright,
      @JsonKey(name: '_copyright') this.copyrightElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ContractContentDefinitionImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractContentDefinitionImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Precusory content structure and use, i.e., a boilerplate,
  ///  template, application for a contract such as an insurance policy or
  ///  benefits under a program, e.g., workers compensation.
  @override
  final CodeableConcept type;

  /// [subType] Detailed Precusory content type.
  @override
  final CodeableConcept? subType;

  /// [publisher] The  individual or organization that published the Contract
  ///  precursor content.
  @override
  final Reference? publisher;

  /// [publicationDate] The date (and optionally time) when the contract was
  ///  last significantly changed. The date must change when the business
  ///  version changes and it must change if the status code changes. In
  ///  addition, it should change when the substantive content of the
  ///  contract changes.
  @override
  final FhirDateTime? publicationDate;

  /// [publicationDateElement] ("_publicationDate") Extensions for
  ///  publicationDate
  @override
  @JsonKey(name: '_publicationDate')
  final Element? publicationDateElement;

  /// [publicationStatus] amended | appended | cancelled | disputed |
  ///  entered-in-error | executable +.
  @override
  final FhirCode? publicationStatus;

  /// [publicationStatusElement] ("_publicationStatus") Extensions for
  ///  publicationStatus
  @override
  @JsonKey(name: '_publicationStatus')
  final Element? publicationStatusElement;

  /// [copyright] A copyright statement relating to Contract precursor
  ///  content. Copyright statements are generally legal restrictions on the
  ///  use and publishing of the Contract precursor content.
  @override
  final FhirMarkdown? copyright;

  /// [copyrightElement] ("_copyright") Extensions for copyright
  @override
  @JsonKey(name: '_copyright')
  final Element? copyrightElement;

  @override
  String toString() {
    return 'ContractContentDefinition(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, subType: $subType, publisher: $publisher, publicationDate: $publicationDate, publicationDateElement: $publicationDateElement, publicationStatus: $publicationStatus, publicationStatusElement: $publicationStatusElement, copyright: $copyright, copyrightElement: $copyrightElement)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractContentDefinitionImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.subType, subType) || other.subType == subType) &&
            (identical(other.publisher, publisher) ||
                other.publisher == publisher) &&
            (identical(other.publicationDate, publicationDate) ||
                other.publicationDate == publicationDate) &&
            (identical(other.publicationDateElement, publicationDateElement) ||
                other.publicationDateElement == publicationDateElement) &&
            (identical(other.publicationStatus, publicationStatus) ||
                other.publicationStatus == publicationStatus) &&
            (identical(
                    other.publicationStatusElement, publicationStatusElement) ||
                other.publicationStatusElement == publicationStatusElement) &&
            (identical(other.copyright, copyright) ||
                other.copyright == copyright) &&
            (identical(other.copyrightElement, copyrightElement) ||
                other.copyrightElement == copyrightElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      subType,
      publisher,
      publicationDate,
      publicationDateElement,
      publicationStatus,
      publicationStatusElement,
      copyright,
      copyrightElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractContentDefinitionImplCopyWith<_$ContractContentDefinitionImpl>
      get copyWith => __$$ContractContentDefinitionImplCopyWithImpl<
          _$ContractContentDefinitionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractContentDefinitionImplToJson(
      this,
    );
  }
}

abstract class _ContractContentDefinition extends ContractContentDefinition {
  const factory _ContractContentDefinition(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableConcept type,
      final CodeableConcept? subType,
      final Reference? publisher,
      final FhirDateTime? publicationDate,
      @JsonKey(name: '_publicationDate') final Element? publicationDateElement,
      final FhirCode? publicationStatus,
      @JsonKey(name: '_publicationStatus')
      final Element? publicationStatusElement,
      final FhirMarkdown? copyright,
      @JsonKey(name: '_copyright')
      final Element? copyrightElement}) = _$ContractContentDefinitionImpl;
  const _ContractContentDefinition._() : super._();

  factory _ContractContentDefinition.fromJson(Map<String, dynamic> json) =
      _$ContractContentDefinitionImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Precusory content structure and use, i.e., a boilerplate,
  ///  template, application for a contract such as an insurance policy or
  ///  benefits under a program, e.g., workers compensation.
  CodeableConcept get type;
  @override

  /// [subType] Detailed Precusory content type.
  CodeableConcept? get subType;
  @override

  /// [publisher] The  individual or organization that published the Contract
  ///  precursor content.
  Reference? get publisher;
  @override

  /// [publicationDate] The date (and optionally time) when the contract was
  ///  last significantly changed. The date must change when the business
  ///  version changes and it must change if the status code changes. In
  ///  addition, it should change when the substantive content of the
  ///  contract changes.
  FhirDateTime? get publicationDate;
  @override

  /// [publicationDateElement] ("_publicationDate") Extensions for
  ///  publicationDate
  @JsonKey(name: '_publicationDate')
  Element? get publicationDateElement;
  @override

  /// [publicationStatus] amended | appended | cancelled | disputed |
  ///  entered-in-error | executable +.
  FhirCode? get publicationStatus;
  @override

  /// [publicationStatusElement] ("_publicationStatus") Extensions for
  ///  publicationStatus
  @JsonKey(name: '_publicationStatus')
  Element? get publicationStatusElement;
  @override

  /// [copyright] A copyright statement relating to Contract precursor
  ///  content. Copyright statements are generally legal restrictions on the
  ///  use and publishing of the Contract precursor content.
  FhirMarkdown? get copyright;
  @override

  /// [copyrightElement] ("_copyright") Extensions for copyright
  @JsonKey(name: '_copyright')
  Element? get copyrightElement;
  @override
  @JsonKey(ignore: true)
  _$$ContractContentDefinitionImplCopyWith<_$ContractContentDefinitionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ContractTerm _$ContractTermFromJson(Map<String, dynamic> json) {
  return _ContractTerm.fromJson(json);
}

/// @nodoc
mixin _$ContractTerm {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Unique identifier for this particular Contract Provision.
  Identifier? get identifier => throw _privateConstructorUsedError;

  /// [issued] When this Contract Provision was issued.
  FhirDateTime? get issued => throw _privateConstructorUsedError;

  /// [issuedElement] ("_issued") Extensions for issued
  @JsonKey(name: '_issued')
  Element? get issuedElement => throw _privateConstructorUsedError;

  /// [applies] Relevant time or time-period when this Contract Provision is
  ///  applicable.
  Period? get applies => throw _privateConstructorUsedError;

  /// [topicCodeableConcept] The entity that the term applies to.
  CodeableConcept? get topicCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [topicReference] The entity that the term applies to.
  Reference? get topicReference => throw _privateConstructorUsedError;

  /// [type] A legal clause or condition contained within a contract that
  ///  requires one or both parties to perform a particular requirement by
  ///  some specified time or prevents one or both parties from performing a
  ///  particular requirement by some specified time.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [subType] A specialized legal clause or condition based on overarching
  ///  contract type.
  CodeableConcept? get subType => throw _privateConstructorUsedError;

  /// [text] Statement of a provision in a policy or a contract.
  String? get text => throw _privateConstructorUsedError;

  /// [textElement] ("_text") Extensions for text
  @JsonKey(name: '_text')
  Element? get textElement => throw _privateConstructorUsedError;

  /// [securityLabel] Security labels that protect the handling of
  ///  information about the term and its elements, which may be specifically
  ///  identified.
  List<ContractSecurityLabel>? get securityLabel =>
      throw _privateConstructorUsedError;

  /// [offer] The matter of concern in the context of this provision of the
  ///  agrement.
  ContractOffer get offer => throw _privateConstructorUsedError;

  /// [asset] Contract Term Asset List.
  List<ContractAsset>? get asset => throw _privateConstructorUsedError;

  /// [action] An actor taking a role in an activity for which it can be
  ///  assigned some degree of responsibility for the activity taking place.
  List<ContractAction>? get action => throw _privateConstructorUsedError;

  /// [group] Nested group of Contract Provisions.
  List<ContractTerm>? get group => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractTermCopyWith<ContractTerm> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractTermCopyWith<$Res> {
  factory $ContractTermCopyWith(
          ContractTerm value, $Res Function(ContractTerm) then) =
      _$ContractTermCopyWithImpl<$Res, ContractTerm>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      FhirDateTime? issued,
      @JsonKey(name: '_issued') Element? issuedElement,
      Period? applies,
      CodeableConcept? topicCodeableConcept,
      Reference? topicReference,
      CodeableConcept? type,
      CodeableConcept? subType,
      String? text,
      @JsonKey(name: '_text') Element? textElement,
      List<ContractSecurityLabel>? securityLabel,
      ContractOffer offer,
      List<ContractAsset>? asset,
      List<ContractAction>? action,
      List<ContractTerm>? group});

  $IdentifierCopyWith<$Res>? get identifier;
  $ElementCopyWith<$Res>? get issuedElement;
  $PeriodCopyWith<$Res>? get applies;
  $CodeableConceptCopyWith<$Res>? get topicCodeableConcept;
  $ReferenceCopyWith<$Res>? get topicReference;
  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get subType;
  $ElementCopyWith<$Res>? get textElement;
  $ContractOfferCopyWith<$Res> get offer;
}

/// @nodoc
class _$ContractTermCopyWithImpl<$Res, $Val extends ContractTerm>
    implements $ContractTermCopyWith<$Res> {
  _$ContractTermCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? issued = freezed,
    Object? issuedElement = freezed,
    Object? applies = freezed,
    Object? topicCodeableConcept = freezed,
    Object? topicReference = freezed,
    Object? type = freezed,
    Object? subType = freezed,
    Object? text = freezed,
    Object? textElement = freezed,
    Object? securityLabel = freezed,
    Object? offer = null,
    Object? asset = freezed,
    Object? action = freezed,
    Object? group = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      issued: freezed == issued
          ? _value.issued
          : issued // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      issuedElement: freezed == issuedElement
          ? _value.issuedElement
          : issuedElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      applies: freezed == applies
          ? _value.applies
          : applies // ignore: cast_nullable_to_non_nullable
              as Period?,
      topicCodeableConcept: freezed == topicCodeableConcept
          ? _value.topicCodeableConcept
          : topicCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      topicReference: freezed == topicReference
          ? _value.topicReference
          : topicReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      subType: freezed == subType
          ? _value.subType
          : subType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      textElement: freezed == textElement
          ? _value.textElement
          : textElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      securityLabel: freezed == securityLabel
          ? _value.securityLabel
          : securityLabel // ignore: cast_nullable_to_non_nullable
              as List<ContractSecurityLabel>?,
      offer: null == offer
          ? _value.offer
          : offer // ignore: cast_nullable_to_non_nullable
              as ContractOffer,
      asset: freezed == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as List<ContractAsset>?,
      action: freezed == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as List<ContractAction>?,
      group: freezed == group
          ? _value.group
          : group // ignore: cast_nullable_to_non_nullable
              as List<ContractTerm>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get issuedElement {
    if (_value.issuedElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.issuedElement!, (value) {
      return _then(_value.copyWith(issuedElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get applies {
    if (_value.applies == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.applies!, (value) {
      return _then(_value.copyWith(applies: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get topicCodeableConcept {
    if (_value.topicCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.topicCodeableConcept!,
        (value) {
      return _then(_value.copyWith(topicCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get topicReference {
    if (_value.topicReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.topicReference!, (value) {
      return _then(_value.copyWith(topicReference: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get subType {
    if (_value.subType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.subType!, (value) {
      return _then(_value.copyWith(subType: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get textElement {
    if (_value.textElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.textElement!, (value) {
      return _then(_value.copyWith(textElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ContractOfferCopyWith<$Res> get offer {
    return $ContractOfferCopyWith<$Res>(_value.offer, (value) {
      return _then(_value.copyWith(offer: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractTermImplCopyWith<$Res>
    implements $ContractTermCopyWith<$Res> {
  factory _$$ContractTermImplCopyWith(
          _$ContractTermImpl value, $Res Function(_$ContractTermImpl) then) =
      __$$ContractTermImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Identifier? identifier,
      FhirDateTime? issued,
      @JsonKey(name: '_issued') Element? issuedElement,
      Period? applies,
      CodeableConcept? topicCodeableConcept,
      Reference? topicReference,
      CodeableConcept? type,
      CodeableConcept? subType,
      String? text,
      @JsonKey(name: '_text') Element? textElement,
      List<ContractSecurityLabel>? securityLabel,
      ContractOffer offer,
      List<ContractAsset>? asset,
      List<ContractAction>? action,
      List<ContractTerm>? group});

  @override
  $IdentifierCopyWith<$Res>? get identifier;
  @override
  $ElementCopyWith<$Res>? get issuedElement;
  @override
  $PeriodCopyWith<$Res>? get applies;
  @override
  $CodeableConceptCopyWith<$Res>? get topicCodeableConcept;
  @override
  $ReferenceCopyWith<$Res>? get topicReference;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get subType;
  @override
  $ElementCopyWith<$Res>? get textElement;
  @override
  $ContractOfferCopyWith<$Res> get offer;
}

/// @nodoc
class __$$ContractTermImplCopyWithImpl<$Res>
    extends _$ContractTermCopyWithImpl<$Res, _$ContractTermImpl>
    implements _$$ContractTermImplCopyWith<$Res> {
  __$$ContractTermImplCopyWithImpl(
      _$ContractTermImpl _value, $Res Function(_$ContractTermImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? issued = freezed,
    Object? issuedElement = freezed,
    Object? applies = freezed,
    Object? topicCodeableConcept = freezed,
    Object? topicReference = freezed,
    Object? type = freezed,
    Object? subType = freezed,
    Object? text = freezed,
    Object? textElement = freezed,
    Object? securityLabel = freezed,
    Object? offer = null,
    Object? asset = freezed,
    Object? action = freezed,
    Object? group = freezed,
  }) {
    return _then(_$ContractTermImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      issued: freezed == issued
          ? _value.issued
          : issued // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      issuedElement: freezed == issuedElement
          ? _value.issuedElement
          : issuedElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      applies: freezed == applies
          ? _value.applies
          : applies // ignore: cast_nullable_to_non_nullable
              as Period?,
      topicCodeableConcept: freezed == topicCodeableConcept
          ? _value.topicCodeableConcept
          : topicCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      topicReference: freezed == topicReference
          ? _value.topicReference
          : topicReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      subType: freezed == subType
          ? _value.subType
          : subType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      textElement: freezed == textElement
          ? _value.textElement
          : textElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      securityLabel: freezed == securityLabel
          ? _value._securityLabel
          : securityLabel // ignore: cast_nullable_to_non_nullable
              as List<ContractSecurityLabel>?,
      offer: null == offer
          ? _value.offer
          : offer // ignore: cast_nullable_to_non_nullable
              as ContractOffer,
      asset: freezed == asset
          ? _value._asset
          : asset // ignore: cast_nullable_to_non_nullable
              as List<ContractAsset>?,
      action: freezed == action
          ? _value._action
          : action // ignore: cast_nullable_to_non_nullable
              as List<ContractAction>?,
      group: freezed == group
          ? _value._group
          : group // ignore: cast_nullable_to_non_nullable
              as List<ContractTerm>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractTermImpl extends _ContractTerm {
  const _$ContractTermImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.identifier,
      this.issued,
      @JsonKey(name: '_issued') this.issuedElement,
      this.applies,
      this.topicCodeableConcept,
      this.topicReference,
      this.type,
      this.subType,
      this.text,
      @JsonKey(name: '_text') this.textElement,
      final List<ContractSecurityLabel>? securityLabel,
      required this.offer,
      final List<ContractAsset>? asset,
      final List<ContractAction>? action,
      final List<ContractTerm>? group})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _securityLabel = securityLabel,
        _asset = asset,
        _action = action,
        _group = group,
        super._();

  factory _$ContractTermImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractTermImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Unique identifier for this particular Contract Provision.
  @override
  final Identifier? identifier;

  /// [issued] When this Contract Provision was issued.
  @override
  final FhirDateTime? issued;

  /// [issuedElement] ("_issued") Extensions for issued
  @override
  @JsonKey(name: '_issued')
  final Element? issuedElement;

  /// [applies] Relevant time or time-period when this Contract Provision is
  ///  applicable.
  @override
  final Period? applies;

  /// [topicCodeableConcept] The entity that the term applies to.
  @override
  final CodeableConcept? topicCodeableConcept;

  /// [topicReference] The entity that the term applies to.
  @override
  final Reference? topicReference;

  /// [type] A legal clause or condition contained within a contract that
  ///  requires one or both parties to perform a particular requirement by
  ///  some specified time or prevents one or both parties from performing a
  ///  particular requirement by some specified time.
  @override
  final CodeableConcept? type;

  /// [subType] A specialized legal clause or condition based on overarching
  ///  contract type.
  @override
  final CodeableConcept? subType;

  /// [text] Statement of a provision in a policy or a contract.
  @override
  final String? text;

  /// [textElement] ("_text") Extensions for text
  @override
  @JsonKey(name: '_text')
  final Element? textElement;

  /// [securityLabel] Security labels that protect the handling of
  ///  information about the term and its elements, which may be specifically
  ///  identified.
  final List<ContractSecurityLabel>? _securityLabel;

  /// [securityLabel] Security labels that protect the handling of
  ///  information about the term and its elements, which may be specifically
  ///  identified.
  @override
  List<ContractSecurityLabel>? get securityLabel {
    final value = _securityLabel;
    if (value == null) return null;
    if (_securityLabel is EqualUnmodifiableListView) return _securityLabel;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [offer] The matter of concern in the context of this provision of the
  ///  agrement.
  @override
  final ContractOffer offer;

  /// [asset] Contract Term Asset List.
  final List<ContractAsset>? _asset;

  /// [asset] Contract Term Asset List.
  @override
  List<ContractAsset>? get asset {
    final value = _asset;
    if (value == null) return null;
    if (_asset is EqualUnmodifiableListView) return _asset;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [action] An actor taking a role in an activity for which it can be
  ///  assigned some degree of responsibility for the activity taking place.
  final List<ContractAction>? _action;

  /// [action] An actor taking a role in an activity for which it can be
  ///  assigned some degree of responsibility for the activity taking place.
  @override
  List<ContractAction>? get action {
    final value = _action;
    if (value == null) return null;
    if (_action is EqualUnmodifiableListView) return _action;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [group] Nested group of Contract Provisions.
  final List<ContractTerm>? _group;

  /// [group] Nested group of Contract Provisions.
  @override
  List<ContractTerm>? get group {
    final value = _group;
    if (value == null) return null;
    if (_group is EqualUnmodifiableListView) return _group;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ContractTerm(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, issued: $issued, issuedElement: $issuedElement, applies: $applies, topicCodeableConcept: $topicCodeableConcept, topicReference: $topicReference, type: $type, subType: $subType, text: $text, textElement: $textElement, securityLabel: $securityLabel, offer: $offer, asset: $asset, action: $action, group: $group)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractTermImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.issued, issued) || other.issued == issued) &&
            (identical(other.issuedElement, issuedElement) ||
                other.issuedElement == issuedElement) &&
            (identical(other.applies, applies) || other.applies == applies) &&
            (identical(other.topicCodeableConcept, topicCodeableConcept) ||
                other.topicCodeableConcept == topicCodeableConcept) &&
            (identical(other.topicReference, topicReference) ||
                other.topicReference == topicReference) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.subType, subType) || other.subType == subType) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.textElement, textElement) ||
                other.textElement == textElement) &&
            const DeepCollectionEquality()
                .equals(other._securityLabel, _securityLabel) &&
            (identical(other.offer, offer) || other.offer == offer) &&
            const DeepCollectionEquality().equals(other._asset, _asset) &&
            const DeepCollectionEquality().equals(other._action, _action) &&
            const DeepCollectionEquality().equals(other._group, _group));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      identifier,
      issued,
      issuedElement,
      applies,
      topicCodeableConcept,
      topicReference,
      type,
      subType,
      text,
      textElement,
      const DeepCollectionEquality().hash(_securityLabel),
      offer,
      const DeepCollectionEquality().hash(_asset),
      const DeepCollectionEquality().hash(_action),
      const DeepCollectionEquality().hash(_group));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractTermImplCopyWith<_$ContractTermImpl> get copyWith =>
      __$$ContractTermImplCopyWithImpl<_$ContractTermImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractTermImplToJson(
      this,
    );
  }
}

abstract class _ContractTerm extends ContractTerm {
  const factory _ContractTerm(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Identifier? identifier,
      final FhirDateTime? issued,
      @JsonKey(name: '_issued') final Element? issuedElement,
      final Period? applies,
      final CodeableConcept? topicCodeableConcept,
      final Reference? topicReference,
      final CodeableConcept? type,
      final CodeableConcept? subType,
      final String? text,
      @JsonKey(name: '_text') final Element? textElement,
      final List<ContractSecurityLabel>? securityLabel,
      required final ContractOffer offer,
      final List<ContractAsset>? asset,
      final List<ContractAction>? action,
      final List<ContractTerm>? group}) = _$ContractTermImpl;
  const _ContractTerm._() : super._();

  factory _ContractTerm.fromJson(Map<String, dynamic> json) =
      _$ContractTermImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Unique identifier for this particular Contract Provision.
  Identifier? get identifier;
  @override

  /// [issued] When this Contract Provision was issued.
  FhirDateTime? get issued;
  @override

  /// [issuedElement] ("_issued") Extensions for issued
  @JsonKey(name: '_issued')
  Element? get issuedElement;
  @override

  /// [applies] Relevant time or time-period when this Contract Provision is
  ///  applicable.
  Period? get applies;
  @override

  /// [topicCodeableConcept] The entity that the term applies to.
  CodeableConcept? get topicCodeableConcept;
  @override

  /// [topicReference] The entity that the term applies to.
  Reference? get topicReference;
  @override

  /// [type] A legal clause or condition contained within a contract that
  ///  requires one or both parties to perform a particular requirement by
  ///  some specified time or prevents one or both parties from performing a
  ///  particular requirement by some specified time.
  CodeableConcept? get type;
  @override

  /// [subType] A specialized legal clause or condition based on overarching
  ///  contract type.
  CodeableConcept? get subType;
  @override

  /// [text] Statement of a provision in a policy or a contract.
  String? get text;
  @override

  /// [textElement] ("_text") Extensions for text
  @JsonKey(name: '_text')
  Element? get textElement;
  @override

  /// [securityLabel] Security labels that protect the handling of
  ///  information about the term and its elements, which may be specifically
  ///  identified.
  List<ContractSecurityLabel>? get securityLabel;
  @override

  /// [offer] The matter of concern in the context of this provision of the
  ///  agrement.
  ContractOffer get offer;
  @override

  /// [asset] Contract Term Asset List.
  List<ContractAsset>? get asset;
  @override

  /// [action] An actor taking a role in an activity for which it can be
  ///  assigned some degree of responsibility for the activity taking place.
  List<ContractAction>? get action;
  @override

  /// [group] Nested group of Contract Provisions.
  List<ContractTerm>? get group;
  @override
  @JsonKey(ignore: true)
  _$$ContractTermImplCopyWith<_$ContractTermImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractSecurityLabel _$ContractSecurityLabelFromJson(
    Map<String, dynamic> json) {
  return _ContractSecurityLabel.fromJson(json);
}

/// @nodoc
mixin _$ContractSecurityLabel {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [number] Number used to link this term or term element to the
  ///  applicable Security Label.
  List<FhirUnsignedInt>? get number => throw _privateConstructorUsedError;

  /// [numberElement] ("_number") Extensions for number
  @JsonKey(name: '_number')
  List<Element>? get numberElement => throw _privateConstructorUsedError;

  /// [classification] Security label privacy tag that specifies the level of
  ///  confidentiality protection required for this term and/or term elements.
  Coding get classification => throw _privateConstructorUsedError;

  /// [category] Security label privacy tag that specifies the applicable
  ///  privacy and security policies governing this term and/or term elements.
  List<Coding>? get category => throw _privateConstructorUsedError;

  /// [control] Security label privacy tag that specifies the manner in which
  ///  term and/or term elements are to be protected.
  List<Coding>? get control => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractSecurityLabelCopyWith<ContractSecurityLabel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractSecurityLabelCopyWith<$Res> {
  factory $ContractSecurityLabelCopyWith(ContractSecurityLabel value,
          $Res Function(ContractSecurityLabel) then) =
      _$ContractSecurityLabelCopyWithImpl<$Res, ContractSecurityLabel>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<FhirUnsignedInt>? number,
      @JsonKey(name: '_number') List<Element>? numberElement,
      Coding classification,
      List<Coding>? category,
      List<Coding>? control});

  $CodingCopyWith<$Res> get classification;
}

/// @nodoc
class _$ContractSecurityLabelCopyWithImpl<$Res,
        $Val extends ContractSecurityLabel>
    implements $ContractSecurityLabelCopyWith<$Res> {
  _$ContractSecurityLabelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? number = freezed,
    Object? numberElement = freezed,
    Object? classification = null,
    Object? category = freezed,
    Object? control = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as List<FhirUnsignedInt>?,
      numberElement: freezed == numberElement
          ? _value.numberElement
          : numberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      classification: null == classification
          ? _value.classification
          : classification // ignore: cast_nullable_to_non_nullable
              as Coding,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as List<Coding>?,
      control: freezed == control
          ? _value.control
          : control // ignore: cast_nullable_to_non_nullable
              as List<Coding>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodingCopyWith<$Res> get classification {
    return $CodingCopyWith<$Res>(_value.classification, (value) {
      return _then(_value.copyWith(classification: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractSecurityLabelImplCopyWith<$Res>
    implements $ContractSecurityLabelCopyWith<$Res> {
  factory _$$ContractSecurityLabelImplCopyWith(
          _$ContractSecurityLabelImpl value,
          $Res Function(_$ContractSecurityLabelImpl) then) =
      __$$ContractSecurityLabelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<FhirUnsignedInt>? number,
      @JsonKey(name: '_number') List<Element>? numberElement,
      Coding classification,
      List<Coding>? category,
      List<Coding>? control});

  @override
  $CodingCopyWith<$Res> get classification;
}

/// @nodoc
class __$$ContractSecurityLabelImplCopyWithImpl<$Res>
    extends _$ContractSecurityLabelCopyWithImpl<$Res,
        _$ContractSecurityLabelImpl>
    implements _$$ContractSecurityLabelImplCopyWith<$Res> {
  __$$ContractSecurityLabelImplCopyWithImpl(_$ContractSecurityLabelImpl _value,
      $Res Function(_$ContractSecurityLabelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? number = freezed,
    Object? numberElement = freezed,
    Object? classification = null,
    Object? category = freezed,
    Object? control = freezed,
  }) {
    return _then(_$ContractSecurityLabelImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      number: freezed == number
          ? _value._number
          : number // ignore: cast_nullable_to_non_nullable
              as List<FhirUnsignedInt>?,
      numberElement: freezed == numberElement
          ? _value._numberElement
          : numberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      classification: null == classification
          ? _value.classification
          : classification // ignore: cast_nullable_to_non_nullable
              as Coding,
      category: freezed == category
          ? _value._category
          : category // ignore: cast_nullable_to_non_nullable
              as List<Coding>?,
      control: freezed == control
          ? _value._control
          : control // ignore: cast_nullable_to_non_nullable
              as List<Coding>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractSecurityLabelImpl extends _ContractSecurityLabel {
  const _$ContractSecurityLabelImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<FhirUnsignedInt>? number,
      @JsonKey(name: '_number') final List<Element>? numberElement,
      required this.classification,
      final List<Coding>? category,
      final List<Coding>? control})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _number = number,
        _numberElement = numberElement,
        _category = category,
        _control = control,
        super._();

  factory _$ContractSecurityLabelImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractSecurityLabelImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [number] Number used to link this term or term element to the
  ///  applicable Security Label.
  final List<FhirUnsignedInt>? _number;

  /// [number] Number used to link this term or term element to the
  ///  applicable Security Label.
  @override
  List<FhirUnsignedInt>? get number {
    final value = _number;
    if (value == null) return null;
    if (_number is EqualUnmodifiableListView) return _number;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [numberElement] ("_number") Extensions for number
  final List<Element>? _numberElement;

  /// [numberElement] ("_number") Extensions for number
  @override
  @JsonKey(name: '_number')
  List<Element>? get numberElement {
    final value = _numberElement;
    if (value == null) return null;
    if (_numberElement is EqualUnmodifiableListView) return _numberElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [classification] Security label privacy tag that specifies the level of
  ///  confidentiality protection required for this term and/or term elements.
  @override
  final Coding classification;

  /// [category] Security label privacy tag that specifies the applicable
  ///  privacy and security policies governing this term and/or term elements.
  final List<Coding>? _category;

  /// [category] Security label privacy tag that specifies the applicable
  ///  privacy and security policies governing this term and/or term elements.
  @override
  List<Coding>? get category {
    final value = _category;
    if (value == null) return null;
    if (_category is EqualUnmodifiableListView) return _category;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [control] Security label privacy tag that specifies the manner in which
  ///  term and/or term elements are to be protected.
  final List<Coding>? _control;

  /// [control] Security label privacy tag that specifies the manner in which
  ///  term and/or term elements are to be protected.
  @override
  List<Coding>? get control {
    final value = _control;
    if (value == null) return null;
    if (_control is EqualUnmodifiableListView) return _control;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ContractSecurityLabel(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, number: $number, numberElement: $numberElement, classification: $classification, category: $category, control: $control)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractSecurityLabelImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality().equals(other._number, _number) &&
            const DeepCollectionEquality()
                .equals(other._numberElement, _numberElement) &&
            (identical(other.classification, classification) ||
                other.classification == classification) &&
            const DeepCollectionEquality().equals(other._category, _category) &&
            const DeepCollectionEquality().equals(other._control, _control));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_number),
      const DeepCollectionEquality().hash(_numberElement),
      classification,
      const DeepCollectionEquality().hash(_category),
      const DeepCollectionEquality().hash(_control));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractSecurityLabelImplCopyWith<_$ContractSecurityLabelImpl>
      get copyWith => __$$ContractSecurityLabelImplCopyWithImpl<
          _$ContractSecurityLabelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractSecurityLabelImplToJson(
      this,
    );
  }
}

abstract class _ContractSecurityLabel extends ContractSecurityLabel {
  const factory _ContractSecurityLabel(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<FhirUnsignedInt>? number,
      @JsonKey(name: '_number') final List<Element>? numberElement,
      required final Coding classification,
      final List<Coding>? category,
      final List<Coding>? control}) = _$ContractSecurityLabelImpl;
  const _ContractSecurityLabel._() : super._();

  factory _ContractSecurityLabel.fromJson(Map<String, dynamic> json) =
      _$ContractSecurityLabelImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [number] Number used to link this term or term element to the
  ///  applicable Security Label.
  List<FhirUnsignedInt>? get number;
  @override

  /// [numberElement] ("_number") Extensions for number
  @JsonKey(name: '_number')
  List<Element>? get numberElement;
  @override

  /// [classification] Security label privacy tag that specifies the level of
  ///  confidentiality protection required for this term and/or term elements.
  Coding get classification;
  @override

  /// [category] Security label privacy tag that specifies the applicable
  ///  privacy and security policies governing this term and/or term elements.
  List<Coding>? get category;
  @override

  /// [control] Security label privacy tag that specifies the manner in which
  ///  term and/or term elements are to be protected.
  List<Coding>? get control;
  @override
  @JsonKey(ignore: true)
  _$$ContractSecurityLabelImplCopyWith<_$ContractSecurityLabelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ContractOffer _$ContractOfferFromJson(Map<String, dynamic> json) {
  return _ContractOffer.fromJson(json);
}

/// @nodoc
mixin _$ContractOffer {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Unique identifier for this particular Contract Provision.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [party] Offer Recipient.
  List<ContractParty>? get party => throw _privateConstructorUsedError;

  /// [topic] The owner of an asset has the residual control rights over the
  ///  asset: the right to decide all usages of the asset in any way not
  ///  inconsistent with a prior contract, custom, or law (Hart, 1995, p. 30).
  Reference? get topic => throw _privateConstructorUsedError;

  /// [type] Type of Contract Provision such as specific requirements,
  ///  purposes for actions, obligations, prohibitions, e.g. life time
  ///  maximum benefit.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [decision] Type of choice made by accepting party with respect to an
  ///  offer made by an offeror/ grantee.
  CodeableConcept? get decision => throw _privateConstructorUsedError;

  /// [decisionMode] How the decision about a Contract was conveyed.
  List<CodeableConcept>? get decisionMode => throw _privateConstructorUsedError;

  /// [answer] Response to offer text.
  List<ContractAnswer>? get answer => throw _privateConstructorUsedError;

  /// [text] Human readable form of this Contract Offer.
  String? get text => throw _privateConstructorUsedError;

  /// [textElement] ("_text") Extensions for text
  @JsonKey(name: '_text')
  Element? get textElement => throw _privateConstructorUsedError;

  /// [linkId] The id of the clause or question text of the offer in the
  ///  referenced questionnaire/response.
  List<String>? get linkId => throw _privateConstructorUsedError;

  /// [linkIdElement] ("_linkId") Extensions for linkId
  @JsonKey(name: '_linkId')
  List<Element>? get linkIdElement => throw _privateConstructorUsedError;

  /// [securityLabelNumber] Security labels that protects the offer.
  List<FhirUnsignedInt>? get securityLabelNumber =>
      throw _privateConstructorUsedError;

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  @JsonKey(name: '_securityLabelNumber')
  List<Element>? get securityLabelNumberElement =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractOfferCopyWith<ContractOffer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractOfferCopyWith<$Res> {
  factory $ContractOfferCopyWith(
          ContractOffer value, $Res Function(ContractOffer) then) =
      _$ContractOfferCopyWithImpl<$Res, ContractOffer>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      List<ContractParty>? party,
      Reference? topic,
      CodeableConcept? type,
      CodeableConcept? decision,
      List<CodeableConcept>? decisionMode,
      List<ContractAnswer>? answer,
      String? text,
      @JsonKey(name: '_text') Element? textElement,
      List<String>? linkId,
      @JsonKey(name: '_linkId') List<Element>? linkIdElement,
      List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      List<Element>? securityLabelNumberElement});

  $ReferenceCopyWith<$Res>? get topic;
  $CodeableConceptCopyWith<$Res>? get type;
  $CodeableConceptCopyWith<$Res>? get decision;
  $ElementCopyWith<$Res>? get textElement;
}

/// @nodoc
class _$ContractOfferCopyWithImpl<$Res, $Val extends ContractOffer>
    implements $ContractOfferCopyWith<$Res> {
  _$ContractOfferCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? party = freezed,
    Object? topic = freezed,
    Object? type = freezed,
    Object? decision = freezed,
    Object? decisionMode = freezed,
    Object? answer = freezed,
    Object? text = freezed,
    Object? textElement = freezed,
    Object? linkId = freezed,
    Object? linkIdElement = freezed,
    Object? securityLabelNumber = freezed,
    Object? securityLabelNumberElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      party: freezed == party
          ? _value.party
          : party // ignore: cast_nullable_to_non_nullable
              as List<ContractParty>?,
      topic: freezed == topic
          ? _value.topic
          : topic // ignore: cast_nullable_to_non_nullable
              as Reference?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      decision: freezed == decision
          ? _value.decision
          : decision // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      decisionMode: freezed == decisionMode
          ? _value.decisionMode
          : decisionMode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      answer: freezed == answer
          ? _value.answer
          : answer // ignore: cast_nullable_to_non_nullable
              as List<ContractAnswer>?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      textElement: freezed == textElement
          ? _value.textElement
          : textElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      linkId: freezed == linkId
          ? _value.linkId
          : linkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      linkIdElement: freezed == linkIdElement
          ? _value.linkIdElement
          : linkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      securityLabelNumber: freezed == securityLabelNumber
          ? _value.securityLabelNumber
          : securityLabelNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirUnsignedInt>?,
      securityLabelNumberElement: freezed == securityLabelNumberElement
          ? _value.securityLabelNumberElement
          : securityLabelNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get topic {
    if (_value.topic == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.topic!, (value) {
      return _then(_value.copyWith(topic: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get decision {
    if (_value.decision == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.decision!, (value) {
      return _then(_value.copyWith(decision: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get textElement {
    if (_value.textElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.textElement!, (value) {
      return _then(_value.copyWith(textElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractOfferImplCopyWith<$Res>
    implements $ContractOfferCopyWith<$Res> {
  factory _$$ContractOfferImplCopyWith(
          _$ContractOfferImpl value, $Res Function(_$ContractOfferImpl) then) =
      __$$ContractOfferImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      List<ContractParty>? party,
      Reference? topic,
      CodeableConcept? type,
      CodeableConcept? decision,
      List<CodeableConcept>? decisionMode,
      List<ContractAnswer>? answer,
      String? text,
      @JsonKey(name: '_text') Element? textElement,
      List<String>? linkId,
      @JsonKey(name: '_linkId') List<Element>? linkIdElement,
      List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      List<Element>? securityLabelNumberElement});

  @override
  $ReferenceCopyWith<$Res>? get topic;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $CodeableConceptCopyWith<$Res>? get decision;
  @override
  $ElementCopyWith<$Res>? get textElement;
}

/// @nodoc
class __$$ContractOfferImplCopyWithImpl<$Res>
    extends _$ContractOfferCopyWithImpl<$Res, _$ContractOfferImpl>
    implements _$$ContractOfferImplCopyWith<$Res> {
  __$$ContractOfferImplCopyWithImpl(
      _$ContractOfferImpl _value, $Res Function(_$ContractOfferImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? party = freezed,
    Object? topic = freezed,
    Object? type = freezed,
    Object? decision = freezed,
    Object? decisionMode = freezed,
    Object? answer = freezed,
    Object? text = freezed,
    Object? textElement = freezed,
    Object? linkId = freezed,
    Object? linkIdElement = freezed,
    Object? securityLabelNumber = freezed,
    Object? securityLabelNumberElement = freezed,
  }) {
    return _then(_$ContractOfferImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      party: freezed == party
          ? _value._party
          : party // ignore: cast_nullable_to_non_nullable
              as List<ContractParty>?,
      topic: freezed == topic
          ? _value.topic
          : topic // ignore: cast_nullable_to_non_nullable
              as Reference?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      decision: freezed == decision
          ? _value.decision
          : decision // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      decisionMode: freezed == decisionMode
          ? _value._decisionMode
          : decisionMode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      answer: freezed == answer
          ? _value._answer
          : answer // ignore: cast_nullable_to_non_nullable
              as List<ContractAnswer>?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      textElement: freezed == textElement
          ? _value.textElement
          : textElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      linkId: freezed == linkId
          ? _value._linkId
          : linkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      linkIdElement: freezed == linkIdElement
          ? _value._linkIdElement
          : linkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      securityLabelNumber: freezed == securityLabelNumber
          ? _value._securityLabelNumber
          : securityLabelNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirUnsignedInt>?,
      securityLabelNumberElement: freezed == securityLabelNumberElement
          ? _value._securityLabelNumberElement
          : securityLabelNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractOfferImpl extends _ContractOffer {
  const _$ContractOfferImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final List<ContractParty>? party,
      this.topic,
      this.type,
      this.decision,
      final List<CodeableConcept>? decisionMode,
      final List<ContractAnswer>? answer,
      this.text,
      @JsonKey(name: '_text') this.textElement,
      final List<String>? linkId,
      @JsonKey(name: '_linkId') final List<Element>? linkIdElement,
      final List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      final List<Element>? securityLabelNumberElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _party = party,
        _decisionMode = decisionMode,
        _answer = answer,
        _linkId = linkId,
        _linkIdElement = linkIdElement,
        _securityLabelNumber = securityLabelNumber,
        _securityLabelNumberElement = securityLabelNumberElement,
        super._();

  factory _$ContractOfferImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractOfferImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Unique identifier for this particular Contract Provision.
  final List<Identifier>? _identifier;

  /// [identifier] Unique identifier for this particular Contract Provision.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [party] Offer Recipient.
  final List<ContractParty>? _party;

  /// [party] Offer Recipient.
  @override
  List<ContractParty>? get party {
    final value = _party;
    if (value == null) return null;
    if (_party is EqualUnmodifiableListView) return _party;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [topic] The owner of an asset has the residual control rights over the
  ///  asset: the right to decide all usages of the asset in any way not
  ///  inconsistent with a prior contract, custom, or law (Hart, 1995, p. 30).
  @override
  final Reference? topic;

  /// [type] Type of Contract Provision such as specific requirements,
  ///  purposes for actions, obligations, prohibitions, e.g. life time
  ///  maximum benefit.
  @override
  final CodeableConcept? type;

  /// [decision] Type of choice made by accepting party with respect to an
  ///  offer made by an offeror/ grantee.
  @override
  final CodeableConcept? decision;

  /// [decisionMode] How the decision about a Contract was conveyed.
  final List<CodeableConcept>? _decisionMode;

  /// [decisionMode] How the decision about a Contract was conveyed.
  @override
  List<CodeableConcept>? get decisionMode {
    final value = _decisionMode;
    if (value == null) return null;
    if (_decisionMode is EqualUnmodifiableListView) return _decisionMode;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [answer] Response to offer text.
  final List<ContractAnswer>? _answer;

  /// [answer] Response to offer text.
  @override
  List<ContractAnswer>? get answer {
    final value = _answer;
    if (value == null) return null;
    if (_answer is EqualUnmodifiableListView) return _answer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [text] Human readable form of this Contract Offer.
  @override
  final String? text;

  /// [textElement] ("_text") Extensions for text
  @override
  @JsonKey(name: '_text')
  final Element? textElement;

  /// [linkId] The id of the clause or question text of the offer in the
  ///  referenced questionnaire/response.
  final List<String>? _linkId;

  /// [linkId] The id of the clause or question text of the offer in the
  ///  referenced questionnaire/response.
  @override
  List<String>? get linkId {
    final value = _linkId;
    if (value == null) return null;
    if (_linkId is EqualUnmodifiableListView) return _linkId;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [linkIdElement] ("_linkId") Extensions for linkId
  final List<Element>? _linkIdElement;

  /// [linkIdElement] ("_linkId") Extensions for linkId
  @override
  @JsonKey(name: '_linkId')
  List<Element>? get linkIdElement {
    final value = _linkIdElement;
    if (value == null) return null;
    if (_linkIdElement is EqualUnmodifiableListView) return _linkIdElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [securityLabelNumber] Security labels that protects the offer.
  final List<FhirUnsignedInt>? _securityLabelNumber;

  /// [securityLabelNumber] Security labels that protects the offer.
  @override
  List<FhirUnsignedInt>? get securityLabelNumber {
    final value = _securityLabelNumber;
    if (value == null) return null;
    if (_securityLabelNumber is EqualUnmodifiableListView)
      return _securityLabelNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  final List<Element>? _securityLabelNumberElement;

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  @override
  @JsonKey(name: '_securityLabelNumber')
  List<Element>? get securityLabelNumberElement {
    final value = _securityLabelNumberElement;
    if (value == null) return null;
    if (_securityLabelNumberElement is EqualUnmodifiableListView)
      return _securityLabelNumberElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ContractOffer(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, party: $party, topic: $topic, type: $type, decision: $decision, decisionMode: $decisionMode, answer: $answer, text: $text, textElement: $textElement, linkId: $linkId, linkIdElement: $linkIdElement, securityLabelNumber: $securityLabelNumber, securityLabelNumberElement: $securityLabelNumberElement)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractOfferImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            const DeepCollectionEquality().equals(other._party, _party) &&
            (identical(other.topic, topic) || other.topic == topic) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.decision, decision) ||
                other.decision == decision) &&
            const DeepCollectionEquality()
                .equals(other._decisionMode, _decisionMode) &&
            const DeepCollectionEquality().equals(other._answer, _answer) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.textElement, textElement) ||
                other.textElement == textElement) &&
            const DeepCollectionEquality().equals(other._linkId, _linkId) &&
            const DeepCollectionEquality()
                .equals(other._linkIdElement, _linkIdElement) &&
            const DeepCollectionEquality()
                .equals(other._securityLabelNumber, _securityLabelNumber) &&
            const DeepCollectionEquality().equals(
                other._securityLabelNumberElement,
                _securityLabelNumberElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_identifier),
      const DeepCollectionEquality().hash(_party),
      topic,
      type,
      decision,
      const DeepCollectionEquality().hash(_decisionMode),
      const DeepCollectionEquality().hash(_answer),
      text,
      textElement,
      const DeepCollectionEquality().hash(_linkId),
      const DeepCollectionEquality().hash(_linkIdElement),
      const DeepCollectionEquality().hash(_securityLabelNumber),
      const DeepCollectionEquality().hash(_securityLabelNumberElement));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractOfferImplCopyWith<_$ContractOfferImpl> get copyWith =>
      __$$ContractOfferImplCopyWithImpl<_$ContractOfferImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractOfferImplToJson(
      this,
    );
  }
}

abstract class _ContractOffer extends ContractOffer {
  const factory _ContractOffer(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final List<ContractParty>? party,
      final Reference? topic,
      final CodeableConcept? type,
      final CodeableConcept? decision,
      final List<CodeableConcept>? decisionMode,
      final List<ContractAnswer>? answer,
      final String? text,
      @JsonKey(name: '_text') final Element? textElement,
      final List<String>? linkId,
      @JsonKey(name: '_linkId') final List<Element>? linkIdElement,
      final List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      final List<Element>? securityLabelNumberElement}) = _$ContractOfferImpl;
  const _ContractOffer._() : super._();

  factory _ContractOffer.fromJson(Map<String, dynamic> json) =
      _$ContractOfferImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Unique identifier for this particular Contract Provision.
  List<Identifier>? get identifier;
  @override

  /// [party] Offer Recipient.
  List<ContractParty>? get party;
  @override

  /// [topic] The owner of an asset has the residual control rights over the
  ///  asset: the right to decide all usages of the asset in any way not
  ///  inconsistent with a prior contract, custom, or law (Hart, 1995, p. 30).
  Reference? get topic;
  @override

  /// [type] Type of Contract Provision such as specific requirements,
  ///  purposes for actions, obligations, prohibitions, e.g. life time
  ///  maximum benefit.
  CodeableConcept? get type;
  @override

  /// [decision] Type of choice made by accepting party with respect to an
  ///  offer made by an offeror/ grantee.
  CodeableConcept? get decision;
  @override

  /// [decisionMode] How the decision about a Contract was conveyed.
  List<CodeableConcept>? get decisionMode;
  @override

  /// [answer] Response to offer text.
  List<ContractAnswer>? get answer;
  @override

  /// [text] Human readable form of this Contract Offer.
  String? get text;
  @override

  /// [textElement] ("_text") Extensions for text
  @JsonKey(name: '_text')
  Element? get textElement;
  @override

  /// [linkId] The id of the clause or question text of the offer in the
  ///  referenced questionnaire/response.
  List<String>? get linkId;
  @override

  /// [linkIdElement] ("_linkId") Extensions for linkId
  @JsonKey(name: '_linkId')
  List<Element>? get linkIdElement;
  @override

  /// [securityLabelNumber] Security labels that protects the offer.
  List<FhirUnsignedInt>? get securityLabelNumber;
  @override

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  @JsonKey(name: '_securityLabelNumber')
  List<Element>? get securityLabelNumberElement;
  @override
  @JsonKey(ignore: true)
  _$$ContractOfferImplCopyWith<_$ContractOfferImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractParty _$ContractPartyFromJson(Map<String, dynamic> json) {
  return _ContractParty.fromJson(json);
}

/// @nodoc
mixin _$ContractParty {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [reference] Participant in the offer.
  List<Reference> get reference => throw _privateConstructorUsedError;

  /// [role] How the party participates in the offer.
  CodeableConcept get role => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractPartyCopyWith<ContractParty> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractPartyCopyWith<$Res> {
  factory $ContractPartyCopyWith(
          ContractParty value, $Res Function(ContractParty) then) =
      _$ContractPartyCopyWithImpl<$Res, ContractParty>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Reference> reference,
      CodeableConcept role});

  $CodeableConceptCopyWith<$Res> get role;
}

/// @nodoc
class _$ContractPartyCopyWithImpl<$Res, $Val extends ContractParty>
    implements $ContractPartyCopyWith<$Res> {
  _$ContractPartyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? reference = null,
    Object? role = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      reference: null == reference
          ? _value.reference
          : reference // ignore: cast_nullable_to_non_nullable
              as List<Reference>,
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get role {
    return $CodeableConceptCopyWith<$Res>(_value.role, (value) {
      return _then(_value.copyWith(role: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractPartyImplCopyWith<$Res>
    implements $ContractPartyCopyWith<$Res> {
  factory _$$ContractPartyImplCopyWith(
          _$ContractPartyImpl value, $Res Function(_$ContractPartyImpl) then) =
      __$$ContractPartyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Reference> reference,
      CodeableConcept role});

  @override
  $CodeableConceptCopyWith<$Res> get role;
}

/// @nodoc
class __$$ContractPartyImplCopyWithImpl<$Res>
    extends _$ContractPartyCopyWithImpl<$Res, _$ContractPartyImpl>
    implements _$$ContractPartyImplCopyWith<$Res> {
  __$$ContractPartyImplCopyWithImpl(
      _$ContractPartyImpl _value, $Res Function(_$ContractPartyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? reference = null,
    Object? role = null,
  }) {
    return _then(_$ContractPartyImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      reference: null == reference
          ? _value._reference
          : reference // ignore: cast_nullable_to_non_nullable
              as List<Reference>,
      role: null == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractPartyImpl extends _ContractParty {
  const _$ContractPartyImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final List<Reference> reference,
      required this.role})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _reference = reference,
        super._();

  factory _$ContractPartyImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractPartyImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reference] Participant in the offer.
  final List<Reference> _reference;

  /// [reference] Participant in the offer.
  @override
  List<Reference> get reference {
    if (_reference is EqualUnmodifiableListView) return _reference;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_reference);
  }

  /// [role] How the party participates in the offer.
  @override
  final CodeableConcept role;

  @override
  String toString() {
    return 'ContractParty(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, reference: $reference, role: $role)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractPartyImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._reference, _reference) &&
            (identical(other.role, role) || other.role == role));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_reference),
      role);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractPartyImplCopyWith<_$ContractPartyImpl> get copyWith =>
      __$$ContractPartyImplCopyWithImpl<_$ContractPartyImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractPartyImplToJson(
      this,
    );
  }
}

abstract class _ContractParty extends ContractParty {
  const factory _ContractParty(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final List<Reference> reference,
      required final CodeableConcept role}) = _$ContractPartyImpl;
  const _ContractParty._() : super._();

  factory _ContractParty.fromJson(Map<String, dynamic> json) =
      _$ContractPartyImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [reference] Participant in the offer.
  List<Reference> get reference;
  @override

  /// [role] How the party participates in the offer.
  CodeableConcept get role;
  @override
  @JsonKey(ignore: true)
  _$$ContractPartyImplCopyWith<_$ContractPartyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractAnswer _$ContractAnswerFromJson(Map<String, dynamic> json) {
  return _ContractAnswer.fromJson(json);
}

/// @nodoc
mixin _$ContractAnswer {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [valueBoolean] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirBoolean? get valueBoolean => throw _privateConstructorUsedError;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement => throw _privateConstructorUsedError;

  /// [valueDecimal] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirDecimal? get valueDecimal => throw _privateConstructorUsedError;

  /// [valueDecimalElement] ("_valueDecimal") Extensions for valueDecimal
  @JsonKey(name: '_valueDecimal')
  Element? get valueDecimalElement => throw _privateConstructorUsedError;

  /// [valueInteger] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirInteger? get valueInteger => throw _privateConstructorUsedError;

  /// [valueIntegerElement] ("_valueInteger") Extensions for valueInteger
  @JsonKey(name: '_valueInteger')
  Element? get valueIntegerElement => throw _privateConstructorUsedError;

  /// [valueDate] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirDate? get valueDate => throw _privateConstructorUsedError;

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement => throw _privateConstructorUsedError;

  /// [valueDateTime] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirDateTime? get valueDateTime => throw _privateConstructorUsedError;

  /// [valueDateTimeElement] ("_valueDateTime") Extensions for valueDateTime
  @JsonKey(name: '_valueDateTime')
  Element? get valueDateTimeElement => throw _privateConstructorUsedError;

  /// [valueTime] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirTime? get valueTime => throw _privateConstructorUsedError;

  /// [valueTimeElement] ("_valueTime") Extensions for valueTime
  @JsonKey(name: '_valueTime')
  Element? get valueTimeElement => throw _privateConstructorUsedError;

  /// [valueString] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  String? get valueString => throw _privateConstructorUsedError;

  /// [valueStringElement] ("_valueString") Extensions for valueString
  @JsonKey(name: '_valueString')
  Element? get valueStringElement => throw _privateConstructorUsedError;

  /// [valueUri] Response to an offer clause or question text,  which enables
  ///  selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirUri? get valueUri => throw _privateConstructorUsedError;

  /// [valueUriElement] ("_valueUri") Extensions for valueUri
  @JsonKey(name: '_valueUri')
  Element? get valueUriElement => throw _privateConstructorUsedError;

  /// [valueAttachment] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  Attachment? get valueAttachment => throw _privateConstructorUsedError;

  /// [valueCoding] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  Coding? get valueCoding => throw _privateConstructorUsedError;

  /// [valueQuantity] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  Quantity? get valueQuantity => throw _privateConstructorUsedError;

  /// [valueReference] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  Reference? get valueReference => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractAnswerCopyWith<ContractAnswer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractAnswerCopyWith<$Res> {
  factory $ContractAnswerCopyWith(
          ContractAnswer value, $Res Function(ContractAnswer) then) =
      _$ContractAnswerCopyWithImpl<$Res, ContractAnswer>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirBoolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      FhirDecimal? valueDecimal,
      @JsonKey(name: '_valueDecimal') Element? valueDecimalElement,
      FhirInteger? valueInteger,
      @JsonKey(name: '_valueInteger') Element? valueIntegerElement,
      FhirDate? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      FhirDateTime? valueDateTime,
      @JsonKey(name: '_valueDateTime') Element? valueDateTimeElement,
      FhirTime? valueTime,
      @JsonKey(name: '_valueTime') Element? valueTimeElement,
      String? valueString,
      @JsonKey(name: '_valueString') Element? valueStringElement,
      FhirUri? valueUri,
      @JsonKey(name: '_valueUri') Element? valueUriElement,
      Attachment? valueAttachment,
      Coding? valueCoding,
      Quantity? valueQuantity,
      Reference? valueReference});

  $ElementCopyWith<$Res>? get valueBooleanElement;
  $ElementCopyWith<$Res>? get valueDecimalElement;
  $ElementCopyWith<$Res>? get valueIntegerElement;
  $ElementCopyWith<$Res>? get valueDateElement;
  $ElementCopyWith<$Res>? get valueDateTimeElement;
  $ElementCopyWith<$Res>? get valueTimeElement;
  $ElementCopyWith<$Res>? get valueStringElement;
  $ElementCopyWith<$Res>? get valueUriElement;
  $AttachmentCopyWith<$Res>? get valueAttachment;
  $CodingCopyWith<$Res>? get valueCoding;
  $QuantityCopyWith<$Res>? get valueQuantity;
  $ReferenceCopyWith<$Res>? get valueReference;
}

/// @nodoc
class _$ContractAnswerCopyWithImpl<$Res, $Val extends ContractAnswer>
    implements $ContractAnswerCopyWith<$Res> {
  _$ContractAnswerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueDecimal = freezed,
    Object? valueDecimalElement = freezed,
    Object? valueInteger = freezed,
    Object? valueIntegerElement = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueDateTime = freezed,
    Object? valueDateTimeElement = freezed,
    Object? valueTime = freezed,
    Object? valueTimeElement = freezed,
    Object? valueString = freezed,
    Object? valueStringElement = freezed,
    Object? valueUri = freezed,
    Object? valueUriElement = freezed,
    Object? valueAttachment = freezed,
    Object? valueCoding = freezed,
    Object? valueQuantity = freezed,
    Object? valueReference = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueDecimal: freezed == valueDecimal
          ? _value.valueDecimal
          : valueDecimal // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      valueDecimalElement: freezed == valueDecimalElement
          ? _value.valueDecimalElement
          : valueDecimalElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueInteger: freezed == valueInteger
          ? _value.valueInteger
          : valueInteger // ignore: cast_nullable_to_non_nullable
              as FhirInteger?,
      valueIntegerElement: freezed == valueIntegerElement
          ? _value.valueIntegerElement
          : valueIntegerElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueDateTime: freezed == valueDateTime
          ? _value.valueDateTime
          : valueDateTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      valueDateTimeElement: freezed == valueDateTimeElement
          ? _value.valueDateTimeElement
          : valueDateTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueTime: freezed == valueTime
          ? _value.valueTime
          : valueTime // ignore: cast_nullable_to_non_nullable
              as FhirTime?,
      valueTimeElement: freezed == valueTimeElement
          ? _value.valueTimeElement
          : valueTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueString: freezed == valueString
          ? _value.valueString
          : valueString // ignore: cast_nullable_to_non_nullable
              as String?,
      valueStringElement: freezed == valueStringElement
          ? _value.valueStringElement
          : valueStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueUri: freezed == valueUri
          ? _value.valueUri
          : valueUri // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      valueUriElement: freezed == valueUriElement
          ? _value.valueUriElement
          : valueUriElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      valueCoding: freezed == valueCoding
          ? _value.valueCoding
          : valueCoding // ignore: cast_nullable_to_non_nullable
              as Coding?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueReference: freezed == valueReference
          ? _value.valueReference
          : valueReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueBooleanElement {
    if (_value.valueBooleanElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueBooleanElement!, (value) {
      return _then(_value.copyWith(valueBooleanElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDecimalElement {
    if (_value.valueDecimalElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDecimalElement!, (value) {
      return _then(_value.copyWith(valueDecimalElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueIntegerElement {
    if (_value.valueIntegerElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueIntegerElement!, (value) {
      return _then(_value.copyWith(valueIntegerElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDateElement {
    if (_value.valueDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDateElement!, (value) {
      return _then(_value.copyWith(valueDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueDateTimeElement {
    if (_value.valueDateTimeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueDateTimeElement!, (value) {
      return _then(_value.copyWith(valueDateTimeElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueTimeElement {
    if (_value.valueTimeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueTimeElement!, (value) {
      return _then(_value.copyWith(valueTimeElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueStringElement {
    if (_value.valueStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueStringElement!, (value) {
      return _then(_value.copyWith(valueStringElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueUriElement {
    if (_value.valueUriElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueUriElement!, (value) {
      return _then(_value.copyWith(valueUriElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.valueAttachment!, (value) {
      return _then(_value.copyWith(valueAttachment: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodingCopyWith<$Res>? get valueCoding {
    if (_value.valueCoding == null) {
      return null;
    }

    return $CodingCopyWith<$Res>(_value.valueCoding!, (value) {
      return _then(_value.copyWith(valueCoding: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.valueQuantity!, (value) {
      return _then(_value.copyWith(valueQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get valueReference {
    if (_value.valueReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.valueReference!, (value) {
      return _then(_value.copyWith(valueReference: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractAnswerImplCopyWith<$Res>
    implements $ContractAnswerCopyWith<$Res> {
  factory _$$ContractAnswerImplCopyWith(_$ContractAnswerImpl value,
          $Res Function(_$ContractAnswerImpl) then) =
      __$$ContractAnswerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirBoolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      FhirDecimal? valueDecimal,
      @JsonKey(name: '_valueDecimal') Element? valueDecimalElement,
      FhirInteger? valueInteger,
      @JsonKey(name: '_valueInteger') Element? valueIntegerElement,
      FhirDate? valueDate,
      @JsonKey(name: '_valueDate') Element? valueDateElement,
      FhirDateTime? valueDateTime,
      @JsonKey(name: '_valueDateTime') Element? valueDateTimeElement,
      FhirTime? valueTime,
      @JsonKey(name: '_valueTime') Element? valueTimeElement,
      String? valueString,
      @JsonKey(name: '_valueString') Element? valueStringElement,
      FhirUri? valueUri,
      @JsonKey(name: '_valueUri') Element? valueUriElement,
      Attachment? valueAttachment,
      Coding? valueCoding,
      Quantity? valueQuantity,
      Reference? valueReference});

  @override
  $ElementCopyWith<$Res>? get valueBooleanElement;
  @override
  $ElementCopyWith<$Res>? get valueDecimalElement;
  @override
  $ElementCopyWith<$Res>? get valueIntegerElement;
  @override
  $ElementCopyWith<$Res>? get valueDateElement;
  @override
  $ElementCopyWith<$Res>? get valueDateTimeElement;
  @override
  $ElementCopyWith<$Res>? get valueTimeElement;
  @override
  $ElementCopyWith<$Res>? get valueStringElement;
  @override
  $ElementCopyWith<$Res>? get valueUriElement;
  @override
  $AttachmentCopyWith<$Res>? get valueAttachment;
  @override
  $CodingCopyWith<$Res>? get valueCoding;
  @override
  $QuantityCopyWith<$Res>? get valueQuantity;
  @override
  $ReferenceCopyWith<$Res>? get valueReference;
}

/// @nodoc
class __$$ContractAnswerImplCopyWithImpl<$Res>
    extends _$ContractAnswerCopyWithImpl<$Res, _$ContractAnswerImpl>
    implements _$$ContractAnswerImplCopyWith<$Res> {
  __$$ContractAnswerImplCopyWithImpl(
      _$ContractAnswerImpl _value, $Res Function(_$ContractAnswerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueDecimal = freezed,
    Object? valueDecimalElement = freezed,
    Object? valueInteger = freezed,
    Object? valueIntegerElement = freezed,
    Object? valueDate = freezed,
    Object? valueDateElement = freezed,
    Object? valueDateTime = freezed,
    Object? valueDateTimeElement = freezed,
    Object? valueTime = freezed,
    Object? valueTimeElement = freezed,
    Object? valueString = freezed,
    Object? valueStringElement = freezed,
    Object? valueUri = freezed,
    Object? valueUriElement = freezed,
    Object? valueAttachment = freezed,
    Object? valueCoding = freezed,
    Object? valueQuantity = freezed,
    Object? valueReference = freezed,
  }) {
    return _then(_$ContractAnswerImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueDecimal: freezed == valueDecimal
          ? _value.valueDecimal
          : valueDecimal // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      valueDecimalElement: freezed == valueDecimalElement
          ? _value.valueDecimalElement
          : valueDecimalElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueInteger: freezed == valueInteger
          ? _value.valueInteger
          : valueInteger // ignore: cast_nullable_to_non_nullable
              as FhirInteger?,
      valueIntegerElement: freezed == valueIntegerElement
          ? _value.valueIntegerElement
          : valueIntegerElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueDate: freezed == valueDate
          ? _value.valueDate
          : valueDate // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      valueDateElement: freezed == valueDateElement
          ? _value.valueDateElement
          : valueDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueDateTime: freezed == valueDateTime
          ? _value.valueDateTime
          : valueDateTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      valueDateTimeElement: freezed == valueDateTimeElement
          ? _value.valueDateTimeElement
          : valueDateTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueTime: freezed == valueTime
          ? _value.valueTime
          : valueTime // ignore: cast_nullable_to_non_nullable
              as FhirTime?,
      valueTimeElement: freezed == valueTimeElement
          ? _value.valueTimeElement
          : valueTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueString: freezed == valueString
          ? _value.valueString
          : valueString // ignore: cast_nullable_to_non_nullable
              as String?,
      valueStringElement: freezed == valueStringElement
          ? _value.valueStringElement
          : valueStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueUri: freezed == valueUri
          ? _value.valueUri
          : valueUri // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      valueUriElement: freezed == valueUriElement
          ? _value.valueUriElement
          : valueUriElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      valueCoding: freezed == valueCoding
          ? _value.valueCoding
          : valueCoding // ignore: cast_nullable_to_non_nullable
              as Coding?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueReference: freezed == valueReference
          ? _value.valueReference
          : valueReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractAnswerImpl extends _ContractAnswer {
  const _$ContractAnswerImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.valueBoolean,
      @JsonKey(name: '_valueBoolean') this.valueBooleanElement,
      this.valueDecimal,
      @JsonKey(name: '_valueDecimal') this.valueDecimalElement,
      this.valueInteger,
      @JsonKey(name: '_valueInteger') this.valueIntegerElement,
      this.valueDate,
      @JsonKey(name: '_valueDate') this.valueDateElement,
      this.valueDateTime,
      @JsonKey(name: '_valueDateTime') this.valueDateTimeElement,
      this.valueTime,
      @JsonKey(name: '_valueTime') this.valueTimeElement,
      this.valueString,
      @JsonKey(name: '_valueString') this.valueStringElement,
      this.valueUri,
      @JsonKey(name: '_valueUri') this.valueUriElement,
      this.valueAttachment,
      this.valueCoding,
      this.valueQuantity,
      this.valueReference})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ContractAnswerImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractAnswerImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [valueBoolean] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  @override
  final FhirBoolean? valueBoolean;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @override
  @JsonKey(name: '_valueBoolean')
  final Element? valueBooleanElement;

  /// [valueDecimal] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  @override
  final FhirDecimal? valueDecimal;

  /// [valueDecimalElement] ("_valueDecimal") Extensions for valueDecimal
  @override
  @JsonKey(name: '_valueDecimal')
  final Element? valueDecimalElement;

  /// [valueInteger] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  @override
  final FhirInteger? valueInteger;

  /// [valueIntegerElement] ("_valueInteger") Extensions for valueInteger
  @override
  @JsonKey(name: '_valueInteger')
  final Element? valueIntegerElement;

  /// [valueDate] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  @override
  final FhirDate? valueDate;

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @override
  @JsonKey(name: '_valueDate')
  final Element? valueDateElement;

  /// [valueDateTime] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  @override
  final FhirDateTime? valueDateTime;

  /// [valueDateTimeElement] ("_valueDateTime") Extensions for valueDateTime
  @override
  @JsonKey(name: '_valueDateTime')
  final Element? valueDateTimeElement;

  /// [valueTime] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  @override
  final FhirTime? valueTime;

  /// [valueTimeElement] ("_valueTime") Extensions for valueTime
  @override
  @JsonKey(name: '_valueTime')
  final Element? valueTimeElement;

  /// [valueString] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  @override
  final String? valueString;

  /// [valueStringElement] ("_valueString") Extensions for valueString
  @override
  @JsonKey(name: '_valueString')
  final Element? valueStringElement;

  /// [valueUri] Response to an offer clause or question text,  which enables
  ///  selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  @override
  final FhirUri? valueUri;

  /// [valueUriElement] ("_valueUri") Extensions for valueUri
  @override
  @JsonKey(name: '_valueUri')
  final Element? valueUriElement;

  /// [valueAttachment] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  @override
  final Attachment? valueAttachment;

  /// [valueCoding] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  @override
  final Coding? valueCoding;

  /// [valueQuantity] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  @override
  final Quantity? valueQuantity;

  /// [valueReference] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  @override
  final Reference? valueReference;

  @override
  String toString() {
    return 'ContractAnswer(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, valueBoolean: $valueBoolean, valueBooleanElement: $valueBooleanElement, valueDecimal: $valueDecimal, valueDecimalElement: $valueDecimalElement, valueInteger: $valueInteger, valueIntegerElement: $valueIntegerElement, valueDate: $valueDate, valueDateElement: $valueDateElement, valueDateTime: $valueDateTime, valueDateTimeElement: $valueDateTimeElement, valueTime: $valueTime, valueTimeElement: $valueTimeElement, valueString: $valueString, valueStringElement: $valueStringElement, valueUri: $valueUri, valueUriElement: $valueUriElement, valueAttachment: $valueAttachment, valueCoding: $valueCoding, valueQuantity: $valueQuantity, valueReference: $valueReference)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractAnswerImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.valueBoolean, valueBoolean) ||
                other.valueBoolean == valueBoolean) &&
            (identical(other.valueBooleanElement, valueBooleanElement) ||
                other.valueBooleanElement == valueBooleanElement) &&
            (identical(other.valueDecimal, valueDecimal) ||
                other.valueDecimal == valueDecimal) &&
            (identical(other.valueDecimalElement, valueDecimalElement) ||
                other.valueDecimalElement == valueDecimalElement) &&
            (identical(other.valueInteger, valueInteger) ||
                other.valueInteger == valueInteger) &&
            (identical(other.valueIntegerElement, valueIntegerElement) ||
                other.valueIntegerElement == valueIntegerElement) &&
            (identical(other.valueDate, valueDate) ||
                other.valueDate == valueDate) &&
            (identical(other.valueDateElement, valueDateElement) ||
                other.valueDateElement == valueDateElement) &&
            (identical(other.valueDateTime, valueDateTime) ||
                other.valueDateTime == valueDateTime) &&
            (identical(other.valueDateTimeElement, valueDateTimeElement) ||
                other.valueDateTimeElement == valueDateTimeElement) &&
            (identical(other.valueTime, valueTime) ||
                other.valueTime == valueTime) &&
            (identical(other.valueTimeElement, valueTimeElement) ||
                other.valueTimeElement == valueTimeElement) &&
            (identical(other.valueString, valueString) ||
                other.valueString == valueString) &&
            (identical(other.valueStringElement, valueStringElement) ||
                other.valueStringElement == valueStringElement) &&
            (identical(other.valueUri, valueUri) ||
                other.valueUri == valueUri) &&
            (identical(other.valueUriElement, valueUriElement) ||
                other.valueUriElement == valueUriElement) &&
            (identical(other.valueAttachment, valueAttachment) ||
                other.valueAttachment == valueAttachment) &&
            (identical(other.valueCoding, valueCoding) ||
                other.valueCoding == valueCoding) &&
            (identical(other.valueQuantity, valueQuantity) ||
                other.valueQuantity == valueQuantity) &&
            (identical(other.valueReference, valueReference) ||
                other.valueReference == valueReference));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        valueBoolean,
        valueBooleanElement,
        valueDecimal,
        valueDecimalElement,
        valueInteger,
        valueIntegerElement,
        valueDate,
        valueDateElement,
        valueDateTime,
        valueDateTimeElement,
        valueTime,
        valueTimeElement,
        valueString,
        valueStringElement,
        valueUri,
        valueUriElement,
        valueAttachment,
        valueCoding,
        valueQuantity,
        valueReference
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractAnswerImplCopyWith<_$ContractAnswerImpl> get copyWith =>
      __$$ContractAnswerImplCopyWithImpl<_$ContractAnswerImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractAnswerImplToJson(
      this,
    );
  }
}

abstract class _ContractAnswer extends ContractAnswer {
  const factory _ContractAnswer(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final FhirBoolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') final Element? valueBooleanElement,
      final FhirDecimal? valueDecimal,
      @JsonKey(name: '_valueDecimal') final Element? valueDecimalElement,
      final FhirInteger? valueInteger,
      @JsonKey(name: '_valueInteger') final Element? valueIntegerElement,
      final FhirDate? valueDate,
      @JsonKey(name: '_valueDate') final Element? valueDateElement,
      final FhirDateTime? valueDateTime,
      @JsonKey(name: '_valueDateTime') final Element? valueDateTimeElement,
      final FhirTime? valueTime,
      @JsonKey(name: '_valueTime') final Element? valueTimeElement,
      final String? valueString,
      @JsonKey(name: '_valueString') final Element? valueStringElement,
      final FhirUri? valueUri,
      @JsonKey(name: '_valueUri') final Element? valueUriElement,
      final Attachment? valueAttachment,
      final Coding? valueCoding,
      final Quantity? valueQuantity,
      final Reference? valueReference}) = _$ContractAnswerImpl;
  const _ContractAnswer._() : super._();

  factory _ContractAnswer.fromJson(Map<String, dynamic> json) =
      _$ContractAnswerImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [valueBoolean] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirBoolean? get valueBoolean;
  @override

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement;
  @override

  /// [valueDecimal] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirDecimal? get valueDecimal;
  @override

  /// [valueDecimalElement] ("_valueDecimal") Extensions for valueDecimal
  @JsonKey(name: '_valueDecimal')
  Element? get valueDecimalElement;
  @override

  /// [valueInteger] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirInteger? get valueInteger;
  @override

  /// [valueIntegerElement] ("_valueInteger") Extensions for valueInteger
  @JsonKey(name: '_valueInteger')
  Element? get valueIntegerElement;
  @override

  /// [valueDate] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirDate? get valueDate;
  @override

  /// [valueDateElement] ("_valueDate") Extensions for valueDate
  @JsonKey(name: '_valueDate')
  Element? get valueDateElement;
  @override

  /// [valueDateTime] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirDateTime? get valueDateTime;
  @override

  /// [valueDateTimeElement] ("_valueDateTime") Extensions for valueDateTime
  @JsonKey(name: '_valueDateTime')
  Element? get valueDateTimeElement;
  @override

  /// [valueTime] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirTime? get valueTime;
  @override

  /// [valueTimeElement] ("_valueTime") Extensions for valueTime
  @JsonKey(name: '_valueTime')
  Element? get valueTimeElement;
  @override

  /// [valueString] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  String? get valueString;
  @override

  /// [valueStringElement] ("_valueString") Extensions for valueString
  @JsonKey(name: '_valueString')
  Element? get valueStringElement;
  @override

  /// [valueUri] Response to an offer clause or question text,  which enables
  ///  selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  FhirUri? get valueUri;
  @override

  /// [valueUriElement] ("_valueUri") Extensions for valueUri
  @JsonKey(name: '_valueUri')
  Element? get valueUriElement;
  @override

  /// [valueAttachment] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  Attachment? get valueAttachment;
  @override

  /// [valueCoding] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  Coding? get valueCoding;
  @override

  /// [valueQuantity] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  Quantity? get valueQuantity;
  @override

  /// [valueReference] Response to an offer clause or question text,  which
  ///  enables selection of values to be agreed to, e.g., the period of
  ///  participation, the date of occupancy of a rental, warranty duration,
  ///  or whether biospecimen may be used for further research.
  Reference? get valueReference;
  @override
  @JsonKey(ignore: true)
  _$$ContractAnswerImplCopyWith<_$ContractAnswerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractAsset _$ContractAssetFromJson(Map<String, dynamic> json) {
  return _ContractAsset.fromJson(json);
}

/// @nodoc
mixin _$ContractAsset {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [scope] Differentiates the kind of the asset .
  CodeableConcept? get scope => throw _privateConstructorUsedError;

  /// [type] Target entity type about which the term may be concerned.
  List<CodeableConcept>? get type => throw _privateConstructorUsedError;

  /// [typeReference] Associated entities.
  List<Reference>? get typeReference => throw _privateConstructorUsedError;

  /// [subtype] May be a subtype or part of an offered asset.
  List<CodeableConcept>? get subtype => throw _privateConstructorUsedError;

  /// [relationship] Specifies the applicability of the term to an asset
  ///  resource instance, and instances it refers to or instances that refer
  ///  to it, and/or are owned by the offeree.
  Coding? get relationship => throw _privateConstructorUsedError;

  /// [context] Circumstance of the asset.
  List<ContractContext>? get context => throw _privateConstructorUsedError;

  /// [condition] Description of the quality and completeness of the asset
  ///  that may be a factor in its valuation.
  String? get condition => throw _privateConstructorUsedError;

  /// [conditionElement] ("_condition") Extensions for condition
  @JsonKey(name: '_condition')
  Element? get conditionElement => throw _privateConstructorUsedError;

  /// [periodType] Type of Asset availability for use or ownership.
  List<CodeableConcept>? get periodType => throw _privateConstructorUsedError;

  /// [period] Asset relevant contractual time period.
  List<Period>? get period => throw _privateConstructorUsedError;

  /// [usePeriod] Time period of asset use.
  List<Period>? get usePeriod => throw _privateConstructorUsedError;

  /// [text] Clause or question text (Prose Object) concerning the asset in a
  ///  linked form, such as a QuestionnaireResponse used in the formation of
  ///  the contract.
  String? get text => throw _privateConstructorUsedError;

  /// [textElement] ("_text") Extensions for text
  @JsonKey(name: '_text')
  Element? get textElement => throw _privateConstructorUsedError;

  /// [linkId] Id [identifier??] of the clause or question text about the
  ///  asset in the referenced form or QuestionnaireResponse.
  List<String>? get linkId => throw _privateConstructorUsedError;

  /// [linkIdElement] ("_linkId") Extensions for linkId
  @JsonKey(name: '_linkId')
  List<Element>? get linkIdElement => throw _privateConstructorUsedError;

  /// [answer] Response to assets.
  List<ContractAnswer>? get answer => throw _privateConstructorUsedError;

  /// [securityLabelNumber] Security labels that protects the asset.
  List<FhirUnsignedInt>? get securityLabelNumber =>
      throw _privateConstructorUsedError;

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  @JsonKey(name: '_securityLabelNumber')
  List<Element>? get securityLabelNumberElement =>
      throw _privateConstructorUsedError;

  /// [valuedItem] Contract Valued Item List.
  List<ContractValuedItem>? get valuedItem =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractAssetCopyWith<ContractAsset> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractAssetCopyWith<$Res> {
  factory $ContractAssetCopyWith(
          ContractAsset value, $Res Function(ContractAsset) then) =
      _$ContractAssetCopyWithImpl<$Res, ContractAsset>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? scope,
      List<CodeableConcept>? type,
      List<Reference>? typeReference,
      List<CodeableConcept>? subtype,
      Coding? relationship,
      List<ContractContext>? context,
      String? condition,
      @JsonKey(name: '_condition') Element? conditionElement,
      List<CodeableConcept>? periodType,
      List<Period>? period,
      List<Period>? usePeriod,
      String? text,
      @JsonKey(name: '_text') Element? textElement,
      List<String>? linkId,
      @JsonKey(name: '_linkId') List<Element>? linkIdElement,
      List<ContractAnswer>? answer,
      List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      List<Element>? securityLabelNumberElement,
      List<ContractValuedItem>? valuedItem});

  $CodeableConceptCopyWith<$Res>? get scope;
  $CodingCopyWith<$Res>? get relationship;
  $ElementCopyWith<$Res>? get conditionElement;
  $ElementCopyWith<$Res>? get textElement;
}

/// @nodoc
class _$ContractAssetCopyWithImpl<$Res, $Val extends ContractAsset>
    implements $ContractAssetCopyWith<$Res> {
  _$ContractAssetCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? scope = freezed,
    Object? type = freezed,
    Object? typeReference = freezed,
    Object? subtype = freezed,
    Object? relationship = freezed,
    Object? context = freezed,
    Object? condition = freezed,
    Object? conditionElement = freezed,
    Object? periodType = freezed,
    Object? period = freezed,
    Object? usePeriod = freezed,
    Object? text = freezed,
    Object? textElement = freezed,
    Object? linkId = freezed,
    Object? linkIdElement = freezed,
    Object? answer = freezed,
    Object? securityLabelNumber = freezed,
    Object? securityLabelNumberElement = freezed,
    Object? valuedItem = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      scope: freezed == scope
          ? _value.scope
          : scope // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      typeReference: freezed == typeReference
          ? _value.typeReference
          : typeReference // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      subtype: freezed == subtype
          ? _value.subtype
          : subtype // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      relationship: freezed == relationship
          ? _value.relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as Coding?,
      context: freezed == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as List<ContractContext>?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as String?,
      conditionElement: freezed == conditionElement
          ? _value.conditionElement
          : conditionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      periodType: freezed == periodType
          ? _value.periodType
          : periodType // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      period: freezed == period
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as List<Period>?,
      usePeriod: freezed == usePeriod
          ? _value.usePeriod
          : usePeriod // ignore: cast_nullable_to_non_nullable
              as List<Period>?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      textElement: freezed == textElement
          ? _value.textElement
          : textElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      linkId: freezed == linkId
          ? _value.linkId
          : linkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      linkIdElement: freezed == linkIdElement
          ? _value.linkIdElement
          : linkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      answer: freezed == answer
          ? _value.answer
          : answer // ignore: cast_nullable_to_non_nullable
              as List<ContractAnswer>?,
      securityLabelNumber: freezed == securityLabelNumber
          ? _value.securityLabelNumber
          : securityLabelNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirUnsignedInt>?,
      securityLabelNumberElement: freezed == securityLabelNumberElement
          ? _value.securityLabelNumberElement
          : securityLabelNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      valuedItem: freezed == valuedItem
          ? _value.valuedItem
          : valuedItem // ignore: cast_nullable_to_non_nullable
              as List<ContractValuedItem>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get scope {
    if (_value.scope == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.scope!, (value) {
      return _then(_value.copyWith(scope: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodingCopyWith<$Res>? get relationship {
    if (_value.relationship == null) {
      return null;
    }

    return $CodingCopyWith<$Res>(_value.relationship!, (value) {
      return _then(_value.copyWith(relationship: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get conditionElement {
    if (_value.conditionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.conditionElement!, (value) {
      return _then(_value.copyWith(conditionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get textElement {
    if (_value.textElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.textElement!, (value) {
      return _then(_value.copyWith(textElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractAssetImplCopyWith<$Res>
    implements $ContractAssetCopyWith<$Res> {
  factory _$$ContractAssetImplCopyWith(
          _$ContractAssetImpl value, $Res Function(_$ContractAssetImpl) then) =
      __$$ContractAssetImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? scope,
      List<CodeableConcept>? type,
      List<Reference>? typeReference,
      List<CodeableConcept>? subtype,
      Coding? relationship,
      List<ContractContext>? context,
      String? condition,
      @JsonKey(name: '_condition') Element? conditionElement,
      List<CodeableConcept>? periodType,
      List<Period>? period,
      List<Period>? usePeriod,
      String? text,
      @JsonKey(name: '_text') Element? textElement,
      List<String>? linkId,
      @JsonKey(name: '_linkId') List<Element>? linkIdElement,
      List<ContractAnswer>? answer,
      List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      List<Element>? securityLabelNumberElement,
      List<ContractValuedItem>? valuedItem});

  @override
  $CodeableConceptCopyWith<$Res>? get scope;
  @override
  $CodingCopyWith<$Res>? get relationship;
  @override
  $ElementCopyWith<$Res>? get conditionElement;
  @override
  $ElementCopyWith<$Res>? get textElement;
}

/// @nodoc
class __$$ContractAssetImplCopyWithImpl<$Res>
    extends _$ContractAssetCopyWithImpl<$Res, _$ContractAssetImpl>
    implements _$$ContractAssetImplCopyWith<$Res> {
  __$$ContractAssetImplCopyWithImpl(
      _$ContractAssetImpl _value, $Res Function(_$ContractAssetImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? scope = freezed,
    Object? type = freezed,
    Object? typeReference = freezed,
    Object? subtype = freezed,
    Object? relationship = freezed,
    Object? context = freezed,
    Object? condition = freezed,
    Object? conditionElement = freezed,
    Object? periodType = freezed,
    Object? period = freezed,
    Object? usePeriod = freezed,
    Object? text = freezed,
    Object? textElement = freezed,
    Object? linkId = freezed,
    Object? linkIdElement = freezed,
    Object? answer = freezed,
    Object? securityLabelNumber = freezed,
    Object? securityLabelNumberElement = freezed,
    Object? valuedItem = freezed,
  }) {
    return _then(_$ContractAssetImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      scope: freezed == scope
          ? _value.scope
          : scope // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      type: freezed == type
          ? _value._type
          : type // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      typeReference: freezed == typeReference
          ? _value._typeReference
          : typeReference // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      subtype: freezed == subtype
          ? _value._subtype
          : subtype // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      relationship: freezed == relationship
          ? _value.relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as Coding?,
      context: freezed == context
          ? _value._context
          : context // ignore: cast_nullable_to_non_nullable
              as List<ContractContext>?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as String?,
      conditionElement: freezed == conditionElement
          ? _value.conditionElement
          : conditionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      periodType: freezed == periodType
          ? _value._periodType
          : periodType // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      period: freezed == period
          ? _value._period
          : period // ignore: cast_nullable_to_non_nullable
              as List<Period>?,
      usePeriod: freezed == usePeriod
          ? _value._usePeriod
          : usePeriod // ignore: cast_nullable_to_non_nullable
              as List<Period>?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      textElement: freezed == textElement
          ? _value.textElement
          : textElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      linkId: freezed == linkId
          ? _value._linkId
          : linkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      linkIdElement: freezed == linkIdElement
          ? _value._linkIdElement
          : linkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      answer: freezed == answer
          ? _value._answer
          : answer // ignore: cast_nullable_to_non_nullable
              as List<ContractAnswer>?,
      securityLabelNumber: freezed == securityLabelNumber
          ? _value._securityLabelNumber
          : securityLabelNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirUnsignedInt>?,
      securityLabelNumberElement: freezed == securityLabelNumberElement
          ? _value._securityLabelNumberElement
          : securityLabelNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      valuedItem: freezed == valuedItem
          ? _value._valuedItem
          : valuedItem // ignore: cast_nullable_to_non_nullable
              as List<ContractValuedItem>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractAssetImpl extends _ContractAsset {
  const _$ContractAssetImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.scope,
      final List<CodeableConcept>? type,
      final List<Reference>? typeReference,
      final List<CodeableConcept>? subtype,
      this.relationship,
      final List<ContractContext>? context,
      this.condition,
      @JsonKey(name: '_condition') this.conditionElement,
      final List<CodeableConcept>? periodType,
      final List<Period>? period,
      final List<Period>? usePeriod,
      this.text,
      @JsonKey(name: '_text') this.textElement,
      final List<String>? linkId,
      @JsonKey(name: '_linkId') final List<Element>? linkIdElement,
      final List<ContractAnswer>? answer,
      final List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      final List<Element>? securityLabelNumberElement,
      final List<ContractValuedItem>? valuedItem})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _type = type,
        _typeReference = typeReference,
        _subtype = subtype,
        _context = context,
        _periodType = periodType,
        _period = period,
        _usePeriod = usePeriod,
        _linkId = linkId,
        _linkIdElement = linkIdElement,
        _answer = answer,
        _securityLabelNumber = securityLabelNumber,
        _securityLabelNumberElement = securityLabelNumberElement,
        _valuedItem = valuedItem,
        super._();

  factory _$ContractAssetImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractAssetImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [scope] Differentiates the kind of the asset .
  @override
  final CodeableConcept? scope;

  /// [type] Target entity type about which the term may be concerned.
  final List<CodeableConcept>? _type;

  /// [type] Target entity type about which the term may be concerned.
  @override
  List<CodeableConcept>? get type {
    final value = _type;
    if (value == null) return null;
    if (_type is EqualUnmodifiableListView) return _type;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [typeReference] Associated entities.
  final List<Reference>? _typeReference;

  /// [typeReference] Associated entities.
  @override
  List<Reference>? get typeReference {
    final value = _typeReference;
    if (value == null) return null;
    if (_typeReference is EqualUnmodifiableListView) return _typeReference;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [subtype] May be a subtype or part of an offered asset.
  final List<CodeableConcept>? _subtype;

  /// [subtype] May be a subtype or part of an offered asset.
  @override
  List<CodeableConcept>? get subtype {
    final value = _subtype;
    if (value == null) return null;
    if (_subtype is EqualUnmodifiableListView) return _subtype;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [relationship] Specifies the applicability of the term to an asset
  ///  resource instance, and instances it refers to or instances that refer
  ///  to it, and/or are owned by the offeree.
  @override
  final Coding? relationship;

  /// [context] Circumstance of the asset.
  final List<ContractContext>? _context;

  /// [context] Circumstance of the asset.
  @override
  List<ContractContext>? get context {
    final value = _context;
    if (value == null) return null;
    if (_context is EqualUnmodifiableListView) return _context;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [condition] Description of the quality and completeness of the asset
  ///  that may be a factor in its valuation.
  @override
  final String? condition;

  /// [conditionElement] ("_condition") Extensions for condition
  @override
  @JsonKey(name: '_condition')
  final Element? conditionElement;

  /// [periodType] Type of Asset availability for use or ownership.
  final List<CodeableConcept>? _periodType;

  /// [periodType] Type of Asset availability for use or ownership.
  @override
  List<CodeableConcept>? get periodType {
    final value = _periodType;
    if (value == null) return null;
    if (_periodType is EqualUnmodifiableListView) return _periodType;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [period] Asset relevant contractual time period.
  final List<Period>? _period;

  /// [period] Asset relevant contractual time period.
  @override
  List<Period>? get period {
    final value = _period;
    if (value == null) return null;
    if (_period is EqualUnmodifiableListView) return _period;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [usePeriod] Time period of asset use.
  final List<Period>? _usePeriod;

  /// [usePeriod] Time period of asset use.
  @override
  List<Period>? get usePeriod {
    final value = _usePeriod;
    if (value == null) return null;
    if (_usePeriod is EqualUnmodifiableListView) return _usePeriod;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [text] Clause or question text (Prose Object) concerning the asset in a
  ///  linked form, such as a QuestionnaireResponse used in the formation of
  ///  the contract.
  @override
  final String? text;

  /// [textElement] ("_text") Extensions for text
  @override
  @JsonKey(name: '_text')
  final Element? textElement;

  /// [linkId] Id [identifier??] of the clause or question text about the
  ///  asset in the referenced form or QuestionnaireResponse.
  final List<String>? _linkId;

  /// [linkId] Id [identifier??] of the clause or question text about the
  ///  asset in the referenced form or QuestionnaireResponse.
  @override
  List<String>? get linkId {
    final value = _linkId;
    if (value == null) return null;
    if (_linkId is EqualUnmodifiableListView) return _linkId;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [linkIdElement] ("_linkId") Extensions for linkId
  final List<Element>? _linkIdElement;

  /// [linkIdElement] ("_linkId") Extensions for linkId
  @override
  @JsonKey(name: '_linkId')
  List<Element>? get linkIdElement {
    final value = _linkIdElement;
    if (value == null) return null;
    if (_linkIdElement is EqualUnmodifiableListView) return _linkIdElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [answer] Response to assets.
  final List<ContractAnswer>? _answer;

  /// [answer] Response to assets.
  @override
  List<ContractAnswer>? get answer {
    final value = _answer;
    if (value == null) return null;
    if (_answer is EqualUnmodifiableListView) return _answer;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [securityLabelNumber] Security labels that protects the asset.
  final List<FhirUnsignedInt>? _securityLabelNumber;

  /// [securityLabelNumber] Security labels that protects the asset.
  @override
  List<FhirUnsignedInt>? get securityLabelNumber {
    final value = _securityLabelNumber;
    if (value == null) return null;
    if (_securityLabelNumber is EqualUnmodifiableListView)
      return _securityLabelNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  final List<Element>? _securityLabelNumberElement;

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  @override
  @JsonKey(name: '_securityLabelNumber')
  List<Element>? get securityLabelNumberElement {
    final value = _securityLabelNumberElement;
    if (value == null) return null;
    if (_securityLabelNumberElement is EqualUnmodifiableListView)
      return _securityLabelNumberElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [valuedItem] Contract Valued Item List.
  final List<ContractValuedItem>? _valuedItem;

  /// [valuedItem] Contract Valued Item List.
  @override
  List<ContractValuedItem>? get valuedItem {
    final value = _valuedItem;
    if (value == null) return null;
    if (_valuedItem is EqualUnmodifiableListView) return _valuedItem;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ContractAsset(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, scope: $scope, type: $type, typeReference: $typeReference, subtype: $subtype, relationship: $relationship, context: $context, condition: $condition, conditionElement: $conditionElement, periodType: $periodType, period: $period, usePeriod: $usePeriod, text: $text, textElement: $textElement, linkId: $linkId, linkIdElement: $linkIdElement, answer: $answer, securityLabelNumber: $securityLabelNumber, securityLabelNumberElement: $securityLabelNumberElement, valuedItem: $valuedItem)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractAssetImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.scope, scope) || other.scope == scope) &&
            const DeepCollectionEquality().equals(other._type, _type) &&
            const DeepCollectionEquality()
                .equals(other._typeReference, _typeReference) &&
            const DeepCollectionEquality().equals(other._subtype, _subtype) &&
            (identical(other.relationship, relationship) ||
                other.relationship == relationship) &&
            const DeepCollectionEquality().equals(other._context, _context) &&
            (identical(other.condition, condition) ||
                other.condition == condition) &&
            (identical(other.conditionElement, conditionElement) ||
                other.conditionElement == conditionElement) &&
            const DeepCollectionEquality()
                .equals(other._periodType, _periodType) &&
            const DeepCollectionEquality().equals(other._period, _period) &&
            const DeepCollectionEquality()
                .equals(other._usePeriod, _usePeriod) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.textElement, textElement) ||
                other.textElement == textElement) &&
            const DeepCollectionEquality().equals(other._linkId, _linkId) &&
            const DeepCollectionEquality()
                .equals(other._linkIdElement, _linkIdElement) &&
            const DeepCollectionEquality().equals(other._answer, _answer) &&
            const DeepCollectionEquality()
                .equals(other._securityLabelNumber, _securityLabelNumber) &&
            const DeepCollectionEquality().equals(
                other._securityLabelNumberElement,
                _securityLabelNumberElement) &&
            const DeepCollectionEquality()
                .equals(other._valuedItem, _valuedItem));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        scope,
        const DeepCollectionEquality().hash(_type),
        const DeepCollectionEquality().hash(_typeReference),
        const DeepCollectionEquality().hash(_subtype),
        relationship,
        const DeepCollectionEquality().hash(_context),
        condition,
        conditionElement,
        const DeepCollectionEquality().hash(_periodType),
        const DeepCollectionEquality().hash(_period),
        const DeepCollectionEquality().hash(_usePeriod),
        text,
        textElement,
        const DeepCollectionEquality().hash(_linkId),
        const DeepCollectionEquality().hash(_linkIdElement),
        const DeepCollectionEquality().hash(_answer),
        const DeepCollectionEquality().hash(_securityLabelNumber),
        const DeepCollectionEquality().hash(_securityLabelNumberElement),
        const DeepCollectionEquality().hash(_valuedItem)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractAssetImplCopyWith<_$ContractAssetImpl> get copyWith =>
      __$$ContractAssetImplCopyWithImpl<_$ContractAssetImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractAssetImplToJson(
      this,
    );
  }
}

abstract class _ContractAsset extends ContractAsset {
  const factory _ContractAsset(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? scope,
      final List<CodeableConcept>? type,
      final List<Reference>? typeReference,
      final List<CodeableConcept>? subtype,
      final Coding? relationship,
      final List<ContractContext>? context,
      final String? condition,
      @JsonKey(name: '_condition') final Element? conditionElement,
      final List<CodeableConcept>? periodType,
      final List<Period>? period,
      final List<Period>? usePeriod,
      final String? text,
      @JsonKey(name: '_text') final Element? textElement,
      final List<String>? linkId,
      @JsonKey(name: '_linkId') final List<Element>? linkIdElement,
      final List<ContractAnswer>? answer,
      final List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      final List<Element>? securityLabelNumberElement,
      final List<ContractValuedItem>? valuedItem}) = _$ContractAssetImpl;
  const _ContractAsset._() : super._();

  factory _ContractAsset.fromJson(Map<String, dynamic> json) =
      _$ContractAssetImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [scope] Differentiates the kind of the asset .
  CodeableConcept? get scope;
  @override

  /// [type] Target entity type about which the term may be concerned.
  List<CodeableConcept>? get type;
  @override

  /// [typeReference] Associated entities.
  List<Reference>? get typeReference;
  @override

  /// [subtype] May be a subtype or part of an offered asset.
  List<CodeableConcept>? get subtype;
  @override

  /// [relationship] Specifies the applicability of the term to an asset
  ///  resource instance, and instances it refers to or instances that refer
  ///  to it, and/or are owned by the offeree.
  Coding? get relationship;
  @override

  /// [context] Circumstance of the asset.
  List<ContractContext>? get context;
  @override

  /// [condition] Description of the quality and completeness of the asset
  ///  that may be a factor in its valuation.
  String? get condition;
  @override

  /// [conditionElement] ("_condition") Extensions for condition
  @JsonKey(name: '_condition')
  Element? get conditionElement;
  @override

  /// [periodType] Type of Asset availability for use or ownership.
  List<CodeableConcept>? get periodType;
  @override

  /// [period] Asset relevant contractual time period.
  List<Period>? get period;
  @override

  /// [usePeriod] Time period of asset use.
  List<Period>? get usePeriod;
  @override

  /// [text] Clause or question text (Prose Object) concerning the asset in a
  ///  linked form, such as a QuestionnaireResponse used in the formation of
  ///  the contract.
  String? get text;
  @override

  /// [textElement] ("_text") Extensions for text
  @JsonKey(name: '_text')
  Element? get textElement;
  @override

  /// [linkId] Id [identifier??] of the clause or question text about the
  ///  asset in the referenced form or QuestionnaireResponse.
  List<String>? get linkId;
  @override

  /// [linkIdElement] ("_linkId") Extensions for linkId
  @JsonKey(name: '_linkId')
  List<Element>? get linkIdElement;
  @override

  /// [answer] Response to assets.
  List<ContractAnswer>? get answer;
  @override

  /// [securityLabelNumber] Security labels that protects the asset.
  List<FhirUnsignedInt>? get securityLabelNumber;
  @override

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  @JsonKey(name: '_securityLabelNumber')
  List<Element>? get securityLabelNumberElement;
  @override

  /// [valuedItem] Contract Valued Item List.
  List<ContractValuedItem>? get valuedItem;
  @override
  @JsonKey(ignore: true)
  _$$ContractAssetImplCopyWith<_$ContractAssetImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractContext _$ContractContextFromJson(Map<String, dynamic> json) {
  return _ContractContext.fromJson(json);
}

/// @nodoc
mixin _$ContractContext {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [reference] Asset context reference may include the creator, custodian,
  ///  or owning Person or Organization (e.g., bank, repository),  location
  ///  held, e.g., building,  jurisdiction.
  Reference? get reference => throw _privateConstructorUsedError;

  /// [code] Coded representation of the context generally or of the
  ///  Referenced entity, such as the asset holder type or location.
  List<CodeableConcept>? get code => throw _privateConstructorUsedError;

  /// [text] Context description.
  String? get text => throw _privateConstructorUsedError;

  /// [textElement] ("_text") Extensions for text
  @JsonKey(name: '_text')
  Element? get textElement => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractContextCopyWith<ContractContext> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractContextCopyWith<$Res> {
  factory $ContractContextCopyWith(
          ContractContext value, $Res Function(ContractContext) then) =
      _$ContractContextCopyWithImpl<$Res, ContractContext>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference? reference,
      List<CodeableConcept>? code,
      String? text,
      @JsonKey(name: '_text') Element? textElement});

  $ReferenceCopyWith<$Res>? get reference;
  $ElementCopyWith<$Res>? get textElement;
}

/// @nodoc
class _$ContractContextCopyWithImpl<$Res, $Val extends ContractContext>
    implements $ContractContextCopyWith<$Res> {
  _$ContractContextCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? reference = freezed,
    Object? code = freezed,
    Object? text = freezed,
    Object? textElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      reference: freezed == reference
          ? _value.reference
          : reference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      textElement: freezed == textElement
          ? _value.textElement
          : textElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get reference {
    if (_value.reference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.reference!, (value) {
      return _then(_value.copyWith(reference: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get textElement {
    if (_value.textElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.textElement!, (value) {
      return _then(_value.copyWith(textElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractContextImplCopyWith<$Res>
    implements $ContractContextCopyWith<$Res> {
  factory _$$ContractContextImplCopyWith(_$ContractContextImpl value,
          $Res Function(_$ContractContextImpl) then) =
      __$$ContractContextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference? reference,
      List<CodeableConcept>? code,
      String? text,
      @JsonKey(name: '_text') Element? textElement});

  @override
  $ReferenceCopyWith<$Res>? get reference;
  @override
  $ElementCopyWith<$Res>? get textElement;
}

/// @nodoc
class __$$ContractContextImplCopyWithImpl<$Res>
    extends _$ContractContextCopyWithImpl<$Res, _$ContractContextImpl>
    implements _$$ContractContextImplCopyWith<$Res> {
  __$$ContractContextImplCopyWithImpl(
      _$ContractContextImpl _value, $Res Function(_$ContractContextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? reference = freezed,
    Object? code = freezed,
    Object? text = freezed,
    Object? textElement = freezed,
  }) {
    return _then(_$ContractContextImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      reference: freezed == reference
          ? _value.reference
          : reference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      code: freezed == code
          ? _value._code
          : code // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      textElement: freezed == textElement
          ? _value.textElement
          : textElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractContextImpl extends _ContractContext {
  const _$ContractContextImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.reference,
      final List<CodeableConcept>? code,
      this.text,
      @JsonKey(name: '_text') this.textElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _code = code,
        super._();

  factory _$ContractContextImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractContextImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reference] Asset context reference may include the creator, custodian,
  ///  or owning Person or Organization (e.g., bank, repository),  location
  ///  held, e.g., building,  jurisdiction.
  @override
  final Reference? reference;

  /// [code] Coded representation of the context generally or of the
  ///  Referenced entity, such as the asset holder type or location.
  final List<CodeableConcept>? _code;

  /// [code] Coded representation of the context generally or of the
  ///  Referenced entity, such as the asset holder type or location.
  @override
  List<CodeableConcept>? get code {
    final value = _code;
    if (value == null) return null;
    if (_code is EqualUnmodifiableListView) return _code;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [text] Context description.
  @override
  final String? text;

  /// [textElement] ("_text") Extensions for text
  @override
  @JsonKey(name: '_text')
  final Element? textElement;

  @override
  String toString() {
    return 'ContractContext(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, reference: $reference, code: $code, text: $text, textElement: $textElement)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractContextImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.reference, reference) ||
                other.reference == reference) &&
            const DeepCollectionEquality().equals(other._code, _code) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.textElement, textElement) ||
                other.textElement == textElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      reference,
      const DeepCollectionEquality().hash(_code),
      text,
      textElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractContextImplCopyWith<_$ContractContextImpl> get copyWith =>
      __$$ContractContextImplCopyWithImpl<_$ContractContextImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractContextImplToJson(
      this,
    );
  }
}

abstract class _ContractContext extends ContractContext {
  const factory _ContractContext(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final Reference? reference,
          final List<CodeableConcept>? code,
          final String? text,
          @JsonKey(name: '_text') final Element? textElement}) =
      _$ContractContextImpl;
  const _ContractContext._() : super._();

  factory _ContractContext.fromJson(Map<String, dynamic> json) =
      _$ContractContextImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [reference] Asset context reference may include the creator, custodian,
  ///  or owning Person or Organization (e.g., bank, repository),  location
  ///  held, e.g., building,  jurisdiction.
  Reference? get reference;
  @override

  /// [code] Coded representation of the context generally or of the
  ///  Referenced entity, such as the asset holder type or location.
  List<CodeableConcept>? get code;
  @override

  /// [text] Context description.
  String? get text;
  @override

  /// [textElement] ("_text") Extensions for text
  @JsonKey(name: '_text')
  Element? get textElement;
  @override
  @JsonKey(ignore: true)
  _$$ContractContextImplCopyWith<_$ContractContextImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractValuedItem _$ContractValuedItemFromJson(Map<String, dynamic> json) {
  return _ContractValuedItem.fromJson(json);
}

/// @nodoc
mixin _$ContractValuedItem {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [entityCodeableConcept] Specific type of Contract Valued Item that may
  ///  be priced.
  CodeableConcept? get entityCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [entityReference] Specific type of Contract Valued Item that may be
  ///  priced.
  Reference? get entityReference => throw _privateConstructorUsedError;

  /// [identifier] Identifies a Contract Valued Item instance.
  Identifier? get identifier => throw _privateConstructorUsedError;

  /// [effectiveTime] Indicates the time during which this Contract
  ///  ValuedItem information is effective.
  FhirDateTime? get effectiveTime => throw _privateConstructorUsedError;

  /// [effectiveTimeElement] ("_effectiveTime") Extensions for effectiveTime
  @JsonKey(name: '_effectiveTime')
  Element? get effectiveTimeElement => throw _privateConstructorUsedError;

  /// [quantity] Specifies the units by which the Contract Valued Item is
  ///  measured or counted, and quantifies the countable or measurable
  ///  Contract Valued Item instances.
  Quantity? get quantity => throw _privateConstructorUsedError;

  /// [unitPrice] A Contract Valued Item unit valuation measure.
  Money? get unitPrice => throw _privateConstructorUsedError;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of the Contract Valued Item delivered. The concept
  ///  of a Factor allows for a discount or surcharge multiplier to be
  ///  applied to a monetary amount.
  FhirDecimal? get factor => throw _privateConstructorUsedError;

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement => throw _privateConstructorUsedError;

  /// [points] An amount that expresses the weighting (based on difficulty,
  ///  cost and/or resource intensiveness) associated with the Contract
  ///  Valued Item delivered. The concept of Points allows for assignment of
  ///  point values for a Contract Valued Item, such that a monetary amount
  ///  can be assigned to each point.
  FhirDecimal? get points => throw _privateConstructorUsedError;

  /// [pointsElement] ("_points") Extensions for points
  @JsonKey(name: '_points')
  Element? get pointsElement => throw _privateConstructorUsedError;

  /// [net] Expresses the product of the Contract Valued Item unitQuantity
  ///  and the unitPriceAmt. For example, the formula: unit Quantity * unit
  ///  Price (Cost per Point) * factor Number  * points = net Amount.
  ///  Quantity, factor and points are assumed to be 1 if not supplied.
  Money? get net => throw _privateConstructorUsedError;

  /// [payment] Terms of valuation.
  String? get payment => throw _privateConstructorUsedError;

  /// [paymentElement] ("_payment") Extensions for payment
  @JsonKey(name: '_payment')
  Element? get paymentElement => throw _privateConstructorUsedError;

  /// [paymentDate] When payment is due.
  FhirDateTime? get paymentDate => throw _privateConstructorUsedError;

  /// [paymentDateElement] ("_paymentDate") Extensions for paymentDate
  @JsonKey(name: '_paymentDate')
  Element? get paymentDateElement => throw _privateConstructorUsedError;

  /// [responsible] Who will make payment.
  Reference? get responsible => throw _privateConstructorUsedError;

  /// [recipient] Who will receive payment.
  Reference? get recipient => throw _privateConstructorUsedError;

  /// [linkId] Id  of the clause or question text related to the context of
  ///  this valuedItem in the referenced form or QuestionnaireResponse.
  List<String>? get linkId => throw _privateConstructorUsedError;

  /// [linkIdElement] ("_linkId") Extensions for linkId
  @JsonKey(name: '_linkId')
  List<Element>? get linkIdElement => throw _privateConstructorUsedError;

  /// [securityLabelNumber] A set of security labels that define which terms
  ///  are controlled by this condition.
  List<FhirUnsignedInt>? get securityLabelNumber =>
      throw _privateConstructorUsedError;

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  @JsonKey(name: '_securityLabelNumber')
  List<Element>? get securityLabelNumberElement =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractValuedItemCopyWith<ContractValuedItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractValuedItemCopyWith<$Res> {
  factory $ContractValuedItemCopyWith(
          ContractValuedItem value, $Res Function(ContractValuedItem) then) =
      _$ContractValuedItemCopyWithImpl<$Res, ContractValuedItem>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? entityCodeableConcept,
      Reference? entityReference,
      Identifier? identifier,
      FhirDateTime? effectiveTime,
      @JsonKey(name: '_effectiveTime') Element? effectiveTimeElement,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      FhirDecimal? points,
      @JsonKey(name: '_points') Element? pointsElement,
      Money? net,
      String? payment,
      @JsonKey(name: '_payment') Element? paymentElement,
      FhirDateTime? paymentDate,
      @JsonKey(name: '_paymentDate') Element? paymentDateElement,
      Reference? responsible,
      Reference? recipient,
      List<String>? linkId,
      @JsonKey(name: '_linkId') List<Element>? linkIdElement,
      List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      List<Element>? securityLabelNumberElement});

  $CodeableConceptCopyWith<$Res>? get entityCodeableConcept;
  $ReferenceCopyWith<$Res>? get entityReference;
  $IdentifierCopyWith<$Res>? get identifier;
  $ElementCopyWith<$Res>? get effectiveTimeElement;
  $QuantityCopyWith<$Res>? get quantity;
  $MoneyCopyWith<$Res>? get unitPrice;
  $ElementCopyWith<$Res>? get factorElement;
  $ElementCopyWith<$Res>? get pointsElement;
  $MoneyCopyWith<$Res>? get net;
  $ElementCopyWith<$Res>? get paymentElement;
  $ElementCopyWith<$Res>? get paymentDateElement;
  $ReferenceCopyWith<$Res>? get responsible;
  $ReferenceCopyWith<$Res>? get recipient;
}

/// @nodoc
class _$ContractValuedItemCopyWithImpl<$Res, $Val extends ContractValuedItem>
    implements $ContractValuedItemCopyWith<$Res> {
  _$ContractValuedItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? entityCodeableConcept = freezed,
    Object? entityReference = freezed,
    Object? identifier = freezed,
    Object? effectiveTime = freezed,
    Object? effectiveTimeElement = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? points = freezed,
    Object? pointsElement = freezed,
    Object? net = freezed,
    Object? payment = freezed,
    Object? paymentElement = freezed,
    Object? paymentDate = freezed,
    Object? paymentDateElement = freezed,
    Object? responsible = freezed,
    Object? recipient = freezed,
    Object? linkId = freezed,
    Object? linkIdElement = freezed,
    Object? securityLabelNumber = freezed,
    Object? securityLabelNumberElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      entityCodeableConcept: freezed == entityCodeableConcept
          ? _value.entityCodeableConcept
          : entityCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      entityReference: freezed == entityReference
          ? _value.entityReference
          : entityReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      effectiveTime: freezed == effectiveTime
          ? _value.effectiveTime
          : effectiveTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      effectiveTimeElement: freezed == effectiveTimeElement
          ? _value.effectiveTimeElement
          : effectiveTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      points: freezed == points
          ? _value.points
          : points // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      pointsElement: freezed == pointsElement
          ? _value.pointsElement
          : pointsElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      payment: freezed == payment
          ? _value.payment
          : payment // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentElement: freezed == paymentElement
          ? _value.paymentElement
          : paymentElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      paymentDate: freezed == paymentDate
          ? _value.paymentDate
          : paymentDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      paymentDateElement: freezed == paymentDateElement
          ? _value.paymentDateElement
          : paymentDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      responsible: freezed == responsible
          ? _value.responsible
          : responsible // ignore: cast_nullable_to_non_nullable
              as Reference?,
      recipient: freezed == recipient
          ? _value.recipient
          : recipient // ignore: cast_nullable_to_non_nullable
              as Reference?,
      linkId: freezed == linkId
          ? _value.linkId
          : linkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      linkIdElement: freezed == linkIdElement
          ? _value.linkIdElement
          : linkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      securityLabelNumber: freezed == securityLabelNumber
          ? _value.securityLabelNumber
          : securityLabelNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirUnsignedInt>?,
      securityLabelNumberElement: freezed == securityLabelNumberElement
          ? _value.securityLabelNumberElement
          : securityLabelNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get entityCodeableConcept {
    if (_value.entityCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.entityCodeableConcept!,
        (value) {
      return _then(_value.copyWith(entityCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get entityReference {
    if (_value.entityReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.entityReference!, (value) {
      return _then(_value.copyWith(entityReference: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get effectiveTimeElement {
    if (_value.effectiveTimeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.effectiveTimeElement!, (value) {
      return _then(_value.copyWith(effectiveTimeElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get quantity {
    if (_value.quantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.quantity!, (value) {
      return _then(_value.copyWith(quantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get unitPrice {
    if (_value.unitPrice == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.unitPrice!, (value) {
      return _then(_value.copyWith(unitPrice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get factorElement {
    if (_value.factorElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.factorElement!, (value) {
      return _then(_value.copyWith(factorElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get pointsElement {
    if (_value.pointsElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.pointsElement!, (value) {
      return _then(_value.copyWith(pointsElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get net {
    if (_value.net == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.net!, (value) {
      return _then(_value.copyWith(net: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get paymentElement {
    if (_value.paymentElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.paymentElement!, (value) {
      return _then(_value.copyWith(paymentElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get paymentDateElement {
    if (_value.paymentDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.paymentDateElement!, (value) {
      return _then(_value.copyWith(paymentDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get responsible {
    if (_value.responsible == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.responsible!, (value) {
      return _then(_value.copyWith(responsible: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get recipient {
    if (_value.recipient == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.recipient!, (value) {
      return _then(_value.copyWith(recipient: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractValuedItemImplCopyWith<$Res>
    implements $ContractValuedItemCopyWith<$Res> {
  factory _$$ContractValuedItemImplCopyWith(_$ContractValuedItemImpl value,
          $Res Function(_$ContractValuedItemImpl) then) =
      __$$ContractValuedItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? entityCodeableConcept,
      Reference? entityReference,
      Identifier? identifier,
      FhirDateTime? effectiveTime,
      @JsonKey(name: '_effectiveTime') Element? effectiveTimeElement,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      FhirDecimal? points,
      @JsonKey(name: '_points') Element? pointsElement,
      Money? net,
      String? payment,
      @JsonKey(name: '_payment') Element? paymentElement,
      FhirDateTime? paymentDate,
      @JsonKey(name: '_paymentDate') Element? paymentDateElement,
      Reference? responsible,
      Reference? recipient,
      List<String>? linkId,
      @JsonKey(name: '_linkId') List<Element>? linkIdElement,
      List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      List<Element>? securityLabelNumberElement});

  @override
  $CodeableConceptCopyWith<$Res>? get entityCodeableConcept;
  @override
  $ReferenceCopyWith<$Res>? get entityReference;
  @override
  $IdentifierCopyWith<$Res>? get identifier;
  @override
  $ElementCopyWith<$Res>? get effectiveTimeElement;
  @override
  $QuantityCopyWith<$Res>? get quantity;
  @override
  $MoneyCopyWith<$Res>? get unitPrice;
  @override
  $ElementCopyWith<$Res>? get factorElement;
  @override
  $ElementCopyWith<$Res>? get pointsElement;
  @override
  $MoneyCopyWith<$Res>? get net;
  @override
  $ElementCopyWith<$Res>? get paymentElement;
  @override
  $ElementCopyWith<$Res>? get paymentDateElement;
  @override
  $ReferenceCopyWith<$Res>? get responsible;
  @override
  $ReferenceCopyWith<$Res>? get recipient;
}

/// @nodoc
class __$$ContractValuedItemImplCopyWithImpl<$Res>
    extends _$ContractValuedItemCopyWithImpl<$Res, _$ContractValuedItemImpl>
    implements _$$ContractValuedItemImplCopyWith<$Res> {
  __$$ContractValuedItemImplCopyWithImpl(_$ContractValuedItemImpl _value,
      $Res Function(_$ContractValuedItemImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? entityCodeableConcept = freezed,
    Object? entityReference = freezed,
    Object? identifier = freezed,
    Object? effectiveTime = freezed,
    Object? effectiveTimeElement = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? points = freezed,
    Object? pointsElement = freezed,
    Object? net = freezed,
    Object? payment = freezed,
    Object? paymentElement = freezed,
    Object? paymentDate = freezed,
    Object? paymentDateElement = freezed,
    Object? responsible = freezed,
    Object? recipient = freezed,
    Object? linkId = freezed,
    Object? linkIdElement = freezed,
    Object? securityLabelNumber = freezed,
    Object? securityLabelNumberElement = freezed,
  }) {
    return _then(_$ContractValuedItemImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      entityCodeableConcept: freezed == entityCodeableConcept
          ? _value.entityCodeableConcept
          : entityCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      entityReference: freezed == entityReference
          ? _value.entityReference
          : entityReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      effectiveTime: freezed == effectiveTime
          ? _value.effectiveTime
          : effectiveTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      effectiveTimeElement: freezed == effectiveTimeElement
          ? _value.effectiveTimeElement
          : effectiveTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      points: freezed == points
          ? _value.points
          : points // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      pointsElement: freezed == pointsElement
          ? _value.pointsElement
          : pointsElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      payment: freezed == payment
          ? _value.payment
          : payment // ignore: cast_nullable_to_non_nullable
              as String?,
      paymentElement: freezed == paymentElement
          ? _value.paymentElement
          : paymentElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      paymentDate: freezed == paymentDate
          ? _value.paymentDate
          : paymentDate // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      paymentDateElement: freezed == paymentDateElement
          ? _value.paymentDateElement
          : paymentDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      responsible: freezed == responsible
          ? _value.responsible
          : responsible // ignore: cast_nullable_to_non_nullable
              as Reference?,
      recipient: freezed == recipient
          ? _value.recipient
          : recipient // ignore: cast_nullable_to_non_nullable
              as Reference?,
      linkId: freezed == linkId
          ? _value._linkId
          : linkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      linkIdElement: freezed == linkIdElement
          ? _value._linkIdElement
          : linkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      securityLabelNumber: freezed == securityLabelNumber
          ? _value._securityLabelNumber
          : securityLabelNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirUnsignedInt>?,
      securityLabelNumberElement: freezed == securityLabelNumberElement
          ? _value._securityLabelNumberElement
          : securityLabelNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractValuedItemImpl extends _ContractValuedItem {
  const _$ContractValuedItemImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.entityCodeableConcept,
      this.entityReference,
      this.identifier,
      this.effectiveTime,
      @JsonKey(name: '_effectiveTime') this.effectiveTimeElement,
      this.quantity,
      this.unitPrice,
      this.factor,
      @JsonKey(name: '_factor') this.factorElement,
      this.points,
      @JsonKey(name: '_points') this.pointsElement,
      this.net,
      this.payment,
      @JsonKey(name: '_payment') this.paymentElement,
      this.paymentDate,
      @JsonKey(name: '_paymentDate') this.paymentDateElement,
      this.responsible,
      this.recipient,
      final List<String>? linkId,
      @JsonKey(name: '_linkId') final List<Element>? linkIdElement,
      final List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      final List<Element>? securityLabelNumberElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _linkId = linkId,
        _linkIdElement = linkIdElement,
        _securityLabelNumber = securityLabelNumber,
        _securityLabelNumberElement = securityLabelNumberElement,
        super._();

  factory _$ContractValuedItemImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractValuedItemImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [entityCodeableConcept] Specific type of Contract Valued Item that may
  ///  be priced.
  @override
  final CodeableConcept? entityCodeableConcept;

  /// [entityReference] Specific type of Contract Valued Item that may be
  ///  priced.
  @override
  final Reference? entityReference;

  /// [identifier] Identifies a Contract Valued Item instance.
  @override
  final Identifier? identifier;

  /// [effectiveTime] Indicates the time during which this Contract
  ///  ValuedItem information is effective.
  @override
  final FhirDateTime? effectiveTime;

  /// [effectiveTimeElement] ("_effectiveTime") Extensions for effectiveTime
  @override
  @JsonKey(name: '_effectiveTime')
  final Element? effectiveTimeElement;

  /// [quantity] Specifies the units by which the Contract Valued Item is
  ///  measured or counted, and quantifies the countable or measurable
  ///  Contract Valued Item instances.
  @override
  final Quantity? quantity;

  /// [unitPrice] A Contract Valued Item unit valuation measure.
  @override
  final Money? unitPrice;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of the Contract Valued Item delivered. The concept
  ///  of a Factor allows for a discount or surcharge multiplier to be
  ///  applied to a monetary amount.
  @override
  final FhirDecimal? factor;

  /// [factorElement] ("_factor") Extensions for factor
  @override
  @JsonKey(name: '_factor')
  final Element? factorElement;

  /// [points] An amount that expresses the weighting (based on difficulty,
  ///  cost and/or resource intensiveness) associated with the Contract
  ///  Valued Item delivered. The concept of Points allows for assignment of
  ///  point values for a Contract Valued Item, such that a monetary amount
  ///  can be assigned to each point.
  @override
  final FhirDecimal? points;

  /// [pointsElement] ("_points") Extensions for points
  @override
  @JsonKey(name: '_points')
  final Element? pointsElement;

  /// [net] Expresses the product of the Contract Valued Item unitQuantity
  ///  and the unitPriceAmt. For example, the formula: unit Quantity * unit
  ///  Price (Cost per Point) * factor Number  * points = net Amount.
  ///  Quantity, factor and points are assumed to be 1 if not supplied.
  @override
  final Money? net;

  /// [payment] Terms of valuation.
  @override
  final String? payment;

  /// [paymentElement] ("_payment") Extensions for payment
  @override
  @JsonKey(name: '_payment')
  final Element? paymentElement;

  /// [paymentDate] When payment is due.
  @override
  final FhirDateTime? paymentDate;

  /// [paymentDateElement] ("_paymentDate") Extensions for paymentDate
  @override
  @JsonKey(name: '_paymentDate')
  final Element? paymentDateElement;

  /// [responsible] Who will make payment.
  @override
  final Reference? responsible;

  /// [recipient] Who will receive payment.
  @override
  final Reference? recipient;

  /// [linkId] Id  of the clause or question text related to the context of
  ///  this valuedItem in the referenced form or QuestionnaireResponse.
  final List<String>? _linkId;

  /// [linkId] Id  of the clause or question text related to the context of
  ///  this valuedItem in the referenced form or QuestionnaireResponse.
  @override
  List<String>? get linkId {
    final value = _linkId;
    if (value == null) return null;
    if (_linkId is EqualUnmodifiableListView) return _linkId;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [linkIdElement] ("_linkId") Extensions for linkId
  final List<Element>? _linkIdElement;

  /// [linkIdElement] ("_linkId") Extensions for linkId
  @override
  @JsonKey(name: '_linkId')
  List<Element>? get linkIdElement {
    final value = _linkIdElement;
    if (value == null) return null;
    if (_linkIdElement is EqualUnmodifiableListView) return _linkIdElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [securityLabelNumber] A set of security labels that define which terms
  ///  are controlled by this condition.
  final List<FhirUnsignedInt>? _securityLabelNumber;

  /// [securityLabelNumber] A set of security labels that define which terms
  ///  are controlled by this condition.
  @override
  List<FhirUnsignedInt>? get securityLabelNumber {
    final value = _securityLabelNumber;
    if (value == null) return null;
    if (_securityLabelNumber is EqualUnmodifiableListView)
      return _securityLabelNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  final List<Element>? _securityLabelNumberElement;

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  @override
  @JsonKey(name: '_securityLabelNumber')
  List<Element>? get securityLabelNumberElement {
    final value = _securityLabelNumberElement;
    if (value == null) return null;
    if (_securityLabelNumberElement is EqualUnmodifiableListView)
      return _securityLabelNumberElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ContractValuedItem(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, entityCodeableConcept: $entityCodeableConcept, entityReference: $entityReference, identifier: $identifier, effectiveTime: $effectiveTime, effectiveTimeElement: $effectiveTimeElement, quantity: $quantity, unitPrice: $unitPrice, factor: $factor, factorElement: $factorElement, points: $points, pointsElement: $pointsElement, net: $net, payment: $payment, paymentElement: $paymentElement, paymentDate: $paymentDate, paymentDateElement: $paymentDateElement, responsible: $responsible, recipient: $recipient, linkId: $linkId, linkIdElement: $linkIdElement, securityLabelNumber: $securityLabelNumber, securityLabelNumberElement: $securityLabelNumberElement)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractValuedItemImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.entityCodeableConcept, entityCodeableConcept) ||
                other.entityCodeableConcept == entityCodeableConcept) &&
            (identical(other.entityReference, entityReference) ||
                other.entityReference == entityReference) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier) &&
            (identical(other.effectiveTime, effectiveTime) ||
                other.effectiveTime == effectiveTime) &&
            (identical(other.effectiveTimeElement, effectiveTimeElement) ||
                other.effectiveTimeElement == effectiveTimeElement) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.unitPrice, unitPrice) ||
                other.unitPrice == unitPrice) &&
            (identical(other.factor, factor) || other.factor == factor) &&
            (identical(other.factorElement, factorElement) ||
                other.factorElement == factorElement) &&
            (identical(other.points, points) || other.points == points) &&
            (identical(other.pointsElement, pointsElement) ||
                other.pointsElement == pointsElement) &&
            (identical(other.net, net) || other.net == net) &&
            (identical(other.payment, payment) || other.payment == payment) &&
            (identical(other.paymentElement, paymentElement) ||
                other.paymentElement == paymentElement) &&
            (identical(other.paymentDate, paymentDate) ||
                other.paymentDate == paymentDate) &&
            (identical(other.paymentDateElement, paymentDateElement) ||
                other.paymentDateElement == paymentDateElement) &&
            (identical(other.responsible, responsible) ||
                other.responsible == responsible) &&
            (identical(other.recipient, recipient) ||
                other.recipient == recipient) &&
            const DeepCollectionEquality().equals(other._linkId, _linkId) &&
            const DeepCollectionEquality()
                .equals(other._linkIdElement, _linkIdElement) &&
            const DeepCollectionEquality()
                .equals(other._securityLabelNumber, _securityLabelNumber) &&
            const DeepCollectionEquality().equals(
                other._securityLabelNumberElement,
                _securityLabelNumberElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        entityCodeableConcept,
        entityReference,
        identifier,
        effectiveTime,
        effectiveTimeElement,
        quantity,
        unitPrice,
        factor,
        factorElement,
        points,
        pointsElement,
        net,
        payment,
        paymentElement,
        paymentDate,
        paymentDateElement,
        responsible,
        recipient,
        const DeepCollectionEquality().hash(_linkId),
        const DeepCollectionEquality().hash(_linkIdElement),
        const DeepCollectionEquality().hash(_securityLabelNumber),
        const DeepCollectionEquality().hash(_securityLabelNumberElement)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractValuedItemImplCopyWith<_$ContractValuedItemImpl> get copyWith =>
      __$$ContractValuedItemImplCopyWithImpl<_$ContractValuedItemImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractValuedItemImplToJson(
      this,
    );
  }
}

abstract class _ContractValuedItem extends ContractValuedItem {
  const factory _ContractValuedItem(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? entityCodeableConcept,
          final Reference? entityReference,
          final Identifier? identifier,
          final FhirDateTime? effectiveTime,
          @JsonKey(name: '_effectiveTime') final Element? effectiveTimeElement,
          final Quantity? quantity,
          final Money? unitPrice,
          final FhirDecimal? factor,
          @JsonKey(name: '_factor') final Element? factorElement,
          final FhirDecimal? points,
          @JsonKey(name: '_points') final Element? pointsElement,
          final Money? net,
          final String? payment,
          @JsonKey(name: '_payment') final Element? paymentElement,
          final FhirDateTime? paymentDate,
          @JsonKey(name: '_paymentDate') final Element? paymentDateElement,
          final Reference? responsible,
          final Reference? recipient,
          final List<String>? linkId,
          @JsonKey(name: '_linkId') final List<Element>? linkIdElement,
          final List<FhirUnsignedInt>? securityLabelNumber,
          @JsonKey(name: '_securityLabelNumber')
          final List<Element>? securityLabelNumberElement}) =
      _$ContractValuedItemImpl;
  const _ContractValuedItem._() : super._();

  factory _ContractValuedItem.fromJson(Map<String, dynamic> json) =
      _$ContractValuedItemImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [entityCodeableConcept] Specific type of Contract Valued Item that may
  ///  be priced.
  CodeableConcept? get entityCodeableConcept;
  @override

  /// [entityReference] Specific type of Contract Valued Item that may be
  ///  priced.
  Reference? get entityReference;
  @override

  /// [identifier] Identifies a Contract Valued Item instance.
  Identifier? get identifier;
  @override

  /// [effectiveTime] Indicates the time during which this Contract
  ///  ValuedItem information is effective.
  FhirDateTime? get effectiveTime;
  @override

  /// [effectiveTimeElement] ("_effectiveTime") Extensions for effectiveTime
  @JsonKey(name: '_effectiveTime')
  Element? get effectiveTimeElement;
  @override

  /// [quantity] Specifies the units by which the Contract Valued Item is
  ///  measured or counted, and quantifies the countable or measurable
  ///  Contract Valued Item instances.
  Quantity? get quantity;
  @override

  /// [unitPrice] A Contract Valued Item unit valuation measure.
  Money? get unitPrice;
  @override

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of the Contract Valued Item delivered. The concept
  ///  of a Factor allows for a discount or surcharge multiplier to be
  ///  applied to a monetary amount.
  FhirDecimal? get factor;
  @override

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement;
  @override

  /// [points] An amount that expresses the weighting (based on difficulty,
  ///  cost and/or resource intensiveness) associated with the Contract
  ///  Valued Item delivered. The concept of Points allows for assignment of
  ///  point values for a Contract Valued Item, such that a monetary amount
  ///  can be assigned to each point.
  FhirDecimal? get points;
  @override

  /// [pointsElement] ("_points") Extensions for points
  @JsonKey(name: '_points')
  Element? get pointsElement;
  @override

  /// [net] Expresses the product of the Contract Valued Item unitQuantity
  ///  and the unitPriceAmt. For example, the formula: unit Quantity * unit
  ///  Price (Cost per Point) * factor Number  * points = net Amount.
  ///  Quantity, factor and points are assumed to be 1 if not supplied.
  Money? get net;
  @override

  /// [payment] Terms of valuation.
  String? get payment;
  @override

  /// [paymentElement] ("_payment") Extensions for payment
  @JsonKey(name: '_payment')
  Element? get paymentElement;
  @override

  /// [paymentDate] When payment is due.
  FhirDateTime? get paymentDate;
  @override

  /// [paymentDateElement] ("_paymentDate") Extensions for paymentDate
  @JsonKey(name: '_paymentDate')
  Element? get paymentDateElement;
  @override

  /// [responsible] Who will make payment.
  Reference? get responsible;
  @override

  /// [recipient] Who will receive payment.
  Reference? get recipient;
  @override

  /// [linkId] Id  of the clause or question text related to the context of
  ///  this valuedItem in the referenced form or QuestionnaireResponse.
  List<String>? get linkId;
  @override

  /// [linkIdElement] ("_linkId") Extensions for linkId
  @JsonKey(name: '_linkId')
  List<Element>? get linkIdElement;
  @override

  /// [securityLabelNumber] A set of security labels that define which terms
  ///  are controlled by this condition.
  List<FhirUnsignedInt>? get securityLabelNumber;
  @override

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  @JsonKey(name: '_securityLabelNumber')
  List<Element>? get securityLabelNumberElement;
  @override
  @JsonKey(ignore: true)
  _$$ContractValuedItemImplCopyWith<_$ContractValuedItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractAction _$ContractActionFromJson(Map<String, dynamic> json) {
  return _ContractAction.fromJson(json);
}

/// @nodoc
mixin _$ContractAction {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [doNotPerform] True if the term prohibits the  action.
  FhirBoolean? get doNotPerform => throw _privateConstructorUsedError;

  /// [doNotPerformElement] ("_doNotPerform") Extensions for doNotPerform
  @JsonKey(name: '_doNotPerform')
  Element? get doNotPerformElement => throw _privateConstructorUsedError;

  /// [type] Activity or service obligation to be done or not done, performed
  ///  or not performed, effectuated or not by this Contract term.
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [subject] Entity of the action.
  List<ContractSubject>? get subject => throw _privateConstructorUsedError;

  /// [intent] Reason or purpose for the action stipulated by this Contract
  ///  Provision.
  CodeableConcept get intent => throw _privateConstructorUsedError;

  /// [linkId] Id [identifier??] of the clause or question text related to
  ///  this action in the referenced form or QuestionnaireResponse.
  List<String>? get linkId => throw _privateConstructorUsedError;

  /// [linkIdElement] ("_linkId") Extensions for linkId
  @JsonKey(name: '_linkId')
  List<Element>? get linkIdElement => throw _privateConstructorUsedError;

  /// [status] Current state of the term action.
  CodeableConcept get status => throw _privateConstructorUsedError;

  /// [context] Encounter or Episode with primary association to the
  ///  specified term activity.
  Reference? get context => throw _privateConstructorUsedError;

  /// [contextLinkId] Id [identifier??] of the clause or question text
  ///  related to the requester of this action in the referenced form or
  ///  QuestionnaireResponse.
  List<String>? get contextLinkId => throw _privateConstructorUsedError;

  /// [contextLinkIdElement] ("_contextLinkId") Extensions for contextLinkId
  @JsonKey(name: '_contextLinkId')
  List<Element>? get contextLinkIdElement => throw _privateConstructorUsedError;

  /// [occurrenceDateTime] When action happens.
  FhirDateTime? get occurrenceDateTime => throw _privateConstructorUsedError;

  /// [occurrenceDateTimeElement] ("_occurrenceDateTime") Extensions for
  ///  occurrenceDateTime
  @JsonKey(name: '_occurrenceDateTime')
  Element? get occurrenceDateTimeElement => throw _privateConstructorUsedError;

  /// [occurrencePeriod] When action happens.
  Period? get occurrencePeriod => throw _privateConstructorUsedError;

  /// [occurrenceTiming] When action happens.
  Timing? get occurrenceTiming => throw _privateConstructorUsedError;

  /// [requester] Who or what initiated the action and has responsibility for
  ///  its activation.
  List<Reference>? get requester => throw _privateConstructorUsedError;

  /// [requesterLinkId] Id [identifier??] of the clause or question text
  ///  related to the requester of this action in the referenced form or
  ///  QuestionnaireResponse.
  List<String>? get requesterLinkId => throw _privateConstructorUsedError;

  /// [requesterLinkIdElement] ("_requesterLinkId") Extensions for
  ///  requesterLinkId
  @JsonKey(name: '_requesterLinkId')
  List<Element>? get requesterLinkIdElement =>
      throw _privateConstructorUsedError;

  /// [performerType] The type of individual that is desired or required to
  ///  perform or not perform the action.
  List<CodeableConcept>? get performerType =>
      throw _privateConstructorUsedError;

  /// [performerRole] The type of role or competency of an individual desired
  ///  or required to perform or not perform the action.
  CodeableConcept? get performerRole => throw _privateConstructorUsedError;

  /// [performer] Indicates who or what is being asked to perform (or not
  ///  perform) the ction.
  Reference? get performer => throw _privateConstructorUsedError;

  /// [performerLinkId] Id [identifier??] of the clause or question text
  ///  related to the reason type or reference of this  action in the
  ///  referenced form or QuestionnaireResponse.
  List<String>? get performerLinkId => throw _privateConstructorUsedError;

  /// [performerLinkIdElement] ("_performerLinkId") Extensions for
  ///  performerLinkId
  @JsonKey(name: '_performerLinkId')
  List<Element>? get performerLinkIdElement =>
      throw _privateConstructorUsedError;

  /// [reason] Rationale for the action to be performed or not performed.
  ///  Describes why the action is permitted or prohibited. Either a coded
  ///  concept, or another resource whose existence justifies permitting or
  ///  not permitting this action.
  List<CodeableReference>? get reason => throw _privateConstructorUsedError;

  /// [reasonLinkId] Id [identifier??] of the clause or question text related
  ///  to the reason type or reference of this  action in the referenced form
  ///  or QuestionnaireResponse.
  List<String>? get reasonLinkId => throw _privateConstructorUsedError;

  /// [reasonLinkIdElement] ("_reasonLinkId") Extensions for reasonLinkId
  @JsonKey(name: '_reasonLinkId')
  List<Element>? get reasonLinkIdElement => throw _privateConstructorUsedError;

  /// [note] Comments made about the term action made by the requester,
  ///  performer, subject or other participants.
  List<Annotation>? get note => throw _privateConstructorUsedError;

  /// [securityLabelNumber] Security labels that protects the action.
  List<FhirUnsignedInt>? get securityLabelNumber =>
      throw _privateConstructorUsedError;

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  @JsonKey(name: '_securityLabelNumber')
  List<Element>? get securityLabelNumberElement =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractActionCopyWith<ContractAction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractActionCopyWith<$Res> {
  factory $ContractActionCopyWith(
          ContractAction value, $Res Function(ContractAction) then) =
      _$ContractActionCopyWithImpl<$Res, ContractAction>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirBoolean? doNotPerform,
      @JsonKey(name: '_doNotPerform') Element? doNotPerformElement,
      CodeableConcept type,
      List<ContractSubject>? subject,
      CodeableConcept intent,
      List<String>? linkId,
      @JsonKey(name: '_linkId') List<Element>? linkIdElement,
      CodeableConcept status,
      Reference? context,
      List<String>? contextLinkId,
      @JsonKey(name: '_contextLinkId') List<Element>? contextLinkIdElement,
      FhirDateTime? occurrenceDateTime,
      @JsonKey(name: '_occurrenceDateTime') Element? occurrenceDateTimeElement,
      Period? occurrencePeriod,
      Timing? occurrenceTiming,
      List<Reference>? requester,
      List<String>? requesterLinkId,
      @JsonKey(name: '_requesterLinkId') List<Element>? requesterLinkIdElement,
      List<CodeableConcept>? performerType,
      CodeableConcept? performerRole,
      Reference? performer,
      List<String>? performerLinkId,
      @JsonKey(name: '_performerLinkId') List<Element>? performerLinkIdElement,
      List<CodeableReference>? reason,
      List<String>? reasonLinkId,
      @JsonKey(name: '_reasonLinkId') List<Element>? reasonLinkIdElement,
      List<Annotation>? note,
      List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      List<Element>? securityLabelNumberElement});

  $ElementCopyWith<$Res>? get doNotPerformElement;
  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res> get intent;
  $CodeableConceptCopyWith<$Res> get status;
  $ReferenceCopyWith<$Res>? get context;
  $ElementCopyWith<$Res>? get occurrenceDateTimeElement;
  $PeriodCopyWith<$Res>? get occurrencePeriod;
  $TimingCopyWith<$Res>? get occurrenceTiming;
  $CodeableConceptCopyWith<$Res>? get performerRole;
  $ReferenceCopyWith<$Res>? get performer;
}

/// @nodoc
class _$ContractActionCopyWithImpl<$Res, $Val extends ContractAction>
    implements $ContractActionCopyWith<$Res> {
  _$ContractActionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? doNotPerform = freezed,
    Object? doNotPerformElement = freezed,
    Object? type = null,
    Object? subject = freezed,
    Object? intent = null,
    Object? linkId = freezed,
    Object? linkIdElement = freezed,
    Object? status = null,
    Object? context = freezed,
    Object? contextLinkId = freezed,
    Object? contextLinkIdElement = freezed,
    Object? occurrenceDateTime = freezed,
    Object? occurrenceDateTimeElement = freezed,
    Object? occurrencePeriod = freezed,
    Object? occurrenceTiming = freezed,
    Object? requester = freezed,
    Object? requesterLinkId = freezed,
    Object? requesterLinkIdElement = freezed,
    Object? performerType = freezed,
    Object? performerRole = freezed,
    Object? performer = freezed,
    Object? performerLinkId = freezed,
    Object? performerLinkIdElement = freezed,
    Object? reason = freezed,
    Object? reasonLinkId = freezed,
    Object? reasonLinkIdElement = freezed,
    Object? note = freezed,
    Object? securityLabelNumber = freezed,
    Object? securityLabelNumberElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      doNotPerform: freezed == doNotPerform
          ? _value.doNotPerform
          : doNotPerform // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      doNotPerformElement: freezed == doNotPerformElement
          ? _value.doNotPerformElement
          : doNotPerformElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      subject: freezed == subject
          ? _value.subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<ContractSubject>?,
      intent: null == intent
          ? _value.intent
          : intent // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      linkId: freezed == linkId
          ? _value.linkId
          : linkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      linkIdElement: freezed == linkIdElement
          ? _value.linkIdElement
          : linkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      context: freezed == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as Reference?,
      contextLinkId: freezed == contextLinkId
          ? _value.contextLinkId
          : contextLinkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      contextLinkIdElement: freezed == contextLinkIdElement
          ? _value.contextLinkIdElement
          : contextLinkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      occurrenceDateTime: freezed == occurrenceDateTime
          ? _value.occurrenceDateTime
          : occurrenceDateTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      occurrenceDateTimeElement: freezed == occurrenceDateTimeElement
          ? _value.occurrenceDateTimeElement
          : occurrenceDateTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      occurrencePeriod: freezed == occurrencePeriod
          ? _value.occurrencePeriod
          : occurrencePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      occurrenceTiming: freezed == occurrenceTiming
          ? _value.occurrenceTiming
          : occurrenceTiming // ignore: cast_nullable_to_non_nullable
              as Timing?,
      requester: freezed == requester
          ? _value.requester
          : requester // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      requesterLinkId: freezed == requesterLinkId
          ? _value.requesterLinkId
          : requesterLinkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      requesterLinkIdElement: freezed == requesterLinkIdElement
          ? _value.requesterLinkIdElement
          : requesterLinkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      performerType: freezed == performerType
          ? _value.performerType
          : performerType // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      performerRole: freezed == performerRole
          ? _value.performerRole
          : performerRole // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      performer: freezed == performer
          ? _value.performer
          : performer // ignore: cast_nullable_to_non_nullable
              as Reference?,
      performerLinkId: freezed == performerLinkId
          ? _value.performerLinkId
          : performerLinkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      performerLinkIdElement: freezed == performerLinkIdElement
          ? _value.performerLinkIdElement
          : performerLinkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      reasonLinkId: freezed == reasonLinkId
          ? _value.reasonLinkId
          : reasonLinkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      reasonLinkIdElement: freezed == reasonLinkIdElement
          ? _value.reasonLinkIdElement
          : reasonLinkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      note: freezed == note
          ? _value.note
          : note // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      securityLabelNumber: freezed == securityLabelNumber
          ? _value.securityLabelNumber
          : securityLabelNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirUnsignedInt>?,
      securityLabelNumberElement: freezed == securityLabelNumberElement
          ? _value.securityLabelNumberElement
          : securityLabelNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get doNotPerformElement {
    if (_value.doNotPerformElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.doNotPerformElement!, (value) {
      return _then(_value.copyWith(doNotPerformElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get intent {
    return $CodeableConceptCopyWith<$Res>(_value.intent, (value) {
      return _then(_value.copyWith(intent: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get status {
    return $CodeableConceptCopyWith<$Res>(_value.status, (value) {
      return _then(_value.copyWith(status: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get context {
    if (_value.context == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.context!, (value) {
      return _then(_value.copyWith(context: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get occurrenceDateTimeElement {
    if (_value.occurrenceDateTimeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.occurrenceDateTimeElement!, (value) {
      return _then(_value.copyWith(occurrenceDateTimeElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get occurrencePeriod {
    if (_value.occurrencePeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.occurrencePeriod!, (value) {
      return _then(_value.copyWith(occurrencePeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TimingCopyWith<$Res>? get occurrenceTiming {
    if (_value.occurrenceTiming == null) {
      return null;
    }

    return $TimingCopyWith<$Res>(_value.occurrenceTiming!, (value) {
      return _then(_value.copyWith(occurrenceTiming: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get performerRole {
    if (_value.performerRole == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.performerRole!, (value) {
      return _then(_value.copyWith(performerRole: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get performer {
    if (_value.performer == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.performer!, (value) {
      return _then(_value.copyWith(performer: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractActionImplCopyWith<$Res>
    implements $ContractActionCopyWith<$Res> {
  factory _$$ContractActionImplCopyWith(_$ContractActionImpl value,
          $Res Function(_$ContractActionImpl) then) =
      __$$ContractActionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirBoolean? doNotPerform,
      @JsonKey(name: '_doNotPerform') Element? doNotPerformElement,
      CodeableConcept type,
      List<ContractSubject>? subject,
      CodeableConcept intent,
      List<String>? linkId,
      @JsonKey(name: '_linkId') List<Element>? linkIdElement,
      CodeableConcept status,
      Reference? context,
      List<String>? contextLinkId,
      @JsonKey(name: '_contextLinkId') List<Element>? contextLinkIdElement,
      FhirDateTime? occurrenceDateTime,
      @JsonKey(name: '_occurrenceDateTime') Element? occurrenceDateTimeElement,
      Period? occurrencePeriod,
      Timing? occurrenceTiming,
      List<Reference>? requester,
      List<String>? requesterLinkId,
      @JsonKey(name: '_requesterLinkId') List<Element>? requesterLinkIdElement,
      List<CodeableConcept>? performerType,
      CodeableConcept? performerRole,
      Reference? performer,
      List<String>? performerLinkId,
      @JsonKey(name: '_performerLinkId') List<Element>? performerLinkIdElement,
      List<CodeableReference>? reason,
      List<String>? reasonLinkId,
      @JsonKey(name: '_reasonLinkId') List<Element>? reasonLinkIdElement,
      List<Annotation>? note,
      List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      List<Element>? securityLabelNumberElement});

  @override
  $ElementCopyWith<$Res>? get doNotPerformElement;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res> get intent;
  @override
  $CodeableConceptCopyWith<$Res> get status;
  @override
  $ReferenceCopyWith<$Res>? get context;
  @override
  $ElementCopyWith<$Res>? get occurrenceDateTimeElement;
  @override
  $PeriodCopyWith<$Res>? get occurrencePeriod;
  @override
  $TimingCopyWith<$Res>? get occurrenceTiming;
  @override
  $CodeableConceptCopyWith<$Res>? get performerRole;
  @override
  $ReferenceCopyWith<$Res>? get performer;
}

/// @nodoc
class __$$ContractActionImplCopyWithImpl<$Res>
    extends _$ContractActionCopyWithImpl<$Res, _$ContractActionImpl>
    implements _$$ContractActionImplCopyWith<$Res> {
  __$$ContractActionImplCopyWithImpl(
      _$ContractActionImpl _value, $Res Function(_$ContractActionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? doNotPerform = freezed,
    Object? doNotPerformElement = freezed,
    Object? type = null,
    Object? subject = freezed,
    Object? intent = null,
    Object? linkId = freezed,
    Object? linkIdElement = freezed,
    Object? status = null,
    Object? context = freezed,
    Object? contextLinkId = freezed,
    Object? contextLinkIdElement = freezed,
    Object? occurrenceDateTime = freezed,
    Object? occurrenceDateTimeElement = freezed,
    Object? occurrencePeriod = freezed,
    Object? occurrenceTiming = freezed,
    Object? requester = freezed,
    Object? requesterLinkId = freezed,
    Object? requesterLinkIdElement = freezed,
    Object? performerType = freezed,
    Object? performerRole = freezed,
    Object? performer = freezed,
    Object? performerLinkId = freezed,
    Object? performerLinkIdElement = freezed,
    Object? reason = freezed,
    Object? reasonLinkId = freezed,
    Object? reasonLinkIdElement = freezed,
    Object? note = freezed,
    Object? securityLabelNumber = freezed,
    Object? securityLabelNumberElement = freezed,
  }) {
    return _then(_$ContractActionImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      doNotPerform: freezed == doNotPerform
          ? _value.doNotPerform
          : doNotPerform // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      doNotPerformElement: freezed == doNotPerformElement
          ? _value.doNotPerformElement
          : doNotPerformElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      subject: freezed == subject
          ? _value._subject
          : subject // ignore: cast_nullable_to_non_nullable
              as List<ContractSubject>?,
      intent: null == intent
          ? _value.intent
          : intent // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      linkId: freezed == linkId
          ? _value._linkId
          : linkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      linkIdElement: freezed == linkIdElement
          ? _value._linkIdElement
          : linkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      context: freezed == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as Reference?,
      contextLinkId: freezed == contextLinkId
          ? _value._contextLinkId
          : contextLinkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      contextLinkIdElement: freezed == contextLinkIdElement
          ? _value._contextLinkIdElement
          : contextLinkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      occurrenceDateTime: freezed == occurrenceDateTime
          ? _value.occurrenceDateTime
          : occurrenceDateTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      occurrenceDateTimeElement: freezed == occurrenceDateTimeElement
          ? _value.occurrenceDateTimeElement
          : occurrenceDateTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      occurrencePeriod: freezed == occurrencePeriod
          ? _value.occurrencePeriod
          : occurrencePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      occurrenceTiming: freezed == occurrenceTiming
          ? _value.occurrenceTiming
          : occurrenceTiming // ignore: cast_nullable_to_non_nullable
              as Timing?,
      requester: freezed == requester
          ? _value._requester
          : requester // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      requesterLinkId: freezed == requesterLinkId
          ? _value._requesterLinkId
          : requesterLinkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      requesterLinkIdElement: freezed == requesterLinkIdElement
          ? _value._requesterLinkIdElement
          : requesterLinkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      performerType: freezed == performerType
          ? _value._performerType
          : performerType // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      performerRole: freezed == performerRole
          ? _value.performerRole
          : performerRole // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      performer: freezed == performer
          ? _value.performer
          : performer // ignore: cast_nullable_to_non_nullable
              as Reference?,
      performerLinkId: freezed == performerLinkId
          ? _value._performerLinkId
          : performerLinkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      performerLinkIdElement: freezed == performerLinkIdElement
          ? _value._performerLinkIdElement
          : performerLinkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reason: freezed == reason
          ? _value._reason
          : reason // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>?,
      reasonLinkId: freezed == reasonLinkId
          ? _value._reasonLinkId
          : reasonLinkId // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      reasonLinkIdElement: freezed == reasonLinkIdElement
          ? _value._reasonLinkIdElement
          : reasonLinkIdElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      note: freezed == note
          ? _value._note
          : note // ignore: cast_nullable_to_non_nullable
              as List<Annotation>?,
      securityLabelNumber: freezed == securityLabelNumber
          ? _value._securityLabelNumber
          : securityLabelNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirUnsignedInt>?,
      securityLabelNumberElement: freezed == securityLabelNumberElement
          ? _value._securityLabelNumberElement
          : securityLabelNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractActionImpl extends _ContractAction {
  const _$ContractActionImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.doNotPerform,
      @JsonKey(name: '_doNotPerform') this.doNotPerformElement,
      required this.type,
      final List<ContractSubject>? subject,
      required this.intent,
      final List<String>? linkId,
      @JsonKey(name: '_linkId') final List<Element>? linkIdElement,
      required this.status,
      this.context,
      final List<String>? contextLinkId,
      @JsonKey(name: '_contextLinkId')
      final List<Element>? contextLinkIdElement,
      this.occurrenceDateTime,
      @JsonKey(name: '_occurrenceDateTime') this.occurrenceDateTimeElement,
      this.occurrencePeriod,
      this.occurrenceTiming,
      final List<Reference>? requester,
      final List<String>? requesterLinkId,
      @JsonKey(name: '_requesterLinkId')
      final List<Element>? requesterLinkIdElement,
      final List<CodeableConcept>? performerType,
      this.performerRole,
      this.performer,
      final List<String>? performerLinkId,
      @JsonKey(name: '_performerLinkId')
      final List<Element>? performerLinkIdElement,
      final List<CodeableReference>? reason,
      final List<String>? reasonLinkId,
      @JsonKey(name: '_reasonLinkId') final List<Element>? reasonLinkIdElement,
      final List<Annotation>? note,
      final List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      final List<Element>? securityLabelNumberElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _subject = subject,
        _linkId = linkId,
        _linkIdElement = linkIdElement,
        _contextLinkId = contextLinkId,
        _contextLinkIdElement = contextLinkIdElement,
        _requester = requester,
        _requesterLinkId = requesterLinkId,
        _requesterLinkIdElement = requesterLinkIdElement,
        _performerType = performerType,
        _performerLinkId = performerLinkId,
        _performerLinkIdElement = performerLinkIdElement,
        _reason = reason,
        _reasonLinkId = reasonLinkId,
        _reasonLinkIdElement = reasonLinkIdElement,
        _note = note,
        _securityLabelNumber = securityLabelNumber,
        _securityLabelNumberElement = securityLabelNumberElement,
        super._();

  factory _$ContractActionImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractActionImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [doNotPerform] True if the term prohibits the  action.
  @override
  final FhirBoolean? doNotPerform;

  /// [doNotPerformElement] ("_doNotPerform") Extensions for doNotPerform
  @override
  @JsonKey(name: '_doNotPerform')
  final Element? doNotPerformElement;

  /// [type] Activity or service obligation to be done or not done, performed
  ///  or not performed, effectuated or not by this Contract term.
  @override
  final CodeableConcept type;

  /// [subject] Entity of the action.
  final List<ContractSubject>? _subject;

  /// [subject] Entity of the action.
  @override
  List<ContractSubject>? get subject {
    final value = _subject;
    if (value == null) return null;
    if (_subject is EqualUnmodifiableListView) return _subject;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [intent] Reason or purpose for the action stipulated by this Contract
  ///  Provision.
  @override
  final CodeableConcept intent;

  /// [linkId] Id [identifier??] of the clause or question text related to
  ///  this action in the referenced form or QuestionnaireResponse.
  final List<String>? _linkId;

  /// [linkId] Id [identifier??] of the clause or question text related to
  ///  this action in the referenced form or QuestionnaireResponse.
  @override
  List<String>? get linkId {
    final value = _linkId;
    if (value == null) return null;
    if (_linkId is EqualUnmodifiableListView) return _linkId;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [linkIdElement] ("_linkId") Extensions for linkId
  final List<Element>? _linkIdElement;

  /// [linkIdElement] ("_linkId") Extensions for linkId
  @override
  @JsonKey(name: '_linkId')
  List<Element>? get linkIdElement {
    final value = _linkIdElement;
    if (value == null) return null;
    if (_linkIdElement is EqualUnmodifiableListView) return _linkIdElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] Current state of the term action.
  @override
  final CodeableConcept status;

  /// [context] Encounter or Episode with primary association to the
  ///  specified term activity.
  @override
  final Reference? context;

  /// [contextLinkId] Id [identifier??] of the clause or question text
  ///  related to the requester of this action in the referenced form or
  ///  QuestionnaireResponse.
  final List<String>? _contextLinkId;

  /// [contextLinkId] Id [identifier??] of the clause or question text
  ///  related to the requester of this action in the referenced form or
  ///  QuestionnaireResponse.
  @override
  List<String>? get contextLinkId {
    final value = _contextLinkId;
    if (value == null) return null;
    if (_contextLinkId is EqualUnmodifiableListView) return _contextLinkId;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [contextLinkIdElement] ("_contextLinkId") Extensions for contextLinkId
  final List<Element>? _contextLinkIdElement;

  /// [contextLinkIdElement] ("_contextLinkId") Extensions for contextLinkId
  @override
  @JsonKey(name: '_contextLinkId')
  List<Element>? get contextLinkIdElement {
    final value = _contextLinkIdElement;
    if (value == null) return null;
    if (_contextLinkIdElement is EqualUnmodifiableListView)
      return _contextLinkIdElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [occurrenceDateTime] When action happens.
  @override
  final FhirDateTime? occurrenceDateTime;

  /// [occurrenceDateTimeElement] ("_occurrenceDateTime") Extensions for
  ///  occurrenceDateTime
  @override
  @JsonKey(name: '_occurrenceDateTime')
  final Element? occurrenceDateTimeElement;

  /// [occurrencePeriod] When action happens.
  @override
  final Period? occurrencePeriod;

  /// [occurrenceTiming] When action happens.
  @override
  final Timing? occurrenceTiming;

  /// [requester] Who or what initiated the action and has responsibility for
  ///  its activation.
  final List<Reference>? _requester;

  /// [requester] Who or what initiated the action and has responsibility for
  ///  its activation.
  @override
  List<Reference>? get requester {
    final value = _requester;
    if (value == null) return null;
    if (_requester is EqualUnmodifiableListView) return _requester;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [requesterLinkId] Id [identifier??] of the clause or question text
  ///  related to the requester of this action in the referenced form or
  ///  QuestionnaireResponse.
  final List<String>? _requesterLinkId;

  /// [requesterLinkId] Id [identifier??] of the clause or question text
  ///  related to the requester of this action in the referenced form or
  ///  QuestionnaireResponse.
  @override
  List<String>? get requesterLinkId {
    final value = _requesterLinkId;
    if (value == null) return null;
    if (_requesterLinkId is EqualUnmodifiableListView) return _requesterLinkId;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [requesterLinkIdElement] ("_requesterLinkId") Extensions for
  ///  requesterLinkId
  final List<Element>? _requesterLinkIdElement;

  /// [requesterLinkIdElement] ("_requesterLinkId") Extensions for
  ///  requesterLinkId
  @override
  @JsonKey(name: '_requesterLinkId')
  List<Element>? get requesterLinkIdElement {
    final value = _requesterLinkIdElement;
    if (value == null) return null;
    if (_requesterLinkIdElement is EqualUnmodifiableListView)
      return _requesterLinkIdElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [performerType] The type of individual that is desired or required to
  ///  perform or not perform the action.
  final List<CodeableConcept>? _performerType;

  /// [performerType] The type of individual that is desired or required to
  ///  perform or not perform the action.
  @override
  List<CodeableConcept>? get performerType {
    final value = _performerType;
    if (value == null) return null;
    if (_performerType is EqualUnmodifiableListView) return _performerType;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [performerRole] The type of role or competency of an individual desired
  ///  or required to perform or not perform the action.
  @override
  final CodeableConcept? performerRole;

  /// [performer] Indicates who or what is being asked to perform (or not
  ///  perform) the ction.
  @override
  final Reference? performer;

  /// [performerLinkId] Id [identifier??] of the clause or question text
  ///  related to the reason type or reference of this  action in the
  ///  referenced form or QuestionnaireResponse.
  final List<String>? _performerLinkId;

  /// [performerLinkId] Id [identifier??] of the clause or question text
  ///  related to the reason type or reference of this  action in the
  ///  referenced form or QuestionnaireResponse.
  @override
  List<String>? get performerLinkId {
    final value = _performerLinkId;
    if (value == null) return null;
    if (_performerLinkId is EqualUnmodifiableListView) return _performerLinkId;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [performerLinkIdElement] ("_performerLinkId") Extensions for
  ///  performerLinkId
  final List<Element>? _performerLinkIdElement;

  /// [performerLinkIdElement] ("_performerLinkId") Extensions for
  ///  performerLinkId
  @override
  @JsonKey(name: '_performerLinkId')
  List<Element>? get performerLinkIdElement {
    final value = _performerLinkIdElement;
    if (value == null) return null;
    if (_performerLinkIdElement is EqualUnmodifiableListView)
      return _performerLinkIdElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reason] Rationale for the action to be performed or not performed.
  ///  Describes why the action is permitted or prohibited. Either a coded
  ///  concept, or another resource whose existence justifies permitting or
  ///  not permitting this action.
  final List<CodeableReference>? _reason;

  /// [reason] Rationale for the action to be performed or not performed.
  ///  Describes why the action is permitted or prohibited. Either a coded
  ///  concept, or another resource whose existence justifies permitting or
  ///  not permitting this action.
  @override
  List<CodeableReference>? get reason {
    final value = _reason;
    if (value == null) return null;
    if (_reason is EqualUnmodifiableListView) return _reason;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reasonLinkId] Id [identifier??] of the clause or question text related
  ///  to the reason type or reference of this  action in the referenced form
  ///  or QuestionnaireResponse.
  final List<String>? _reasonLinkId;

  /// [reasonLinkId] Id [identifier??] of the clause or question text related
  ///  to the reason type or reference of this  action in the referenced form
  ///  or QuestionnaireResponse.
  @override
  List<String>? get reasonLinkId {
    final value = _reasonLinkId;
    if (value == null) return null;
    if (_reasonLinkId is EqualUnmodifiableListView) return _reasonLinkId;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reasonLinkIdElement] ("_reasonLinkId") Extensions for reasonLinkId
  final List<Element>? _reasonLinkIdElement;

  /// [reasonLinkIdElement] ("_reasonLinkId") Extensions for reasonLinkId
  @override
  @JsonKey(name: '_reasonLinkId')
  List<Element>? get reasonLinkIdElement {
    final value = _reasonLinkIdElement;
    if (value == null) return null;
    if (_reasonLinkIdElement is EqualUnmodifiableListView)
      return _reasonLinkIdElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [note] Comments made about the term action made by the requester,
  ///  performer, subject or other participants.
  final List<Annotation>? _note;

  /// [note] Comments made about the term action made by the requester,
  ///  performer, subject or other participants.
  @override
  List<Annotation>? get note {
    final value = _note;
    if (value == null) return null;
    if (_note is EqualUnmodifiableListView) return _note;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [securityLabelNumber] Security labels that protects the action.
  final List<FhirUnsignedInt>? _securityLabelNumber;

  /// [securityLabelNumber] Security labels that protects the action.
  @override
  List<FhirUnsignedInt>? get securityLabelNumber {
    final value = _securityLabelNumber;
    if (value == null) return null;
    if (_securityLabelNumber is EqualUnmodifiableListView)
      return _securityLabelNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  final List<Element>? _securityLabelNumberElement;

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  @override
  @JsonKey(name: '_securityLabelNumber')
  List<Element>? get securityLabelNumberElement {
    final value = _securityLabelNumberElement;
    if (value == null) return null;
    if (_securityLabelNumberElement is EqualUnmodifiableListView)
      return _securityLabelNumberElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ContractAction(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, doNotPerform: $doNotPerform, doNotPerformElement: $doNotPerformElement, type: $type, subject: $subject, intent: $intent, linkId: $linkId, linkIdElement: $linkIdElement, status: $status, context: $context, contextLinkId: $contextLinkId, contextLinkIdElement: $contextLinkIdElement, occurrenceDateTime: $occurrenceDateTime, occurrenceDateTimeElement: $occurrenceDateTimeElement, occurrencePeriod: $occurrencePeriod, occurrenceTiming: $occurrenceTiming, requester: $requester, requesterLinkId: $requesterLinkId, requesterLinkIdElement: $requesterLinkIdElement, performerType: $performerType, performerRole: $performerRole, performer: $performer, performerLinkId: $performerLinkId, performerLinkIdElement: $performerLinkIdElement, reason: $reason, reasonLinkId: $reasonLinkId, reasonLinkIdElement: $reasonLinkIdElement, note: $note, securityLabelNumber: $securityLabelNumber, securityLabelNumberElement: $securityLabelNumberElement)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractActionImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.doNotPerform, doNotPerform) ||
                other.doNotPerform == doNotPerform) &&
            (identical(other.doNotPerformElement, doNotPerformElement) ||
                other.doNotPerformElement == doNotPerformElement) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality().equals(other._subject, _subject) &&
            (identical(other.intent, intent) || other.intent == intent) &&
            const DeepCollectionEquality().equals(other._linkId, _linkId) &&
            const DeepCollectionEquality()
                .equals(other._linkIdElement, _linkIdElement) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.context, context) || other.context == context) &&
            const DeepCollectionEquality()
                .equals(other._contextLinkId, _contextLinkId) &&
            const DeepCollectionEquality()
                .equals(other._contextLinkIdElement, _contextLinkIdElement) &&
            (identical(other.occurrenceDateTime, occurrenceDateTime) ||
                other.occurrenceDateTime == occurrenceDateTime) &&
            (identical(other.occurrenceDateTimeElement,
                    occurrenceDateTimeElement) ||
                other.occurrenceDateTimeElement == occurrenceDateTimeElement) &&
            (identical(other.occurrencePeriod, occurrencePeriod) ||
                other.occurrencePeriod == occurrencePeriod) &&
            (identical(other.occurrenceTiming, occurrenceTiming) ||
                other.occurrenceTiming == occurrenceTiming) &&
            const DeepCollectionEquality()
                .equals(other._requester, _requester) &&
            const DeepCollectionEquality()
                .equals(other._requesterLinkId, _requesterLinkId) &&
            const DeepCollectionEquality().equals(
                other._requesterLinkIdElement, _requesterLinkIdElement) &&
            const DeepCollectionEquality()
                .equals(other._performerType, _performerType) &&
            (identical(other.performerRole, performerRole) ||
                other.performerRole == performerRole) &&
            (identical(other.performer, performer) ||
                other.performer == performer) &&
            const DeepCollectionEquality()
                .equals(other._performerLinkId, _performerLinkId) &&
            const DeepCollectionEquality().equals(
                other._performerLinkIdElement, _performerLinkIdElement) &&
            const DeepCollectionEquality().equals(other._reason, _reason) &&
            const DeepCollectionEquality()
                .equals(other._reasonLinkId, _reasonLinkId) &&
            const DeepCollectionEquality()
                .equals(other._reasonLinkIdElement, _reasonLinkIdElement) &&
            const DeepCollectionEquality().equals(other._note, _note) &&
            const DeepCollectionEquality()
                .equals(other._securityLabelNumber, _securityLabelNumber) &&
            const DeepCollectionEquality().equals(
                other._securityLabelNumberElement,
                _securityLabelNumberElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        doNotPerform,
        doNotPerformElement,
        type,
        const DeepCollectionEquality().hash(_subject),
        intent,
        const DeepCollectionEquality().hash(_linkId),
        const DeepCollectionEquality().hash(_linkIdElement),
        status,
        context,
        const DeepCollectionEquality().hash(_contextLinkId),
        const DeepCollectionEquality().hash(_contextLinkIdElement),
        occurrenceDateTime,
        occurrenceDateTimeElement,
        occurrencePeriod,
        occurrenceTiming,
        const DeepCollectionEquality().hash(_requester),
        const DeepCollectionEquality().hash(_requesterLinkId),
        const DeepCollectionEquality().hash(_requesterLinkIdElement),
        const DeepCollectionEquality().hash(_performerType),
        performerRole,
        performer,
        const DeepCollectionEquality().hash(_performerLinkId),
        const DeepCollectionEquality().hash(_performerLinkIdElement),
        const DeepCollectionEquality().hash(_reason),
        const DeepCollectionEquality().hash(_reasonLinkId),
        const DeepCollectionEquality().hash(_reasonLinkIdElement),
        const DeepCollectionEquality().hash(_note),
        const DeepCollectionEquality().hash(_securityLabelNumber),
        const DeepCollectionEquality().hash(_securityLabelNumberElement)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractActionImplCopyWith<_$ContractActionImpl> get copyWith =>
      __$$ContractActionImplCopyWithImpl<_$ContractActionImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractActionImplToJson(
      this,
    );
  }
}

abstract class _ContractAction extends ContractAction {
  const factory _ContractAction(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final FhirBoolean? doNotPerform,
      @JsonKey(name: '_doNotPerform') final Element? doNotPerformElement,
      required final CodeableConcept type,
      final List<ContractSubject>? subject,
      required final CodeableConcept intent,
      final List<String>? linkId,
      @JsonKey(name: '_linkId') final List<Element>? linkIdElement,
      required final CodeableConcept status,
      final Reference? context,
      final List<String>? contextLinkId,
      @JsonKey(name: '_contextLinkId')
      final List<Element>? contextLinkIdElement,
      final FhirDateTime? occurrenceDateTime,
      @JsonKey(name: '_occurrenceDateTime')
      final Element? occurrenceDateTimeElement,
      final Period? occurrencePeriod,
      final Timing? occurrenceTiming,
      final List<Reference>? requester,
      final List<String>? requesterLinkId,
      @JsonKey(name: '_requesterLinkId')
      final List<Element>? requesterLinkIdElement,
      final List<CodeableConcept>? performerType,
      final CodeableConcept? performerRole,
      final Reference? performer,
      final List<String>? performerLinkId,
      @JsonKey(name: '_performerLinkId')
      final List<Element>? performerLinkIdElement,
      final List<CodeableReference>? reason,
      final List<String>? reasonLinkId,
      @JsonKey(name: '_reasonLinkId') final List<Element>? reasonLinkIdElement,
      final List<Annotation>? note,
      final List<FhirUnsignedInt>? securityLabelNumber,
      @JsonKey(name: '_securityLabelNumber')
      final List<Element>? securityLabelNumberElement}) = _$ContractActionImpl;
  const _ContractAction._() : super._();

  factory _ContractAction.fromJson(Map<String, dynamic> json) =
      _$ContractActionImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [doNotPerform] True if the term prohibits the  action.
  FhirBoolean? get doNotPerform;
  @override

  /// [doNotPerformElement] ("_doNotPerform") Extensions for doNotPerform
  @JsonKey(name: '_doNotPerform')
  Element? get doNotPerformElement;
  @override

  /// [type] Activity or service obligation to be done or not done, performed
  ///  or not performed, effectuated or not by this Contract term.
  CodeableConcept get type;
  @override

  /// [subject] Entity of the action.
  List<ContractSubject>? get subject;
  @override

  /// [intent] Reason or purpose for the action stipulated by this Contract
  ///  Provision.
  CodeableConcept get intent;
  @override

  /// [linkId] Id [identifier??] of the clause or question text related to
  ///  this action in the referenced form or QuestionnaireResponse.
  List<String>? get linkId;
  @override

  /// [linkIdElement] ("_linkId") Extensions for linkId
  @JsonKey(name: '_linkId')
  List<Element>? get linkIdElement;
  @override

  /// [status] Current state of the term action.
  CodeableConcept get status;
  @override

  /// [context] Encounter or Episode with primary association to the
  ///  specified term activity.
  Reference? get context;
  @override

  /// [contextLinkId] Id [identifier??] of the clause or question text
  ///  related to the requester of this action in the referenced form or
  ///  QuestionnaireResponse.
  List<String>? get contextLinkId;
  @override

  /// [contextLinkIdElement] ("_contextLinkId") Extensions for contextLinkId
  @JsonKey(name: '_contextLinkId')
  List<Element>? get contextLinkIdElement;
  @override

  /// [occurrenceDateTime] When action happens.
  FhirDateTime? get occurrenceDateTime;
  @override

  /// [occurrenceDateTimeElement] ("_occurrenceDateTime") Extensions for
  ///  occurrenceDateTime
  @JsonKey(name: '_occurrenceDateTime')
  Element? get occurrenceDateTimeElement;
  @override

  /// [occurrencePeriod] When action happens.
  Period? get occurrencePeriod;
  @override

  /// [occurrenceTiming] When action happens.
  Timing? get occurrenceTiming;
  @override

  /// [requester] Who or what initiated the action and has responsibility for
  ///  its activation.
  List<Reference>? get requester;
  @override

  /// [requesterLinkId] Id [identifier??] of the clause or question text
  ///  related to the requester of this action in the referenced form or
  ///  QuestionnaireResponse.
  List<String>? get requesterLinkId;
  @override

  /// [requesterLinkIdElement] ("_requesterLinkId") Extensions for
  ///  requesterLinkId
  @JsonKey(name: '_requesterLinkId')
  List<Element>? get requesterLinkIdElement;
  @override

  /// [performerType] The type of individual that is desired or required to
  ///  perform or not perform the action.
  List<CodeableConcept>? get performerType;
  @override

  /// [performerRole] The type of role or competency of an individual desired
  ///  or required to perform or not perform the action.
  CodeableConcept? get performerRole;
  @override

  /// [performer] Indicates who or what is being asked to perform (or not
  ///  perform) the ction.
  Reference? get performer;
  @override

  /// [performerLinkId] Id [identifier??] of the clause or question text
  ///  related to the reason type or reference of this  action in the
  ///  referenced form or QuestionnaireResponse.
  List<String>? get performerLinkId;
  @override

  /// [performerLinkIdElement] ("_performerLinkId") Extensions for
  ///  performerLinkId
  @JsonKey(name: '_performerLinkId')
  List<Element>? get performerLinkIdElement;
  @override

  /// [reason] Rationale for the action to be performed or not performed.
  ///  Describes why the action is permitted or prohibited. Either a coded
  ///  concept, or another resource whose existence justifies permitting or
  ///  not permitting this action.
  List<CodeableReference>? get reason;
  @override

  /// [reasonLinkId] Id [identifier??] of the clause or question text related
  ///  to the reason type or reference of this  action in the referenced form
  ///  or QuestionnaireResponse.
  List<String>? get reasonLinkId;
  @override

  /// [reasonLinkIdElement] ("_reasonLinkId") Extensions for reasonLinkId
  @JsonKey(name: '_reasonLinkId')
  List<Element>? get reasonLinkIdElement;
  @override

  /// [note] Comments made about the term action made by the requester,
  ///  performer, subject or other participants.
  List<Annotation>? get note;
  @override

  /// [securityLabelNumber] Security labels that protects the action.
  List<FhirUnsignedInt>? get securityLabelNumber;
  @override

  /// [securityLabelNumberElement] ("_securityLabelNumber") Extensions for
  ///  securityLabelNumber
  @JsonKey(name: '_securityLabelNumber')
  List<Element>? get securityLabelNumberElement;
  @override
  @JsonKey(ignore: true)
  _$$ContractActionImplCopyWith<_$ContractActionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractSubject _$ContractSubjectFromJson(Map<String, dynamic> json) {
  return _ContractSubject.fromJson(json);
}

/// @nodoc
mixin _$ContractSubject {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [reference] The entity the action is performed or not performed on or
  ///  for.
  List<Reference> get reference => throw _privateConstructorUsedError;

  /// [role] Role type of agent assigned roles in this Contract.
  CodeableConcept? get role => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractSubjectCopyWith<ContractSubject> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractSubjectCopyWith<$Res> {
  factory $ContractSubjectCopyWith(
          ContractSubject value, $Res Function(ContractSubject) then) =
      _$ContractSubjectCopyWithImpl<$Res, ContractSubject>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Reference> reference,
      CodeableConcept? role});

  $CodeableConceptCopyWith<$Res>? get role;
}

/// @nodoc
class _$ContractSubjectCopyWithImpl<$Res, $Val extends ContractSubject>
    implements $ContractSubjectCopyWith<$Res> {
  _$ContractSubjectCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? reference = null,
    Object? role = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      reference: null == reference
          ? _value.reference
          : reference // ignore: cast_nullable_to_non_nullable
              as List<Reference>,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get role {
    if (_value.role == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.role!, (value) {
      return _then(_value.copyWith(role: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractSubjectImplCopyWith<$Res>
    implements $ContractSubjectCopyWith<$Res> {
  factory _$$ContractSubjectImplCopyWith(_$ContractSubjectImpl value,
          $Res Function(_$ContractSubjectImpl) then) =
      __$$ContractSubjectImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Reference> reference,
      CodeableConcept? role});

  @override
  $CodeableConceptCopyWith<$Res>? get role;
}

/// @nodoc
class __$$ContractSubjectImplCopyWithImpl<$Res>
    extends _$ContractSubjectCopyWithImpl<$Res, _$ContractSubjectImpl>
    implements _$$ContractSubjectImplCopyWith<$Res> {
  __$$ContractSubjectImplCopyWithImpl(
      _$ContractSubjectImpl _value, $Res Function(_$ContractSubjectImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? reference = null,
    Object? role = freezed,
  }) {
    return _then(_$ContractSubjectImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      reference: null == reference
          ? _value._reference
          : reference // ignore: cast_nullable_to_non_nullable
              as List<Reference>,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractSubjectImpl extends _ContractSubject {
  const _$ContractSubjectImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final List<Reference> reference,
      this.role})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _reference = reference,
        super._();

  factory _$ContractSubjectImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractSubjectImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reference] The entity the action is performed or not performed on or
  ///  for.
  final List<Reference> _reference;

  /// [reference] The entity the action is performed or not performed on or
  ///  for.
  @override
  List<Reference> get reference {
    if (_reference is EqualUnmodifiableListView) return _reference;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_reference);
  }

  /// [role] Role type of agent assigned roles in this Contract.
  @override
  final CodeableConcept? role;

  @override
  String toString() {
    return 'ContractSubject(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, reference: $reference, role: $role)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractSubjectImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._reference, _reference) &&
            (identical(other.role, role) || other.role == role));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_reference),
      role);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractSubjectImplCopyWith<_$ContractSubjectImpl> get copyWith =>
      __$$ContractSubjectImplCopyWithImpl<_$ContractSubjectImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractSubjectImplToJson(
      this,
    );
  }
}

abstract class _ContractSubject extends ContractSubject {
  const factory _ContractSubject(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final List<Reference> reference,
      final CodeableConcept? role}) = _$ContractSubjectImpl;
  const _ContractSubject._() : super._();

  factory _ContractSubject.fromJson(Map<String, dynamic> json) =
      _$ContractSubjectImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [reference] The entity the action is performed or not performed on or
  ///  for.
  List<Reference> get reference;
  @override

  /// [role] Role type of agent assigned roles in this Contract.
  CodeableConcept? get role;
  @override
  @JsonKey(ignore: true)
  _$$ContractSubjectImplCopyWith<_$ContractSubjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractSigner _$ContractSignerFromJson(Map<String, dynamic> json) {
  return _ContractSigner.fromJson(json);
}

/// @nodoc
mixin _$ContractSigner {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Role of this Contract signer, e.g. notary, grantee.
  Coding get type => throw _privateConstructorUsedError;

  /// [party] Party which is a signator to this Contract.
  Reference get party => throw _privateConstructorUsedError;

  /// [signature] Legally binding Contract DSIG signature contents in Base64.
  List<Signature> get signature => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractSignerCopyWith<ContractSigner> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractSignerCopyWith<$Res> {
  factory $ContractSignerCopyWith(
          ContractSigner value, $Res Function(ContractSigner) then) =
      _$ContractSignerCopyWithImpl<$Res, ContractSigner>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Coding type,
      Reference party,
      List<Signature> signature});

  $CodingCopyWith<$Res> get type;
  $ReferenceCopyWith<$Res> get party;
}

/// @nodoc
class _$ContractSignerCopyWithImpl<$Res, $Val extends ContractSigner>
    implements $ContractSignerCopyWith<$Res> {
  _$ContractSignerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? party = null,
    Object? signature = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as Coding,
      party: null == party
          ? _value.party
          : party // ignore: cast_nullable_to_non_nullable
              as Reference,
      signature: null == signature
          ? _value.signature
          : signature // ignore: cast_nullable_to_non_nullable
              as List<Signature>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodingCopyWith<$Res> get type {
    return $CodingCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get party {
    return $ReferenceCopyWith<$Res>(_value.party, (value) {
      return _then(_value.copyWith(party: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractSignerImplCopyWith<$Res>
    implements $ContractSignerCopyWith<$Res> {
  factory _$$ContractSignerImplCopyWith(_$ContractSignerImpl value,
          $Res Function(_$ContractSignerImpl) then) =
      __$$ContractSignerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Coding type,
      Reference party,
      List<Signature> signature});

  @override
  $CodingCopyWith<$Res> get type;
  @override
  $ReferenceCopyWith<$Res> get party;
}

/// @nodoc
class __$$ContractSignerImplCopyWithImpl<$Res>
    extends _$ContractSignerCopyWithImpl<$Res, _$ContractSignerImpl>
    implements _$$ContractSignerImplCopyWith<$Res> {
  __$$ContractSignerImplCopyWithImpl(
      _$ContractSignerImpl _value, $Res Function(_$ContractSignerImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? party = null,
    Object? signature = null,
  }) {
    return _then(_$ContractSignerImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as Coding,
      party: null == party
          ? _value.party
          : party // ignore: cast_nullable_to_non_nullable
              as Reference,
      signature: null == signature
          ? _value._signature
          : signature // ignore: cast_nullable_to_non_nullable
              as List<Signature>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractSignerImpl extends _ContractSigner {
  const _$ContractSignerImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      required this.party,
      required final List<Signature> signature})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _signature = signature,
        super._();

  factory _$ContractSignerImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractSignerImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Role of this Contract signer, e.g. notary, grantee.
  @override
  final Coding type;

  /// [party] Party which is a signator to this Contract.
  @override
  final Reference party;

  /// [signature] Legally binding Contract DSIG signature contents in Base64.
  final List<Signature> _signature;

  /// [signature] Legally binding Contract DSIG signature contents in Base64.
  @override
  List<Signature> get signature {
    if (_signature is EqualUnmodifiableListView) return _signature;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_signature);
  }

  @override
  String toString() {
    return 'ContractSigner(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, party: $party, signature: $signature)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractSignerImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.party, party) || other.party == party) &&
            const DeepCollectionEquality()
                .equals(other._signature, _signature));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      party,
      const DeepCollectionEquality().hash(_signature));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractSignerImplCopyWith<_$ContractSignerImpl> get copyWith =>
      __$$ContractSignerImplCopyWithImpl<_$ContractSignerImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractSignerImplToJson(
      this,
    );
  }
}

abstract class _ContractSigner extends ContractSigner {
  const factory _ContractSigner(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final Coding type,
      required final Reference party,
      required final List<Signature> signature}) = _$ContractSignerImpl;
  const _ContractSigner._() : super._();

  factory _ContractSigner.fromJson(Map<String, dynamic> json) =
      _$ContractSignerImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Role of this Contract signer, e.g. notary, grantee.
  Coding get type;
  @override

  /// [party] Party which is a signator to this Contract.
  Reference get party;
  @override

  /// [signature] Legally binding Contract DSIG signature contents in Base64.
  List<Signature> get signature;
  @override
  @JsonKey(ignore: true)
  _$$ContractSignerImplCopyWith<_$ContractSignerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractFriendly _$ContractFriendlyFromJson(Map<String, dynamic> json) {
  return _ContractFriendly.fromJson(json);
}

/// @nodoc
mixin _$ContractFriendly {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [contentAttachment] Human readable rendering of this Contract in a
  ///  format and representation intended to enhance comprehension and ensure
  ///  understandability.
  Attachment? get contentAttachment => throw _privateConstructorUsedError;

  /// [contentReference] Human readable rendering of this Contract in a
  ///  format and representation intended to enhance comprehension and ensure
  ///  understandability.
  Reference? get contentReference => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractFriendlyCopyWith<ContractFriendly> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractFriendlyCopyWith<$Res> {
  factory $ContractFriendlyCopyWith(
          ContractFriendly value, $Res Function(ContractFriendly) then) =
      _$ContractFriendlyCopyWithImpl<$Res, ContractFriendly>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Attachment? contentAttachment,
      Reference? contentReference});

  $AttachmentCopyWith<$Res>? get contentAttachment;
  $ReferenceCopyWith<$Res>? get contentReference;
}

/// @nodoc
class _$ContractFriendlyCopyWithImpl<$Res, $Val extends ContractFriendly>
    implements $ContractFriendlyCopyWith<$Res> {
  _$ContractFriendlyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? contentAttachment = freezed,
    Object? contentReference = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      contentAttachment: freezed == contentAttachment
          ? _value.contentAttachment
          : contentAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      contentReference: freezed == contentReference
          ? _value.contentReference
          : contentReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get contentAttachment {
    if (_value.contentAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.contentAttachment!, (value) {
      return _then(_value.copyWith(contentAttachment: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get contentReference {
    if (_value.contentReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.contentReference!, (value) {
      return _then(_value.copyWith(contentReference: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractFriendlyImplCopyWith<$Res>
    implements $ContractFriendlyCopyWith<$Res> {
  factory _$$ContractFriendlyImplCopyWith(_$ContractFriendlyImpl value,
          $Res Function(_$ContractFriendlyImpl) then) =
      __$$ContractFriendlyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Attachment? contentAttachment,
      Reference? contentReference});

  @override
  $AttachmentCopyWith<$Res>? get contentAttachment;
  @override
  $ReferenceCopyWith<$Res>? get contentReference;
}

/// @nodoc
class __$$ContractFriendlyImplCopyWithImpl<$Res>
    extends _$ContractFriendlyCopyWithImpl<$Res, _$ContractFriendlyImpl>
    implements _$$ContractFriendlyImplCopyWith<$Res> {
  __$$ContractFriendlyImplCopyWithImpl(_$ContractFriendlyImpl _value,
      $Res Function(_$ContractFriendlyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? contentAttachment = freezed,
    Object? contentReference = freezed,
  }) {
    return _then(_$ContractFriendlyImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      contentAttachment: freezed == contentAttachment
          ? _value.contentAttachment
          : contentAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      contentReference: freezed == contentReference
          ? _value.contentReference
          : contentReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractFriendlyImpl extends _ContractFriendly {
  const _$ContractFriendlyImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.contentAttachment,
      this.contentReference})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ContractFriendlyImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractFriendlyImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [contentAttachment] Human readable rendering of this Contract in a
  ///  format and representation intended to enhance comprehension and ensure
  ///  understandability.
  @override
  final Attachment? contentAttachment;

  /// [contentReference] Human readable rendering of this Contract in a
  ///  format and representation intended to enhance comprehension and ensure
  ///  understandability.
  @override
  final Reference? contentReference;

  @override
  String toString() {
    return 'ContractFriendly(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, contentAttachment: $contentAttachment, contentReference: $contentReference)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractFriendlyImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.contentAttachment, contentAttachment) ||
                other.contentAttachment == contentAttachment) &&
            (identical(other.contentReference, contentReference) ||
                other.contentReference == contentReference));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      contentAttachment,
      contentReference);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractFriendlyImplCopyWith<_$ContractFriendlyImpl> get copyWith =>
      __$$ContractFriendlyImplCopyWithImpl<_$ContractFriendlyImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractFriendlyImplToJson(
      this,
    );
  }
}

abstract class _ContractFriendly extends ContractFriendly {
  const factory _ContractFriendly(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Attachment? contentAttachment,
      final Reference? contentReference}) = _$ContractFriendlyImpl;
  const _ContractFriendly._() : super._();

  factory _ContractFriendly.fromJson(Map<String, dynamic> json) =
      _$ContractFriendlyImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [contentAttachment] Human readable rendering of this Contract in a
  ///  format and representation intended to enhance comprehension and ensure
  ///  understandability.
  Attachment? get contentAttachment;
  @override

  /// [contentReference] Human readable rendering of this Contract in a
  ///  format and representation intended to enhance comprehension and ensure
  ///  understandability.
  Reference? get contentReference;
  @override
  @JsonKey(ignore: true)
  _$$ContractFriendlyImplCopyWith<_$ContractFriendlyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractLegal _$ContractLegalFromJson(Map<String, dynamic> json) {
  return _ContractLegal.fromJson(json);
}

/// @nodoc
mixin _$ContractLegal {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [contentAttachment] Contract legal text in human renderable form.
  Attachment? get contentAttachment => throw _privateConstructorUsedError;

  /// [contentReference] Contract legal text in human renderable form.
  Reference? get contentReference => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractLegalCopyWith<ContractLegal> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractLegalCopyWith<$Res> {
  factory $ContractLegalCopyWith(
          ContractLegal value, $Res Function(ContractLegal) then) =
      _$ContractLegalCopyWithImpl<$Res, ContractLegal>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Attachment? contentAttachment,
      Reference? contentReference});

  $AttachmentCopyWith<$Res>? get contentAttachment;
  $ReferenceCopyWith<$Res>? get contentReference;
}

/// @nodoc
class _$ContractLegalCopyWithImpl<$Res, $Val extends ContractLegal>
    implements $ContractLegalCopyWith<$Res> {
  _$ContractLegalCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? contentAttachment = freezed,
    Object? contentReference = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      contentAttachment: freezed == contentAttachment
          ? _value.contentAttachment
          : contentAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      contentReference: freezed == contentReference
          ? _value.contentReference
          : contentReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get contentAttachment {
    if (_value.contentAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.contentAttachment!, (value) {
      return _then(_value.copyWith(contentAttachment: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get contentReference {
    if (_value.contentReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.contentReference!, (value) {
      return _then(_value.copyWith(contentReference: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractLegalImplCopyWith<$Res>
    implements $ContractLegalCopyWith<$Res> {
  factory _$$ContractLegalImplCopyWith(
          _$ContractLegalImpl value, $Res Function(_$ContractLegalImpl) then) =
      __$$ContractLegalImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Attachment? contentAttachment,
      Reference? contentReference});

  @override
  $AttachmentCopyWith<$Res>? get contentAttachment;
  @override
  $ReferenceCopyWith<$Res>? get contentReference;
}

/// @nodoc
class __$$ContractLegalImplCopyWithImpl<$Res>
    extends _$ContractLegalCopyWithImpl<$Res, _$ContractLegalImpl>
    implements _$$ContractLegalImplCopyWith<$Res> {
  __$$ContractLegalImplCopyWithImpl(
      _$ContractLegalImpl _value, $Res Function(_$ContractLegalImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? contentAttachment = freezed,
    Object? contentReference = freezed,
  }) {
    return _then(_$ContractLegalImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      contentAttachment: freezed == contentAttachment
          ? _value.contentAttachment
          : contentAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      contentReference: freezed == contentReference
          ? _value.contentReference
          : contentReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractLegalImpl extends _ContractLegal {
  const _$ContractLegalImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.contentAttachment,
      this.contentReference})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ContractLegalImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractLegalImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [contentAttachment] Contract legal text in human renderable form.
  @override
  final Attachment? contentAttachment;

  /// [contentReference] Contract legal text in human renderable form.
  @override
  final Reference? contentReference;

  @override
  String toString() {
    return 'ContractLegal(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, contentAttachment: $contentAttachment, contentReference: $contentReference)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractLegalImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.contentAttachment, contentAttachment) ||
                other.contentAttachment == contentAttachment) &&
            (identical(other.contentReference, contentReference) ||
                other.contentReference == contentReference));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      contentAttachment,
      contentReference);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractLegalImplCopyWith<_$ContractLegalImpl> get copyWith =>
      __$$ContractLegalImplCopyWithImpl<_$ContractLegalImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractLegalImplToJson(
      this,
    );
  }
}

abstract class _ContractLegal extends ContractLegal {
  const factory _ContractLegal(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Attachment? contentAttachment,
      final Reference? contentReference}) = _$ContractLegalImpl;
  const _ContractLegal._() : super._();

  factory _ContractLegal.fromJson(Map<String, dynamic> json) =
      _$ContractLegalImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [contentAttachment] Contract legal text in human renderable form.
  Attachment? get contentAttachment;
  @override

  /// [contentReference] Contract legal text in human renderable form.
  Reference? get contentReference;
  @override
  @JsonKey(ignore: true)
  _$$ContractLegalImplCopyWith<_$ContractLegalImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContractRule _$ContractRuleFromJson(Map<String, dynamic> json) {
  return _ContractRule.fromJson(json);
}

/// @nodoc
mixin _$ContractRule {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [contentAttachment] Computable Contract conveyed using a policy rule
  ///  language (e.g. XACML, DKAL, SecPal).
  Attachment? get contentAttachment => throw _privateConstructorUsedError;

  /// [contentReference] Computable Contract conveyed using a policy rule
  ///  language (e.g. XACML, DKAL, SecPal).
  Reference? get contentReference => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContractRuleCopyWith<ContractRule> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContractRuleCopyWith<$Res> {
  factory $ContractRuleCopyWith(
          ContractRule value, $Res Function(ContractRule) then) =
      _$ContractRuleCopyWithImpl<$Res, ContractRule>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Attachment? contentAttachment,
      Reference? contentReference});

  $AttachmentCopyWith<$Res>? get contentAttachment;
  $ReferenceCopyWith<$Res>? get contentReference;
}

/// @nodoc
class _$ContractRuleCopyWithImpl<$Res, $Val extends ContractRule>
    implements $ContractRuleCopyWith<$Res> {
  _$ContractRuleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? contentAttachment = freezed,
    Object? contentReference = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      contentAttachment: freezed == contentAttachment
          ? _value.contentAttachment
          : contentAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      contentReference: freezed == contentReference
          ? _value.contentReference
          : contentReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get contentAttachment {
    if (_value.contentAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.contentAttachment!, (value) {
      return _then(_value.copyWith(contentAttachment: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get contentReference {
    if (_value.contentReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.contentReference!, (value) {
      return _then(_value.copyWith(contentReference: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ContractRuleImplCopyWith<$Res>
    implements $ContractRuleCopyWith<$Res> {
  factory _$$ContractRuleImplCopyWith(
          _$ContractRuleImpl value, $Res Function(_$ContractRuleImpl) then) =
      __$$ContractRuleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Attachment? contentAttachment,
      Reference? contentReference});

  @override
  $AttachmentCopyWith<$Res>? get contentAttachment;
  @override
  $ReferenceCopyWith<$Res>? get contentReference;
}

/// @nodoc
class __$$ContractRuleImplCopyWithImpl<$Res>
    extends _$ContractRuleCopyWithImpl<$Res, _$ContractRuleImpl>
    implements _$$ContractRuleImplCopyWith<$Res> {
  __$$ContractRuleImplCopyWithImpl(
      _$ContractRuleImpl _value, $Res Function(_$ContractRuleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? contentAttachment = freezed,
    Object? contentReference = freezed,
  }) {
    return _then(_$ContractRuleImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      contentAttachment: freezed == contentAttachment
          ? _value.contentAttachment
          : contentAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      contentReference: freezed == contentReference
          ? _value.contentReference
          : contentReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ContractRuleImpl extends _ContractRule {
  const _$ContractRuleImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.contentAttachment,
      this.contentReference})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ContractRuleImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContractRuleImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [contentAttachment] Computable Contract conveyed using a policy rule
  ///  language (e.g. XACML, DKAL, SecPal).
  @override
  final Attachment? contentAttachment;

  /// [contentReference] Computable Contract conveyed using a policy rule
  ///  language (e.g. XACML, DKAL, SecPal).
  @override
  final Reference? contentReference;

  @override
  String toString() {
    return 'ContractRule(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, contentAttachment: $contentAttachment, contentReference: $contentReference)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContractRuleImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.contentAttachment, contentAttachment) ||
                other.contentAttachment == contentAttachment) &&
            (identical(other.contentReference, contentReference) ||
                other.contentReference == contentReference));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      contentAttachment,
      contentReference);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ContractRuleImplCopyWith<_$ContractRuleImpl> get copyWith =>
      __$$ContractRuleImplCopyWithImpl<_$ContractRuleImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContractRuleImplToJson(
      this,
    );
  }
}

abstract class _ContractRule extends ContractRule {
  const factory _ContractRule(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Attachment? contentAttachment,
      final Reference? contentReference}) = _$ContractRuleImpl;
  const _ContractRule._() : super._();

  factory _ContractRule.fromJson(Map<String, dynamic> json) =
      _$ContractRuleImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [contentAttachment] Computable Contract conveyed using a policy rule
  ///  language (e.g. XACML, DKAL, SecPal).
  Attachment? get contentAttachment;
  @override

  /// [contentReference] Computable Contract conveyed using a policy rule
  ///  language (e.g. XACML, DKAL, SecPal).
  Reference? get contentReference;
  @override
  @JsonKey(ignore: true)
  _$$ContractRuleImplCopyWith<_$ContractRuleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ExplanationOfBenefit _$ExplanationOfBenefitFromJson(Map<String, dynamic> json) {
  return _ExplanationOfBenefit.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefit {
  /// [resourceType] This is a ExplanationOfBenefit resource
  @JsonKey(unknownEnumValue: R6ResourceType.ExplanationOfBenefit)
  R6ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  FhirMeta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  FhirCode? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] A unique identifier assigned to this explanation of
  ///  benefit.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber => throw _privateConstructorUsedError;

  /// [status] The status of the resource instance.
  FhirCode? get status => throw _privateConstructorUsedError;

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement => throw _privateConstructorUsedError;

  /// [type] The category of claim, e.g. oral, pharmacy, vision,
  ///  institutional, professional.
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [subType] A finer grained suite of claim type codes which may convey
  ///  additional information such as Inpatient vs Outpatient and/or a
  ///  specialty service.
  CodeableConcept? get subType => throw _privateConstructorUsedError;

  /// [use] A code to indicate whether the nature of the request is: Claim -
  ///  A request to an Insurer to adjudicate the supplied charges for health
  ///  care goods and services under the identified policy and to pay the
  ///  determined Benefit amount, if any; Preauthorization - A request to an
  ///  Insurer to adjudicate the supplied proposed future charges for health
  ///  care goods and services under the identified policy and to approve the
  ///  services and provide the expected benefit amounts and potentially to
  ///  reserve funds to pay the benefits when Claims for the indicated
  ///  services are later submitted; or, Pre-determination - A request to an
  ///  Insurer to adjudicate the supplied 'what if' charges for health care
  ///  goods and services under the identified policy and report back what
  ///  the Benefit payable would be had the services actually been provided.
  FhirCode? get use => throw _privateConstructorUsedError;

  /// [useElement] ("_use") Extensions for use
  @JsonKey(name: '_use')
  Element? get useElement => throw _privateConstructorUsedError;

  /// [patient] The party to whom the professional services and/or products
  ///  have been supplied or are being considered and for whom actual for
  ///  forecast reimbursement is sought.
  Reference get patient => throw _privateConstructorUsedError;

  /// [billablePeriod] The period for which charges are being submitted.
  Period? get billablePeriod => throw _privateConstructorUsedError;

  /// [created] The date this resource was created.
  FhirDateTime? get created => throw _privateConstructorUsedError;

  /// [createdElement] ("_created") Extensions for created
  @JsonKey(name: '_created')
  Element? get createdElement => throw _privateConstructorUsedError;

  /// [enterer] Individual who created the claim, predetermination or
  ///  preauthorization.
  Reference? get enterer => throw _privateConstructorUsedError;

  /// [insurer] The party responsible for authorization, adjudication and
  ///  reimbursement.
  Reference? get insurer => throw _privateConstructorUsedError;

  /// [provider] The provider which is responsible for the claim,
  ///  predetermination or preauthorization.
  Reference? get provider => throw _privateConstructorUsedError;

  /// [priority] The provider-required urgency of processing the request.
  ///  Typical values include: stat, normal deferred.
  CodeableConcept? get priority => throw _privateConstructorUsedError;

  /// [fundsReserveRequested] A code to indicate whether and for whom funds
  ///  are to be reserved for future claims.
  CodeableConcept? get fundsReserveRequested =>
      throw _privateConstructorUsedError;

  /// [fundsReserve] A code, used only on a response to a preauthorization,
  ///  to indicate whether the benefits payable have been reserved and for
  ///  whom.
  CodeableConcept? get fundsReserve => throw _privateConstructorUsedError;

  /// [related] Other claims which are related to this claim such as prior
  ///  submissions or claims for related services or for the same event.
  List<ExplanationOfBenefitRelated>? get related =>
      throw _privateConstructorUsedError;

  /// [prescription] Prescription is the document/authorization given to the
  ///  claim author for them to provide products and services for which
  ///  consideration (reimbursement) is sought. Could be a RX for
  ///  medications, an 'order' for oxygen or wheelchair or physiotherapy
  ///  treatments.
  Reference? get prescription => throw _privateConstructorUsedError;

  /// [originalPrescription] Original prescription which has been superseded
  ///  by this prescription to support the dispensing of pharmacy services,
  ///  medications or products.
  Reference? get originalPrescription => throw _privateConstructorUsedError;

  /// [event] Information code for an event with a corresponding date or
  ///  period.
  List<ExplanationOfBenefitEvent>? get event =>
      throw _privateConstructorUsedError;

  /// [payee] The party to be reimbursed for cost of the products and
  ///  services according to the terms of the policy.
  ExplanationOfBenefitPayee? get payee => throw _privateConstructorUsedError;

  /// [referral] The referral information received by the claim author, it is
  ///  not to be used when the author generates a referral for a patient. A
  ///  copy of that referral may be provided as supporting information. Some
  ///  insurers require proof of referral to pay for services or to pay
  ///  specialist rates for services.
  Reference? get referral => throw _privateConstructorUsedError;

  /// [encounter] Healthcare encounters related to this claim.
  List<Reference>? get encounter => throw _privateConstructorUsedError;

  /// [facility] Facility where the services were provided.
  Reference? get facility => throw _privateConstructorUsedError;

  /// [claim] The business identifier for the instance of the adjudication
  ///  request: claim predetermination or preauthorization.
  Reference? get claim => throw _privateConstructorUsedError;

  /// [claimResponse] The business identifier for the instance of the
  ///  adjudication response: claim, predetermination or preauthorization
  ///  response.
  Reference? get claimResponse => throw _privateConstructorUsedError;

  /// [outcome] The outcome of the claim, predetermination, or
  ///  preauthorization processing.
  FhirCode? get outcome => throw _privateConstructorUsedError;

  /// [outcomeElement] ("_outcome") Extensions for outcome
  @JsonKey(name: '_outcome')
  Element? get outcomeElement => throw _privateConstructorUsedError;

  /// [decision] The result of the claim, predetermination, or
  ///  preauthorization adjudication.
  CodeableConcept? get decision => throw _privateConstructorUsedError;

  /// [disposition] A human readable description of the status of the
  ///  adjudication.
  String? get disposition => throw _privateConstructorUsedError;

  /// [dispositionElement] ("_disposition") Extensions for disposition
  @JsonKey(name: '_disposition')
  Element? get dispositionElement => throw _privateConstructorUsedError;

  /// [preAuthRef] Reference from the Insurer which is used in later
  ///  communications which refers to this adjudication.
  List<String>? get preAuthRef => throw _privateConstructorUsedError;

  /// [preAuthRefElement] ("_preAuthRef") Extensions for preAuthRef
  @JsonKey(name: '_preAuthRef')
  List<Element>? get preAuthRefElement => throw _privateConstructorUsedError;

  /// [preAuthRefPeriod] The timeframe during which the supplied
  ///  preauthorization reference may be quoted on claims to obtain the
  ///  adjudication as provided.
  List<Period>? get preAuthRefPeriod => throw _privateConstructorUsedError;

  /// [diagnosisRelatedGroup] A package billing code or bundle code used to
  ///  group products and services to a particular health condition (such as
  ///  heart attack) which is based on a predetermined grouping code system.
  CodeableConcept? get diagnosisRelatedGroup =>
      throw _privateConstructorUsedError;

  /// [careTeam] The members of the team who provided the products and
  ///  services.
  List<ExplanationOfBenefitCareTeam>? get careTeam =>
      throw _privateConstructorUsedError;

  /// [supportingInfo] Additional information codes regarding exceptions,
  ///  special considerations, the condition, situation, prior or concurrent
  ///  issues.
  List<ExplanationOfBenefitSupportingInfo>? get supportingInfo =>
      throw _privateConstructorUsedError;

  /// [diagnosis] Information about diagnoses relevant to the claim items.
  List<ExplanationOfBenefitDiagnosis>? get diagnosis =>
      throw _privateConstructorUsedError;

  /// [procedure] Procedures performed on the patient relevant to the billing
  ///  items with the claim.
  List<ExplanationOfBenefitProcedure>? get procedure =>
      throw _privateConstructorUsedError;

  /// [precedence] This indicates the relative order of a series of EOBs
  ///  related to different coverages for the same suite of services.
  FhirPositiveInt? get precedence => throw _privateConstructorUsedError;

  /// [precedenceElement] ("_precedence") Extensions for precedence
  @JsonKey(name: '_precedence')
  Element? get precedenceElement => throw _privateConstructorUsedError;

  /// [insurance] Financial instruments for reimbursement for the health care
  ///  products and services specified on the claim.
  List<ExplanationOfBenefitInsurance>? get insurance =>
      throw _privateConstructorUsedError;

  /// [accident] Details of a accident which resulted in injuries which
  ///  required the products and services listed in the claim.
  ExplanationOfBenefitAccident? get accident =>
      throw _privateConstructorUsedError;

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid => throw _privateConstructorUsedError;

  /// [item] A claim line. Either a simple (a product or service) or a
  ///  'group' of details which can also be a simple items or groups of
  ///  sub-details.
  List<ExplanationOfBenefitItem>? get item =>
      throw _privateConstructorUsedError;

  /// [addItem] The first-tier service adjudications for payor added product
  ///  or service lines.
  List<ExplanationOfBenefitAddItem>? get addItem =>
      throw _privateConstructorUsedError;

  /// [adjudication] The adjudication results which are presented at the
  ///  header level rather than at the line-item or add-item levels.
  List<ExplanationOfBenefitAdjudication>? get adjudication =>
      throw _privateConstructorUsedError;

  /// [total] Categorized monetary totals for the adjudication.
  List<ExplanationOfBenefitTotal>? get total =>
      throw _privateConstructorUsedError;

  /// [payment] Payment details for the adjudication of the claim.
  ExplanationOfBenefitPayment? get payment =>
      throw _privateConstructorUsedError;

  /// [formCode] A code for the form to be used for printing the content.
  CodeableConcept? get formCode => throw _privateConstructorUsedError;

  /// [form] The actual form, by reference or inclusion, for printing the
  ///  content or an EOB.
  Attachment? get form => throw _privateConstructorUsedError;

  /// [processNote] A note that describes or explains adjudication results in
  ///  a human readable form.
  List<ExplanationOfBenefitProcessNote>? get processNote =>
      throw _privateConstructorUsedError;

  /// [benefitPeriod] The term of the benefits documented in this response.
  Period? get benefitPeriod => throw _privateConstructorUsedError;

  /// [benefitBalance] Balance by Benefit Category.
  List<ExplanationOfBenefitBenefitBalance>? get benefitBalance =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitCopyWith<ExplanationOfBenefit> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitCopyWith<$Res> {
  factory $ExplanationOfBenefitCopyWith(ExplanationOfBenefit value,
          $Res Function(ExplanationOfBenefit) then) =
      _$ExplanationOfBenefitCopyWithImpl<$Res, ExplanationOfBenefit>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.ExplanationOfBenefit)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      List<Identifier>? traceNumber,
      FhirCode? status,
      @JsonKey(name: '_status') Element? statusElement,
      CodeableConcept type,
      CodeableConcept? subType,
      FhirCode? use,
      @JsonKey(name: '_use') Element? useElement,
      Reference patient,
      Period? billablePeriod,
      FhirDateTime? created,
      @JsonKey(name: '_created') Element? createdElement,
      Reference? enterer,
      Reference? insurer,
      Reference? provider,
      CodeableConcept? priority,
      CodeableConcept? fundsReserveRequested,
      CodeableConcept? fundsReserve,
      List<ExplanationOfBenefitRelated>? related,
      Reference? prescription,
      Reference? originalPrescription,
      List<ExplanationOfBenefitEvent>? event,
      ExplanationOfBenefitPayee? payee,
      Reference? referral,
      List<Reference>? encounter,
      Reference? facility,
      Reference? claim,
      Reference? claimResponse,
      FhirCode? outcome,
      @JsonKey(name: '_outcome') Element? outcomeElement,
      CodeableConcept? decision,
      String? disposition,
      @JsonKey(name: '_disposition') Element? dispositionElement,
      List<String>? preAuthRef,
      @JsonKey(name: '_preAuthRef') List<Element>? preAuthRefElement,
      List<Period>? preAuthRefPeriod,
      CodeableConcept? diagnosisRelatedGroup,
      List<ExplanationOfBenefitCareTeam>? careTeam,
      List<ExplanationOfBenefitSupportingInfo>? supportingInfo,
      List<ExplanationOfBenefitDiagnosis>? diagnosis,
      List<ExplanationOfBenefitProcedure>? procedure,
      FhirPositiveInt? precedence,
      @JsonKey(name: '_precedence') Element? precedenceElement,
      List<ExplanationOfBenefitInsurance>? insurance,
      ExplanationOfBenefitAccident? accident,
      Money? patientPaid,
      List<ExplanationOfBenefitItem>? item,
      List<ExplanationOfBenefitAddItem>? addItem,
      List<ExplanationOfBenefitAdjudication>? adjudication,
      List<ExplanationOfBenefitTotal>? total,
      ExplanationOfBenefitPayment? payment,
      CodeableConcept? formCode,
      Attachment? form,
      List<ExplanationOfBenefitProcessNote>? processNote,
      Period? benefitPeriod,
      List<ExplanationOfBenefitBenefitBalance>? benefitBalance});

  $FhirMetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get statusElement;
  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get subType;
  $ElementCopyWith<$Res>? get useElement;
  $ReferenceCopyWith<$Res> get patient;
  $PeriodCopyWith<$Res>? get billablePeriod;
  $ElementCopyWith<$Res>? get createdElement;
  $ReferenceCopyWith<$Res>? get enterer;
  $ReferenceCopyWith<$Res>? get insurer;
  $ReferenceCopyWith<$Res>? get provider;
  $CodeableConceptCopyWith<$Res>? get priority;
  $CodeableConceptCopyWith<$Res>? get fundsReserveRequested;
  $CodeableConceptCopyWith<$Res>? get fundsReserve;
  $ReferenceCopyWith<$Res>? get prescription;
  $ReferenceCopyWith<$Res>? get originalPrescription;
  $ExplanationOfBenefitPayeeCopyWith<$Res>? get payee;
  $ReferenceCopyWith<$Res>? get referral;
  $ReferenceCopyWith<$Res>? get facility;
  $ReferenceCopyWith<$Res>? get claim;
  $ReferenceCopyWith<$Res>? get claimResponse;
  $ElementCopyWith<$Res>? get outcomeElement;
  $CodeableConceptCopyWith<$Res>? get decision;
  $ElementCopyWith<$Res>? get dispositionElement;
  $CodeableConceptCopyWith<$Res>? get diagnosisRelatedGroup;
  $ElementCopyWith<$Res>? get precedenceElement;
  $ExplanationOfBenefitAccidentCopyWith<$Res>? get accident;
  $MoneyCopyWith<$Res>? get patientPaid;
  $ExplanationOfBenefitPaymentCopyWith<$Res>? get payment;
  $CodeableConceptCopyWith<$Res>? get formCode;
  $AttachmentCopyWith<$Res>? get form;
  $PeriodCopyWith<$Res>? get benefitPeriod;
}

/// @nodoc
class _$ExplanationOfBenefitCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefit>
    implements $ExplanationOfBenefitCopyWith<$Res> {
  _$ExplanationOfBenefitCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? traceNumber = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? type = null,
    Object? subType = freezed,
    Object? use = freezed,
    Object? useElement = freezed,
    Object? patient = null,
    Object? billablePeriod = freezed,
    Object? created = freezed,
    Object? createdElement = freezed,
    Object? enterer = freezed,
    Object? insurer = freezed,
    Object? provider = freezed,
    Object? priority = freezed,
    Object? fundsReserveRequested = freezed,
    Object? fundsReserve = freezed,
    Object? related = freezed,
    Object? prescription = freezed,
    Object? originalPrescription = freezed,
    Object? event = freezed,
    Object? payee = freezed,
    Object? referral = freezed,
    Object? encounter = freezed,
    Object? facility = freezed,
    Object? claim = freezed,
    Object? claimResponse = freezed,
    Object? outcome = freezed,
    Object? outcomeElement = freezed,
    Object? decision = freezed,
    Object? disposition = freezed,
    Object? dispositionElement = freezed,
    Object? preAuthRef = freezed,
    Object? preAuthRefElement = freezed,
    Object? preAuthRefPeriod = freezed,
    Object? diagnosisRelatedGroup = freezed,
    Object? careTeam = freezed,
    Object? supportingInfo = freezed,
    Object? diagnosis = freezed,
    Object? procedure = freezed,
    Object? precedence = freezed,
    Object? precedenceElement = freezed,
    Object? insurance = freezed,
    Object? accident = freezed,
    Object? patientPaid = freezed,
    Object? item = freezed,
    Object? addItem = freezed,
    Object? adjudication = freezed,
    Object? total = freezed,
    Object? payment = freezed,
    Object? formCode = freezed,
    Object? form = freezed,
    Object? processNote = freezed,
    Object? benefitPeriod = freezed,
    Object? benefitBalance = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      traceNumber: freezed == traceNumber
          ? _value.traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      subType: freezed == subType
          ? _value.subType
          : subType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      use: freezed == use
          ? _value.use
          : use // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      useElement: freezed == useElement
          ? _value.useElement
          : useElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      patient: null == patient
          ? _value.patient
          : patient // ignore: cast_nullable_to_non_nullable
              as Reference,
      billablePeriod: freezed == billablePeriod
          ? _value.billablePeriod
          : billablePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      created: freezed == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      createdElement: freezed == createdElement
          ? _value.createdElement
          : createdElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      enterer: freezed == enterer
          ? _value.enterer
          : enterer // ignore: cast_nullable_to_non_nullable
              as Reference?,
      insurer: freezed == insurer
          ? _value.insurer
          : insurer // ignore: cast_nullable_to_non_nullable
              as Reference?,
      provider: freezed == provider
          ? _value.provider
          : provider // ignore: cast_nullable_to_non_nullable
              as Reference?,
      priority: freezed == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      fundsReserveRequested: freezed == fundsReserveRequested
          ? _value.fundsReserveRequested
          : fundsReserveRequested // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      fundsReserve: freezed == fundsReserve
          ? _value.fundsReserve
          : fundsReserve // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      related: freezed == related
          ? _value.related
          : related // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitRelated>?,
      prescription: freezed == prescription
          ? _value.prescription
          : prescription // ignore: cast_nullable_to_non_nullable
              as Reference?,
      originalPrescription: freezed == originalPrescription
          ? _value.originalPrescription
          : originalPrescription // ignore: cast_nullable_to_non_nullable
              as Reference?,
      event: freezed == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitEvent>?,
      payee: freezed == payee
          ? _value.payee
          : payee // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitPayee?,
      referral: freezed == referral
          ? _value.referral
          : referral // ignore: cast_nullable_to_non_nullable
              as Reference?,
      encounter: freezed == encounter
          ? _value.encounter
          : encounter // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      facility: freezed == facility
          ? _value.facility
          : facility // ignore: cast_nullable_to_non_nullable
              as Reference?,
      claim: freezed == claim
          ? _value.claim
          : claim // ignore: cast_nullable_to_non_nullable
              as Reference?,
      claimResponse: freezed == claimResponse
          ? _value.claimResponse
          : claimResponse // ignore: cast_nullable_to_non_nullable
              as Reference?,
      outcome: freezed == outcome
          ? _value.outcome
          : outcome // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      outcomeElement: freezed == outcomeElement
          ? _value.outcomeElement
          : outcomeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      decision: freezed == decision
          ? _value.decision
          : decision // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      disposition: freezed == disposition
          ? _value.disposition
          : disposition // ignore: cast_nullable_to_non_nullable
              as String?,
      dispositionElement: freezed == dispositionElement
          ? _value.dispositionElement
          : dispositionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      preAuthRef: freezed == preAuthRef
          ? _value.preAuthRef
          : preAuthRef // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      preAuthRefElement: freezed == preAuthRefElement
          ? _value.preAuthRefElement
          : preAuthRefElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      preAuthRefPeriod: freezed == preAuthRefPeriod
          ? _value.preAuthRefPeriod
          : preAuthRefPeriod // ignore: cast_nullable_to_non_nullable
              as List<Period>?,
      diagnosisRelatedGroup: freezed == diagnosisRelatedGroup
          ? _value.diagnosisRelatedGroup
          : diagnosisRelatedGroup // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      careTeam: freezed == careTeam
          ? _value.careTeam
          : careTeam // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitCareTeam>?,
      supportingInfo: freezed == supportingInfo
          ? _value.supportingInfo
          : supportingInfo // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitSupportingInfo>?,
      diagnosis: freezed == diagnosis
          ? _value.diagnosis
          : diagnosis // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitDiagnosis>?,
      procedure: freezed == procedure
          ? _value.procedure
          : procedure // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitProcedure>?,
      precedence: freezed == precedence
          ? _value.precedence
          : precedence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      precedenceElement: freezed == precedenceElement
          ? _value.precedenceElement
          : precedenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      insurance: freezed == insurance
          ? _value.insurance
          : insurance // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitInsurance>?,
      accident: freezed == accident
          ? _value.accident
          : accident // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitAccident?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      item: freezed == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitItem>?,
      addItem: freezed == addItem
          ? _value.addItem
          : addItem // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAddItem>?,
      adjudication: freezed == adjudication
          ? _value.adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitTotal>?,
      payment: freezed == payment
          ? _value.payment
          : payment // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitPayment?,
      formCode: freezed == formCode
          ? _value.formCode
          : formCode // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      form: freezed == form
          ? _value.form
          : form // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      processNote: freezed == processNote
          ? _value.processNote
          : processNote // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitProcessNote>?,
      benefitPeriod: freezed == benefitPeriod
          ? _value.benefitPeriod
          : benefitPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      benefitBalance: freezed == benefitBalance
          ? _value.benefitBalance
          : benefitBalance // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitBenefitBalance>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FhirMetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $FhirMetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusElement {
    if (_value.statusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusElement!, (value) {
      return _then(_value.copyWith(statusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get subType {
    if (_value.subType == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.subType!, (value) {
      return _then(_value.copyWith(subType: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get useElement {
    if (_value.useElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.useElement!, (value) {
      return _then(_value.copyWith(useElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get patient {
    return $ReferenceCopyWith<$Res>(_value.patient, (value) {
      return _then(_value.copyWith(patient: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get billablePeriod {
    if (_value.billablePeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.billablePeriod!, (value) {
      return _then(_value.copyWith(billablePeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get createdElement {
    if (_value.createdElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.createdElement!, (value) {
      return _then(_value.copyWith(createdElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get enterer {
    if (_value.enterer == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.enterer!, (value) {
      return _then(_value.copyWith(enterer: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get insurer {
    if (_value.insurer == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.insurer!, (value) {
      return _then(_value.copyWith(insurer: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get provider {
    if (_value.provider == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.provider!, (value) {
      return _then(_value.copyWith(provider: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get priority {
    if (_value.priority == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.priority!, (value) {
      return _then(_value.copyWith(priority: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get fundsReserveRequested {
    if (_value.fundsReserveRequested == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.fundsReserveRequested!,
        (value) {
      return _then(_value.copyWith(fundsReserveRequested: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get fundsReserve {
    if (_value.fundsReserve == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.fundsReserve!, (value) {
      return _then(_value.copyWith(fundsReserve: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get prescription {
    if (_value.prescription == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.prescription!, (value) {
      return _then(_value.copyWith(prescription: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get originalPrescription {
    if (_value.originalPrescription == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.originalPrescription!, (value) {
      return _then(_value.copyWith(originalPrescription: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExplanationOfBenefitPayeeCopyWith<$Res>? get payee {
    if (_value.payee == null) {
      return null;
    }

    return $ExplanationOfBenefitPayeeCopyWith<$Res>(_value.payee!, (value) {
      return _then(_value.copyWith(payee: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get referral {
    if (_value.referral == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.referral!, (value) {
      return _then(_value.copyWith(referral: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get facility {
    if (_value.facility == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.facility!, (value) {
      return _then(_value.copyWith(facility: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get claim {
    if (_value.claim == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.claim!, (value) {
      return _then(_value.copyWith(claim: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get claimResponse {
    if (_value.claimResponse == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.claimResponse!, (value) {
      return _then(_value.copyWith(claimResponse: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get outcomeElement {
    if (_value.outcomeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.outcomeElement!, (value) {
      return _then(_value.copyWith(outcomeElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get decision {
    if (_value.decision == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.decision!, (value) {
      return _then(_value.copyWith(decision: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get dispositionElement {
    if (_value.dispositionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.dispositionElement!, (value) {
      return _then(_value.copyWith(dispositionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get diagnosisRelatedGroup {
    if (_value.diagnosisRelatedGroup == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.diagnosisRelatedGroup!,
        (value) {
      return _then(_value.copyWith(diagnosisRelatedGroup: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get precedenceElement {
    if (_value.precedenceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.precedenceElement!, (value) {
      return _then(_value.copyWith(precedenceElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExplanationOfBenefitAccidentCopyWith<$Res>? get accident {
    if (_value.accident == null) {
      return null;
    }

    return $ExplanationOfBenefitAccidentCopyWith<$Res>(_value.accident!,
        (value) {
      return _then(_value.copyWith(accident: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get patientPaid {
    if (_value.patientPaid == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.patientPaid!, (value) {
      return _then(_value.copyWith(patientPaid: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExplanationOfBenefitPaymentCopyWith<$Res>? get payment {
    if (_value.payment == null) {
      return null;
    }

    return $ExplanationOfBenefitPaymentCopyWith<$Res>(_value.payment!, (value) {
      return _then(_value.copyWith(payment: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get formCode {
    if (_value.formCode == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.formCode!, (value) {
      return _then(_value.copyWith(formCode: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get form {
    if (_value.form == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.form!, (value) {
      return _then(_value.copyWith(form: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get benefitPeriod {
    if (_value.benefitPeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.benefitPeriod!, (value) {
      return _then(_value.copyWith(benefitPeriod: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitImplCopyWith<$Res>
    implements $ExplanationOfBenefitCopyWith<$Res> {
  factory _$$ExplanationOfBenefitImplCopyWith(_$ExplanationOfBenefitImpl value,
          $Res Function(_$ExplanationOfBenefitImpl) then) =
      __$$ExplanationOfBenefitImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.ExplanationOfBenefit)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      List<Identifier>? traceNumber,
      FhirCode? status,
      @JsonKey(name: '_status') Element? statusElement,
      CodeableConcept type,
      CodeableConcept? subType,
      FhirCode? use,
      @JsonKey(name: '_use') Element? useElement,
      Reference patient,
      Period? billablePeriod,
      FhirDateTime? created,
      @JsonKey(name: '_created') Element? createdElement,
      Reference? enterer,
      Reference? insurer,
      Reference? provider,
      CodeableConcept? priority,
      CodeableConcept? fundsReserveRequested,
      CodeableConcept? fundsReserve,
      List<ExplanationOfBenefitRelated>? related,
      Reference? prescription,
      Reference? originalPrescription,
      List<ExplanationOfBenefitEvent>? event,
      ExplanationOfBenefitPayee? payee,
      Reference? referral,
      List<Reference>? encounter,
      Reference? facility,
      Reference? claim,
      Reference? claimResponse,
      FhirCode? outcome,
      @JsonKey(name: '_outcome') Element? outcomeElement,
      CodeableConcept? decision,
      String? disposition,
      @JsonKey(name: '_disposition') Element? dispositionElement,
      List<String>? preAuthRef,
      @JsonKey(name: '_preAuthRef') List<Element>? preAuthRefElement,
      List<Period>? preAuthRefPeriod,
      CodeableConcept? diagnosisRelatedGroup,
      List<ExplanationOfBenefitCareTeam>? careTeam,
      List<ExplanationOfBenefitSupportingInfo>? supportingInfo,
      List<ExplanationOfBenefitDiagnosis>? diagnosis,
      List<ExplanationOfBenefitProcedure>? procedure,
      FhirPositiveInt? precedence,
      @JsonKey(name: '_precedence') Element? precedenceElement,
      List<ExplanationOfBenefitInsurance>? insurance,
      ExplanationOfBenefitAccident? accident,
      Money? patientPaid,
      List<ExplanationOfBenefitItem>? item,
      List<ExplanationOfBenefitAddItem>? addItem,
      List<ExplanationOfBenefitAdjudication>? adjudication,
      List<ExplanationOfBenefitTotal>? total,
      ExplanationOfBenefitPayment? payment,
      CodeableConcept? formCode,
      Attachment? form,
      List<ExplanationOfBenefitProcessNote>? processNote,
      Period? benefitPeriod,
      List<ExplanationOfBenefitBenefitBalance>? benefitBalance});

  @override
  $FhirMetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get statusElement;
  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get subType;
  @override
  $ElementCopyWith<$Res>? get useElement;
  @override
  $ReferenceCopyWith<$Res> get patient;
  @override
  $PeriodCopyWith<$Res>? get billablePeriod;
  @override
  $ElementCopyWith<$Res>? get createdElement;
  @override
  $ReferenceCopyWith<$Res>? get enterer;
  @override
  $ReferenceCopyWith<$Res>? get insurer;
  @override
  $ReferenceCopyWith<$Res>? get provider;
  @override
  $CodeableConceptCopyWith<$Res>? get priority;
  @override
  $CodeableConceptCopyWith<$Res>? get fundsReserveRequested;
  @override
  $CodeableConceptCopyWith<$Res>? get fundsReserve;
  @override
  $ReferenceCopyWith<$Res>? get prescription;
  @override
  $ReferenceCopyWith<$Res>? get originalPrescription;
  @override
  $ExplanationOfBenefitPayeeCopyWith<$Res>? get payee;
  @override
  $ReferenceCopyWith<$Res>? get referral;
  @override
  $ReferenceCopyWith<$Res>? get facility;
  @override
  $ReferenceCopyWith<$Res>? get claim;
  @override
  $ReferenceCopyWith<$Res>? get claimResponse;
  @override
  $ElementCopyWith<$Res>? get outcomeElement;
  @override
  $CodeableConceptCopyWith<$Res>? get decision;
  @override
  $ElementCopyWith<$Res>? get dispositionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get diagnosisRelatedGroup;
  @override
  $ElementCopyWith<$Res>? get precedenceElement;
  @override
  $ExplanationOfBenefitAccidentCopyWith<$Res>? get accident;
  @override
  $MoneyCopyWith<$Res>? get patientPaid;
  @override
  $ExplanationOfBenefitPaymentCopyWith<$Res>? get payment;
  @override
  $CodeableConceptCopyWith<$Res>? get formCode;
  @override
  $AttachmentCopyWith<$Res>? get form;
  @override
  $PeriodCopyWith<$Res>? get benefitPeriod;
}

/// @nodoc
class __$$ExplanationOfBenefitImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitCopyWithImpl<$Res, _$ExplanationOfBenefitImpl>
    implements _$$ExplanationOfBenefitImplCopyWith<$Res> {
  __$$ExplanationOfBenefitImplCopyWithImpl(_$ExplanationOfBenefitImpl _value,
      $Res Function(_$ExplanationOfBenefitImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? traceNumber = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? type = null,
    Object? subType = freezed,
    Object? use = freezed,
    Object? useElement = freezed,
    Object? patient = null,
    Object? billablePeriod = freezed,
    Object? created = freezed,
    Object? createdElement = freezed,
    Object? enterer = freezed,
    Object? insurer = freezed,
    Object? provider = freezed,
    Object? priority = freezed,
    Object? fundsReserveRequested = freezed,
    Object? fundsReserve = freezed,
    Object? related = freezed,
    Object? prescription = freezed,
    Object? originalPrescription = freezed,
    Object? event = freezed,
    Object? payee = freezed,
    Object? referral = freezed,
    Object? encounter = freezed,
    Object? facility = freezed,
    Object? claim = freezed,
    Object? claimResponse = freezed,
    Object? outcome = freezed,
    Object? outcomeElement = freezed,
    Object? decision = freezed,
    Object? disposition = freezed,
    Object? dispositionElement = freezed,
    Object? preAuthRef = freezed,
    Object? preAuthRefElement = freezed,
    Object? preAuthRefPeriod = freezed,
    Object? diagnosisRelatedGroup = freezed,
    Object? careTeam = freezed,
    Object? supportingInfo = freezed,
    Object? diagnosis = freezed,
    Object? procedure = freezed,
    Object? precedence = freezed,
    Object? precedenceElement = freezed,
    Object? insurance = freezed,
    Object? accident = freezed,
    Object? patientPaid = freezed,
    Object? item = freezed,
    Object? addItem = freezed,
    Object? adjudication = freezed,
    Object? total = freezed,
    Object? payment = freezed,
    Object? formCode = freezed,
    Object? form = freezed,
    Object? processNote = freezed,
    Object? benefitPeriod = freezed,
    Object? benefitBalance = freezed,
  }) {
    return _then(_$ExplanationOfBenefitImpl(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      traceNumber: freezed == traceNumber
          ? _value._traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      subType: freezed == subType
          ? _value.subType
          : subType // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      use: freezed == use
          ? _value.use
          : use // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      useElement: freezed == useElement
          ? _value.useElement
          : useElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      patient: null == patient
          ? _value.patient
          : patient // ignore: cast_nullable_to_non_nullable
              as Reference,
      billablePeriod: freezed == billablePeriod
          ? _value.billablePeriod
          : billablePeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      created: freezed == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      createdElement: freezed == createdElement
          ? _value.createdElement
          : createdElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      enterer: freezed == enterer
          ? _value.enterer
          : enterer // ignore: cast_nullable_to_non_nullable
              as Reference?,
      insurer: freezed == insurer
          ? _value.insurer
          : insurer // ignore: cast_nullable_to_non_nullable
              as Reference?,
      provider: freezed == provider
          ? _value.provider
          : provider // ignore: cast_nullable_to_non_nullable
              as Reference?,
      priority: freezed == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      fundsReserveRequested: freezed == fundsReserveRequested
          ? _value.fundsReserveRequested
          : fundsReserveRequested // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      fundsReserve: freezed == fundsReserve
          ? _value.fundsReserve
          : fundsReserve // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      related: freezed == related
          ? _value._related
          : related // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitRelated>?,
      prescription: freezed == prescription
          ? _value.prescription
          : prescription // ignore: cast_nullable_to_non_nullable
              as Reference?,
      originalPrescription: freezed == originalPrescription
          ? _value.originalPrescription
          : originalPrescription // ignore: cast_nullable_to_non_nullable
              as Reference?,
      event: freezed == event
          ? _value._event
          : event // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitEvent>?,
      payee: freezed == payee
          ? _value.payee
          : payee // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitPayee?,
      referral: freezed == referral
          ? _value.referral
          : referral // ignore: cast_nullable_to_non_nullable
              as Reference?,
      encounter: freezed == encounter
          ? _value._encounter
          : encounter // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      facility: freezed == facility
          ? _value.facility
          : facility // ignore: cast_nullable_to_non_nullable
              as Reference?,
      claim: freezed == claim
          ? _value.claim
          : claim // ignore: cast_nullable_to_non_nullable
              as Reference?,
      claimResponse: freezed == claimResponse
          ? _value.claimResponse
          : claimResponse // ignore: cast_nullable_to_non_nullable
              as Reference?,
      outcome: freezed == outcome
          ? _value.outcome
          : outcome // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      outcomeElement: freezed == outcomeElement
          ? _value.outcomeElement
          : outcomeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      decision: freezed == decision
          ? _value.decision
          : decision // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      disposition: freezed == disposition
          ? _value.disposition
          : disposition // ignore: cast_nullable_to_non_nullable
              as String?,
      dispositionElement: freezed == dispositionElement
          ? _value.dispositionElement
          : dispositionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      preAuthRef: freezed == preAuthRef
          ? _value._preAuthRef
          : preAuthRef // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      preAuthRefElement: freezed == preAuthRefElement
          ? _value._preAuthRefElement
          : preAuthRefElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      preAuthRefPeriod: freezed == preAuthRefPeriod
          ? _value._preAuthRefPeriod
          : preAuthRefPeriod // ignore: cast_nullable_to_non_nullable
              as List<Period>?,
      diagnosisRelatedGroup: freezed == diagnosisRelatedGroup
          ? _value.diagnosisRelatedGroup
          : diagnosisRelatedGroup // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      careTeam: freezed == careTeam
          ? _value._careTeam
          : careTeam // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitCareTeam>?,
      supportingInfo: freezed == supportingInfo
          ? _value._supportingInfo
          : supportingInfo // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitSupportingInfo>?,
      diagnosis: freezed == diagnosis
          ? _value._diagnosis
          : diagnosis // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitDiagnosis>?,
      procedure: freezed == procedure
          ? _value._procedure
          : procedure // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitProcedure>?,
      precedence: freezed == precedence
          ? _value.precedence
          : precedence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      precedenceElement: freezed == precedenceElement
          ? _value.precedenceElement
          : precedenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      insurance: freezed == insurance
          ? _value._insurance
          : insurance // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitInsurance>?,
      accident: freezed == accident
          ? _value.accident
          : accident // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitAccident?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      item: freezed == item
          ? _value._item
          : item // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitItem>?,
      addItem: freezed == addItem
          ? _value._addItem
          : addItem // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAddItem>?,
      adjudication: freezed == adjudication
          ? _value._adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
      total: freezed == total
          ? _value._total
          : total // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitTotal>?,
      payment: freezed == payment
          ? _value.payment
          : payment // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitPayment?,
      formCode: freezed == formCode
          ? _value.formCode
          : formCode // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      form: freezed == form
          ? _value.form
          : form // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      processNote: freezed == processNote
          ? _value._processNote
          : processNote // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitProcessNote>?,
      benefitPeriod: freezed == benefitPeriod
          ? _value.benefitPeriod
          : benefitPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      benefitBalance: freezed == benefitBalance
          ? _value._benefitBalance
          : benefitBalance // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitBenefitBalance>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitImpl extends _ExplanationOfBenefit {
  const _$ExplanationOfBenefitImpl(
      {@JsonKey(unknownEnumValue: R6ResourceType.ExplanationOfBenefit)
      this.resourceType = R6ResourceType.ExplanationOfBenefit,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final List<Identifier>? traceNumber,
      this.status,
      @JsonKey(name: '_status') this.statusElement,
      required this.type,
      this.subType,
      this.use,
      @JsonKey(name: '_use') this.useElement,
      required this.patient,
      this.billablePeriod,
      this.created,
      @JsonKey(name: '_created') this.createdElement,
      this.enterer,
      this.insurer,
      this.provider,
      this.priority,
      this.fundsReserveRequested,
      this.fundsReserve,
      final List<ExplanationOfBenefitRelated>? related,
      this.prescription,
      this.originalPrescription,
      final List<ExplanationOfBenefitEvent>? event,
      this.payee,
      this.referral,
      final List<Reference>? encounter,
      this.facility,
      this.claim,
      this.claimResponse,
      this.outcome,
      @JsonKey(name: '_outcome') this.outcomeElement,
      this.decision,
      this.disposition,
      @JsonKey(name: '_disposition') this.dispositionElement,
      final List<String>? preAuthRef,
      @JsonKey(name: '_preAuthRef') final List<Element>? preAuthRefElement,
      final List<Period>? preAuthRefPeriod,
      this.diagnosisRelatedGroup,
      final List<ExplanationOfBenefitCareTeam>? careTeam,
      final List<ExplanationOfBenefitSupportingInfo>? supportingInfo,
      final List<ExplanationOfBenefitDiagnosis>? diagnosis,
      final List<ExplanationOfBenefitProcedure>? procedure,
      this.precedence,
      @JsonKey(name: '_precedence') this.precedenceElement,
      final List<ExplanationOfBenefitInsurance>? insurance,
      this.accident,
      this.patientPaid,
      final List<ExplanationOfBenefitItem>? item,
      final List<ExplanationOfBenefitAddItem>? addItem,
      final List<ExplanationOfBenefitAdjudication>? adjudication,
      final List<ExplanationOfBenefitTotal>? total,
      this.payment,
      this.formCode,
      this.form,
      final List<ExplanationOfBenefitProcessNote>? processNote,
      this.benefitPeriod,
      final List<ExplanationOfBenefitBenefitBalance>? benefitBalance})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _traceNumber = traceNumber,
        _related = related,
        _event = event,
        _encounter = encounter,
        _preAuthRef = preAuthRef,
        _preAuthRefElement = preAuthRefElement,
        _preAuthRefPeriod = preAuthRefPeriod,
        _careTeam = careTeam,
        _supportingInfo = supportingInfo,
        _diagnosis = diagnosis,
        _procedure = procedure,
        _insurance = insurance,
        _item = item,
        _addItem = addItem,
        _adjudication = adjudication,
        _total = total,
        _processNote = processNote,
        _benefitBalance = benefitBalance,
        super._();

  factory _$ExplanationOfBenefitImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitImplFromJson(json);

  /// [resourceType] This is a ExplanationOfBenefit resource
  @override
  @JsonKey(unknownEnumValue: R6ResourceType.ExplanationOfBenefit)
  final R6ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  @override
  final FhirMeta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final FhirCode? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] A unique identifier assigned to this explanation of
  ///  benefit.
  final List<Identifier>? _identifier;

  /// [identifier] A unique identifier assigned to this explanation of
  ///  benefit.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  final List<Identifier>? _traceNumber;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  @override
  List<Identifier>? get traceNumber {
    final value = _traceNumber;
    if (value == null) return null;
    if (_traceNumber is EqualUnmodifiableListView) return _traceNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [status] The status of the resource instance.
  @override
  final FhirCode? status;

  /// [statusElement] ("_status") Extensions for status
  @override
  @JsonKey(name: '_status')
  final Element? statusElement;

  /// [type] The category of claim, e.g. oral, pharmacy, vision,
  ///  institutional, professional.
  @override
  final CodeableConcept type;

  /// [subType] A finer grained suite of claim type codes which may convey
  ///  additional information such as Inpatient vs Outpatient and/or a
  ///  specialty service.
  @override
  final CodeableConcept? subType;

  /// [use] A code to indicate whether the nature of the request is: Claim -
  ///  A request to an Insurer to adjudicate the supplied charges for health
  ///  care goods and services under the identified policy and to pay the
  ///  determined Benefit amount, if any; Preauthorization - A request to an
  ///  Insurer to adjudicate the supplied proposed future charges for health
  ///  care goods and services under the identified policy and to approve the
  ///  services and provide the expected benefit amounts and potentially to
  ///  reserve funds to pay the benefits when Claims for the indicated
  ///  services are later submitted; or, Pre-determination - A request to an
  ///  Insurer to adjudicate the supplied 'what if' charges for health care
  ///  goods and services under the identified policy and report back what
  ///  the Benefit payable would be had the services actually been provided.
  @override
  final FhirCode? use;

  /// [useElement] ("_use") Extensions for use
  @override
  @JsonKey(name: '_use')
  final Element? useElement;

  /// [patient] The party to whom the professional services and/or products
  ///  have been supplied or are being considered and for whom actual for
  ///  forecast reimbursement is sought.
  @override
  final Reference patient;

  /// [billablePeriod] The period for which charges are being submitted.
  @override
  final Period? billablePeriod;

  /// [created] The date this resource was created.
  @override
  final FhirDateTime? created;

  /// [createdElement] ("_created") Extensions for created
  @override
  @JsonKey(name: '_created')
  final Element? createdElement;

  /// [enterer] Individual who created the claim, predetermination or
  ///  preauthorization.
  @override
  final Reference? enterer;

  /// [insurer] The party responsible for authorization, adjudication and
  ///  reimbursement.
  @override
  final Reference? insurer;

  /// [provider] The provider which is responsible for the claim,
  ///  predetermination or preauthorization.
  @override
  final Reference? provider;

  /// [priority] The provider-required urgency of processing the request.
  ///  Typical values include: stat, normal deferred.
  @override
  final CodeableConcept? priority;

  /// [fundsReserveRequested] A code to indicate whether and for whom funds
  ///  are to be reserved for future claims.
  @override
  final CodeableConcept? fundsReserveRequested;

  /// [fundsReserve] A code, used only on a response to a preauthorization,
  ///  to indicate whether the benefits payable have been reserved and for
  ///  whom.
  @override
  final CodeableConcept? fundsReserve;

  /// [related] Other claims which are related to this claim such as prior
  ///  submissions or claims for related services or for the same event.
  final List<ExplanationOfBenefitRelated>? _related;

  /// [related] Other claims which are related to this claim such as prior
  ///  submissions or claims for related services or for the same event.
  @override
  List<ExplanationOfBenefitRelated>? get related {
    final value = _related;
    if (value == null) return null;
    if (_related is EqualUnmodifiableListView) return _related;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [prescription] Prescription is the document/authorization given to the
  ///  claim author for them to provide products and services for which
  ///  consideration (reimbursement) is sought. Could be a RX for
  ///  medications, an 'order' for oxygen or wheelchair or physiotherapy
  ///  treatments.
  @override
  final Reference? prescription;

  /// [originalPrescription] Original prescription which has been superseded
  ///  by this prescription to support the dispensing of pharmacy services,
  ///  medications or products.
  @override
  final Reference? originalPrescription;

  /// [event] Information code for an event with a corresponding date or
  ///  period.
  final List<ExplanationOfBenefitEvent>? _event;

  /// [event] Information code for an event with a corresponding date or
  ///  period.
  @override
  List<ExplanationOfBenefitEvent>? get event {
    final value = _event;
    if (value == null) return null;
    if (_event is EqualUnmodifiableListView) return _event;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [payee] The party to be reimbursed for cost of the products and
  ///  services according to the terms of the policy.
  @override
  final ExplanationOfBenefitPayee? payee;

  /// [referral] The referral information received by the claim author, it is
  ///  not to be used when the author generates a referral for a patient. A
  ///  copy of that referral may be provided as supporting information. Some
  ///  insurers require proof of referral to pay for services or to pay
  ///  specialist rates for services.
  @override
  final Reference? referral;

  /// [encounter] Healthcare encounters related to this claim.
  final List<Reference>? _encounter;

  /// [encounter] Healthcare encounters related to this claim.
  @override
  List<Reference>? get encounter {
    final value = _encounter;
    if (value == null) return null;
    if (_encounter is EqualUnmodifiableListView) return _encounter;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [facility] Facility where the services were provided.
  @override
  final Reference? facility;

  /// [claim] The business identifier for the instance of the adjudication
  ///  request: claim predetermination or preauthorization.
  @override
  final Reference? claim;

  /// [claimResponse] The business identifier for the instance of the
  ///  adjudication response: claim, predetermination or preauthorization
  ///  response.
  @override
  final Reference? claimResponse;

  /// [outcome] The outcome of the claim, predetermination, or
  ///  preauthorization processing.
  @override
  final FhirCode? outcome;

  /// [outcomeElement] ("_outcome") Extensions for outcome
  @override
  @JsonKey(name: '_outcome')
  final Element? outcomeElement;

  /// [decision] The result of the claim, predetermination, or
  ///  preauthorization adjudication.
  @override
  final CodeableConcept? decision;

  /// [disposition] A human readable description of the status of the
  ///  adjudication.
  @override
  final String? disposition;

  /// [dispositionElement] ("_disposition") Extensions for disposition
  @override
  @JsonKey(name: '_disposition')
  final Element? dispositionElement;

  /// [preAuthRef] Reference from the Insurer which is used in later
  ///  communications which refers to this adjudication.
  final List<String>? _preAuthRef;

  /// [preAuthRef] Reference from the Insurer which is used in later
  ///  communications which refers to this adjudication.
  @override
  List<String>? get preAuthRef {
    final value = _preAuthRef;
    if (value == null) return null;
    if (_preAuthRef is EqualUnmodifiableListView) return _preAuthRef;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [preAuthRefElement] ("_preAuthRef") Extensions for preAuthRef
  final List<Element>? _preAuthRefElement;

  /// [preAuthRefElement] ("_preAuthRef") Extensions for preAuthRef
  @override
  @JsonKey(name: '_preAuthRef')
  List<Element>? get preAuthRefElement {
    final value = _preAuthRefElement;
    if (value == null) return null;
    if (_preAuthRefElement is EqualUnmodifiableListView)
      return _preAuthRefElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [preAuthRefPeriod] The timeframe during which the supplied
  ///  preauthorization reference may be quoted on claims to obtain the
  ///  adjudication as provided.
  final List<Period>? _preAuthRefPeriod;

  /// [preAuthRefPeriod] The timeframe during which the supplied
  ///  preauthorization reference may be quoted on claims to obtain the
  ///  adjudication as provided.
  @override
  List<Period>? get preAuthRefPeriod {
    final value = _preAuthRefPeriod;
    if (value == null) return null;
    if (_preAuthRefPeriod is EqualUnmodifiableListView)
      return _preAuthRefPeriod;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [diagnosisRelatedGroup] A package billing code or bundle code used to
  ///  group products and services to a particular health condition (such as
  ///  heart attack) which is based on a predetermined grouping code system.
  @override
  final CodeableConcept? diagnosisRelatedGroup;

  /// [careTeam] The members of the team who provided the products and
  ///  services.
  final List<ExplanationOfBenefitCareTeam>? _careTeam;

  /// [careTeam] The members of the team who provided the products and
  ///  services.
  @override
  List<ExplanationOfBenefitCareTeam>? get careTeam {
    final value = _careTeam;
    if (value == null) return null;
    if (_careTeam is EqualUnmodifiableListView) return _careTeam;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [supportingInfo] Additional information codes regarding exceptions,
  ///  special considerations, the condition, situation, prior or concurrent
  ///  issues.
  final List<ExplanationOfBenefitSupportingInfo>? _supportingInfo;

  /// [supportingInfo] Additional information codes regarding exceptions,
  ///  special considerations, the condition, situation, prior or concurrent
  ///  issues.
  @override
  List<ExplanationOfBenefitSupportingInfo>? get supportingInfo {
    final value = _supportingInfo;
    if (value == null) return null;
    if (_supportingInfo is EqualUnmodifiableListView) return _supportingInfo;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [diagnosis] Information about diagnoses relevant to the claim items.
  final List<ExplanationOfBenefitDiagnosis>? _diagnosis;

  /// [diagnosis] Information about diagnoses relevant to the claim items.
  @override
  List<ExplanationOfBenefitDiagnosis>? get diagnosis {
    final value = _diagnosis;
    if (value == null) return null;
    if (_diagnosis is EqualUnmodifiableListView) return _diagnosis;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [procedure] Procedures performed on the patient relevant to the billing
  ///  items with the claim.
  final List<ExplanationOfBenefitProcedure>? _procedure;

  /// [procedure] Procedures performed on the patient relevant to the billing
  ///  items with the claim.
  @override
  List<ExplanationOfBenefitProcedure>? get procedure {
    final value = _procedure;
    if (value == null) return null;
    if (_procedure is EqualUnmodifiableListView) return _procedure;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [precedence] This indicates the relative order of a series of EOBs
  ///  related to different coverages for the same suite of services.
  @override
  final FhirPositiveInt? precedence;

  /// [precedenceElement] ("_precedence") Extensions for precedence
  @override
  @JsonKey(name: '_precedence')
  final Element? precedenceElement;

  /// [insurance] Financial instruments for reimbursement for the health care
  ///  products and services specified on the claim.
  final List<ExplanationOfBenefitInsurance>? _insurance;

  /// [insurance] Financial instruments for reimbursement for the health care
  ///  products and services specified on the claim.
  @override
  List<ExplanationOfBenefitInsurance>? get insurance {
    final value = _insurance;
    if (value == null) return null;
    if (_insurance is EqualUnmodifiableListView) return _insurance;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [accident] Details of a accident which resulted in injuries which
  ///  required the products and services listed in the claim.
  @override
  final ExplanationOfBenefitAccident? accident;

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  @override
  final Money? patientPaid;

  /// [item] A claim line. Either a simple (a product or service) or a
  ///  'group' of details which can also be a simple items or groups of
  ///  sub-details.
  final List<ExplanationOfBenefitItem>? _item;

  /// [item] A claim line. Either a simple (a product or service) or a
  ///  'group' of details which can also be a simple items or groups of
  ///  sub-details.
  @override
  List<ExplanationOfBenefitItem>? get item {
    final value = _item;
    if (value == null) return null;
    if (_item is EqualUnmodifiableListView) return _item;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [addItem] The first-tier service adjudications for payor added product
  ///  or service lines.
  final List<ExplanationOfBenefitAddItem>? _addItem;

  /// [addItem] The first-tier service adjudications for payor added product
  ///  or service lines.
  @override
  List<ExplanationOfBenefitAddItem>? get addItem {
    final value = _addItem;
    if (value == null) return null;
    if (_addItem is EqualUnmodifiableListView) return _addItem;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [adjudication] The adjudication results which are presented at the
  ///  header level rather than at the line-item or add-item levels.
  final List<ExplanationOfBenefitAdjudication>? _adjudication;

  /// [adjudication] The adjudication results which are presented at the
  ///  header level rather than at the line-item or add-item levels.
  @override
  List<ExplanationOfBenefitAdjudication>? get adjudication {
    final value = _adjudication;
    if (value == null) return null;
    if (_adjudication is EqualUnmodifiableListView) return _adjudication;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [total] Categorized monetary totals for the adjudication.
  final List<ExplanationOfBenefitTotal>? _total;

  /// [total] Categorized monetary totals for the adjudication.
  @override
  List<ExplanationOfBenefitTotal>? get total {
    final value = _total;
    if (value == null) return null;
    if (_total is EqualUnmodifiableListView) return _total;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [payment] Payment details for the adjudication of the claim.
  @override
  final ExplanationOfBenefitPayment? payment;

  /// [formCode] A code for the form to be used for printing the content.
  @override
  final CodeableConcept? formCode;

  /// [form] The actual form, by reference or inclusion, for printing the
  ///  content or an EOB.
  @override
  final Attachment? form;

  /// [processNote] A note that describes or explains adjudication results in
  ///  a human readable form.
  final List<ExplanationOfBenefitProcessNote>? _processNote;

  /// [processNote] A note that describes or explains adjudication results in
  ///  a human readable form.
  @override
  List<ExplanationOfBenefitProcessNote>? get processNote {
    final value = _processNote;
    if (value == null) return null;
    if (_processNote is EqualUnmodifiableListView) return _processNote;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [benefitPeriod] The term of the benefits documented in this response.
  @override
  final Period? benefitPeriod;

  /// [benefitBalance] Balance by Benefit Category.
  final List<ExplanationOfBenefitBenefitBalance>? _benefitBalance;

  /// [benefitBalance] Balance by Benefit Category.
  @override
  List<ExplanationOfBenefitBenefitBalance>? get benefitBalance {
    final value = _benefitBalance;
    if (value == null) return null;
    if (_benefitBalance is EqualUnmodifiableListView) return _benefitBalance;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExplanationOfBenefit(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, traceNumber: $traceNumber, status: $status, statusElement: $statusElement, type: $type, subType: $subType, use: $use, useElement: $useElement, patient: $patient, billablePeriod: $billablePeriod, created: $created, createdElement: $createdElement, enterer: $enterer, insurer: $insurer, provider: $provider, priority: $priority, fundsReserveRequested: $fundsReserveRequested, fundsReserve: $fundsReserve, related: $related, prescription: $prescription, originalPrescription: $originalPrescription, event: $event, payee: $payee, referral: $referral, encounter: $encounter, facility: $facility, claim: $claim, claimResponse: $claimResponse, outcome: $outcome, outcomeElement: $outcomeElement, decision: $decision, disposition: $disposition, dispositionElement: $dispositionElement, preAuthRef: $preAuthRef, preAuthRefElement: $preAuthRefElement, preAuthRefPeriod: $preAuthRefPeriod, diagnosisRelatedGroup: $diagnosisRelatedGroup, careTeam: $careTeam, supportingInfo: $supportingInfo, diagnosis: $diagnosis, procedure: $procedure, precedence: $precedence, precedenceElement: $precedenceElement, insurance: $insurance, accident: $accident, patientPaid: $patientPaid, item: $item, addItem: $addItem, adjudication: $adjudication, total: $total, payment: $payment, formCode: $formCode, form: $form, processNote: $processNote, benefitPeriod: $benefitPeriod, benefitBalance: $benefitBalance)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitImpl &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            const DeepCollectionEquality()
                .equals(other._traceNumber, _traceNumber) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusElement, statusElement) ||
                other.statusElement == statusElement) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.subType, subType) || other.subType == subType) &&
            (identical(other.use, use) || other.use == use) &&
            (identical(other.useElement, useElement) ||
                other.useElement == useElement) &&
            (identical(other.patient, patient) || other.patient == patient) &&
            (identical(other.billablePeriod, billablePeriod) ||
                other.billablePeriod == billablePeriod) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.createdElement, createdElement) ||
                other.createdElement == createdElement) &&
            (identical(other.enterer, enterer) || other.enterer == enterer) &&
            (identical(other.insurer, insurer) || other.insurer == insurer) &&
            (identical(other.provider, provider) ||
                other.provider == provider) &&
            (identical(other.priority, priority) ||
                other.priority == priority) &&
            (identical(other.fundsReserveRequested, fundsReserveRequested) ||
                other.fundsReserveRequested == fundsReserveRequested) &&
            (identical(other.fundsReserve, fundsReserve) ||
                other.fundsReserve == fundsReserve) &&
            const DeepCollectionEquality().equals(other._related, _related) &&
            (identical(other.prescription, prescription) ||
                other.prescription == prescription) &&
            (identical(other.originalPrescription, originalPrescription) ||
                other.originalPrescription == originalPrescription) &&
            const DeepCollectionEquality().equals(other._event, _event) &&
            (identical(other.payee, payee) || other.payee == payee) &&
            (identical(other.referral, referral) ||
                other.referral == referral) &&
            const DeepCollectionEquality()
                .equals(other._encounter, _encounter) &&
            (identical(other.facility, facility) ||
                other.facility == facility) &&
            (identical(other.claim, claim) || other.claim == claim) &&
            (identical(other.claimResponse, claimResponse) ||
                other.claimResponse == claimResponse) &&
            (identical(other.outcome, outcome) || other.outcome == outcome) &&
            (identical(other.outcomeElement, outcomeElement) ||
                other.outcomeElement == outcomeElement) &&
            (identical(other.decision, decision) ||
                other.decision == decision) &&
            (identical(other.disposition, disposition) ||
                other.disposition == disposition) &&
            (identical(other.dispositionElement, dispositionElement) ||
                other.dispositionElement == dispositionElement) &&
            const DeepCollectionEquality()
                .equals(other._preAuthRef, _preAuthRef) &&
            const DeepCollectionEquality()
                .equals(other._preAuthRefElement, _preAuthRefElement) &&
            const DeepCollectionEquality()
                .equals(other._preAuthRefPeriod, _preAuthRefPeriod) &&
            (identical(other.diagnosisRelatedGroup, diagnosisRelatedGroup) ||
                other.diagnosisRelatedGroup == diagnosisRelatedGroup) &&
            const DeepCollectionEquality().equals(other._careTeam, _careTeam) &&
            const DeepCollectionEquality()
                .equals(other._supportingInfo, _supportingInfo) &&
            const DeepCollectionEquality()
                .equals(other._diagnosis, _diagnosis) &&
            const DeepCollectionEquality()
                .equals(other._procedure, _procedure) &&
            (identical(other.precedence, precedence) ||
                other.precedence == precedence) &&
            (identical(other.precedenceElement, precedenceElement) ||
                other.precedenceElement == precedenceElement) &&
            const DeepCollectionEquality()
                .equals(other._insurance, _insurance) &&
            (identical(other.accident, accident) ||
                other.accident == accident) &&
            (identical(other.patientPaid, patientPaid) ||
                other.patientPaid == patientPaid) &&
            const DeepCollectionEquality().equals(other._item, _item) &&
            const DeepCollectionEquality().equals(other._addItem, _addItem) &&
            const DeepCollectionEquality()
                .equals(other._adjudication, _adjudication) &&
            const DeepCollectionEquality().equals(other._total, _total) &&
            (identical(other.payment, payment) || other.payment == payment) &&
            (identical(other.formCode, formCode) ||
                other.formCode == formCode) &&
            (identical(other.form, form) || other.form == form) &&
            const DeepCollectionEquality()
                .equals(other._processNote, _processNote) &&
            (identical(other.benefitPeriod, benefitPeriod) || other.benefitPeriod == benefitPeriod) &&
            const DeepCollectionEquality().equals(other._benefitBalance, _benefitBalance));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        const DeepCollectionEquality().hash(_traceNumber),
        status,
        statusElement,
        type,
        subType,
        use,
        useElement,
        patient,
        billablePeriod,
        created,
        createdElement,
        enterer,
        insurer,
        provider,
        priority,
        fundsReserveRequested,
        fundsReserve,
        const DeepCollectionEquality().hash(_related),
        prescription,
        originalPrescription,
        const DeepCollectionEquality().hash(_event),
        payee,
        referral,
        const DeepCollectionEquality().hash(_encounter),
        facility,
        claim,
        claimResponse,
        outcome,
        outcomeElement,
        decision,
        disposition,
        dispositionElement,
        const DeepCollectionEquality().hash(_preAuthRef),
        const DeepCollectionEquality().hash(_preAuthRefElement),
        const DeepCollectionEquality().hash(_preAuthRefPeriod),
        diagnosisRelatedGroup,
        const DeepCollectionEquality().hash(_careTeam),
        const DeepCollectionEquality().hash(_supportingInfo),
        const DeepCollectionEquality().hash(_diagnosis),
        const DeepCollectionEquality().hash(_procedure),
        precedence,
        precedenceElement,
        const DeepCollectionEquality().hash(_insurance),
        accident,
        patientPaid,
        const DeepCollectionEquality().hash(_item),
        const DeepCollectionEquality().hash(_addItem),
        const DeepCollectionEquality().hash(_adjudication),
        const DeepCollectionEquality().hash(_total),
        payment,
        formCode,
        form,
        const DeepCollectionEquality().hash(_processNote),
        benefitPeriod,
        const DeepCollectionEquality().hash(_benefitBalance)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitImplCopyWith<_$ExplanationOfBenefitImpl>
      get copyWith =>
          __$$ExplanationOfBenefitImplCopyWithImpl<_$ExplanationOfBenefitImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefit extends ExplanationOfBenefit {
  const factory _ExplanationOfBenefit(
          {@JsonKey(unknownEnumValue: R6ResourceType.ExplanationOfBenefit)
          final R6ResourceType resourceType,
          final FhirId? id,
          final FhirMeta? meta,
          final FhirUri? implicitRules,
          @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
          final FhirCode? language,
          @JsonKey(name: '_language') final Element? languageElement,
          final Narrative? text,
          final List<Resource>? contained,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Identifier>? identifier,
          final List<Identifier>? traceNumber,
          final FhirCode? status,
          @JsonKey(name: '_status') final Element? statusElement,
          required final CodeableConcept type,
          final CodeableConcept? subType,
          final FhirCode? use,
          @JsonKey(name: '_use') final Element? useElement,
          required final Reference patient,
          final Period? billablePeriod,
          final FhirDateTime? created,
          @JsonKey(name: '_created') final Element? createdElement,
          final Reference? enterer,
          final Reference? insurer,
          final Reference? provider,
          final CodeableConcept? priority,
          final CodeableConcept? fundsReserveRequested,
          final CodeableConcept? fundsReserve,
          final List<ExplanationOfBenefitRelated>? related,
          final Reference? prescription,
          final Reference? originalPrescription,
          final List<ExplanationOfBenefitEvent>? event,
          final ExplanationOfBenefitPayee? payee,
          final Reference? referral,
          final List<Reference>? encounter,
          final Reference? facility,
          final Reference? claim,
          final Reference? claimResponse,
          final FhirCode? outcome,
          @JsonKey(name: '_outcome') final Element? outcomeElement,
          final CodeableConcept? decision,
          final String? disposition,
          @JsonKey(name: '_disposition') final Element? dispositionElement,
          final List<String>? preAuthRef,
          @JsonKey(name: '_preAuthRef') final List<Element>? preAuthRefElement,
          final List<Period>? preAuthRefPeriod,
          final CodeableConcept? diagnosisRelatedGroup,
          final List<ExplanationOfBenefitCareTeam>? careTeam,
          final List<ExplanationOfBenefitSupportingInfo>? supportingInfo,
          final List<ExplanationOfBenefitDiagnosis>? diagnosis,
          final List<ExplanationOfBenefitProcedure>? procedure,
          final FhirPositiveInt? precedence,
          @JsonKey(name: '_precedence') final Element? precedenceElement,
          final List<ExplanationOfBenefitInsurance>? insurance,
          final ExplanationOfBenefitAccident? accident,
          final Money? patientPaid,
          final List<ExplanationOfBenefitItem>? item,
          final List<ExplanationOfBenefitAddItem>? addItem,
          final List<ExplanationOfBenefitAdjudication>? adjudication,
          final List<ExplanationOfBenefitTotal>? total,
          final ExplanationOfBenefitPayment? payment,
          final CodeableConcept? formCode,
          final Attachment? form,
          final List<ExplanationOfBenefitProcessNote>? processNote,
          final Period? benefitPeriod,
          final List<ExplanationOfBenefitBenefitBalance>? benefitBalance}) =
      _$ExplanationOfBenefitImpl;
  const _ExplanationOfBenefit._() : super._();

  factory _ExplanationOfBenefit.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitImpl.fromJson;

  @override

  /// [resourceType] This is a ExplanationOfBenefit resource
  @JsonKey(unknownEnumValue: R6ResourceType.ExplanationOfBenefit)
  R6ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  FhirMeta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  FhirCode? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] A unique identifier assigned to this explanation of
  ///  benefit.
  List<Identifier>? get identifier;
  @override

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber;
  @override

  /// [status] The status of the resource instance.
  FhirCode? get status;
  @override

  /// [statusElement] ("_status") Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement;
  @override

  /// [type] The category of claim, e.g. oral, pharmacy, vision,
  ///  institutional, professional.
  CodeableConcept get type;
  @override

  /// [subType] A finer grained suite of claim type codes which may convey
  ///  additional information such as Inpatient vs Outpatient and/or a
  ///  specialty service.
  CodeableConcept? get subType;
  @override

  /// [use] A code to indicate whether the nature of the request is: Claim -
  ///  A request to an Insurer to adjudicate the supplied charges for health
  ///  care goods and services under the identified policy and to pay the
  ///  determined Benefit amount, if any; Preauthorization - A request to an
  ///  Insurer to adjudicate the supplied proposed future charges for health
  ///  care goods and services under the identified policy and to approve the
  ///  services and provide the expected benefit amounts and potentially to
  ///  reserve funds to pay the benefits when Claims for the indicated
  ///  services are later submitted; or, Pre-determination - A request to an
  ///  Insurer to adjudicate the supplied 'what if' charges for health care
  ///  goods and services under the identified policy and report back what
  ///  the Benefit payable would be had the services actually been provided.
  FhirCode? get use;
  @override

  /// [useElement] ("_use") Extensions for use
  @JsonKey(name: '_use')
  Element? get useElement;
  @override

  /// [patient] The party to whom the professional services and/or products
  ///  have been supplied or are being considered and for whom actual for
  ///  forecast reimbursement is sought.
  Reference get patient;
  @override

  /// [billablePeriod] The period for which charges are being submitted.
  Period? get billablePeriod;
  @override

  /// [created] The date this resource was created.
  FhirDateTime? get created;
  @override

  /// [createdElement] ("_created") Extensions for created
  @JsonKey(name: '_created')
  Element? get createdElement;
  @override

  /// [enterer] Individual who created the claim, predetermination or
  ///  preauthorization.
  Reference? get enterer;
  @override

  /// [insurer] The party responsible for authorization, adjudication and
  ///  reimbursement.
  Reference? get insurer;
  @override

  /// [provider] The provider which is responsible for the claim,
  ///  predetermination or preauthorization.
  Reference? get provider;
  @override

  /// [priority] The provider-required urgency of processing the request.
  ///  Typical values include: stat, normal deferred.
  CodeableConcept? get priority;
  @override

  /// [fundsReserveRequested] A code to indicate whether and for whom funds
  ///  are to be reserved for future claims.
  CodeableConcept? get fundsReserveRequested;
  @override

  /// [fundsReserve] A code, used only on a response to a preauthorization,
  ///  to indicate whether the benefits payable have been reserved and for
  ///  whom.
  CodeableConcept? get fundsReserve;
  @override

  /// [related] Other claims which are related to this claim such as prior
  ///  submissions or claims for related services or for the same event.
  List<ExplanationOfBenefitRelated>? get related;
  @override

  /// [prescription] Prescription is the document/authorization given to the
  ///  claim author for them to provide products and services for which
  ///  consideration (reimbursement) is sought. Could be a RX for
  ///  medications, an 'order' for oxygen or wheelchair or physiotherapy
  ///  treatments.
  Reference? get prescription;
  @override

  /// [originalPrescription] Original prescription which has been superseded
  ///  by this prescription to support the dispensing of pharmacy services,
  ///  medications or products.
  Reference? get originalPrescription;
  @override

  /// [event] Information code for an event with a corresponding date or
  ///  period.
  List<ExplanationOfBenefitEvent>? get event;
  @override

  /// [payee] The party to be reimbursed for cost of the products and
  ///  services according to the terms of the policy.
  ExplanationOfBenefitPayee? get payee;
  @override

  /// [referral] The referral information received by the claim author, it is
  ///  not to be used when the author generates a referral for a patient. A
  ///  copy of that referral may be provided as supporting information. Some
  ///  insurers require proof of referral to pay for services or to pay
  ///  specialist rates for services.
  Reference? get referral;
  @override

  /// [encounter] Healthcare encounters related to this claim.
  List<Reference>? get encounter;
  @override

  /// [facility] Facility where the services were provided.
  Reference? get facility;
  @override

  /// [claim] The business identifier for the instance of the adjudication
  ///  request: claim predetermination or preauthorization.
  Reference? get claim;
  @override

  /// [claimResponse] The business identifier for the instance of the
  ///  adjudication response: claim, predetermination or preauthorization
  ///  response.
  Reference? get claimResponse;
  @override

  /// [outcome] The outcome of the claim, predetermination, or
  ///  preauthorization processing.
  FhirCode? get outcome;
  @override

  /// [outcomeElement] ("_outcome") Extensions for outcome
  @JsonKey(name: '_outcome')
  Element? get outcomeElement;
  @override

  /// [decision] The result of the claim, predetermination, or
  ///  preauthorization adjudication.
  CodeableConcept? get decision;
  @override

  /// [disposition] A human readable description of the status of the
  ///  adjudication.
  String? get disposition;
  @override

  /// [dispositionElement] ("_disposition") Extensions for disposition
  @JsonKey(name: '_disposition')
  Element? get dispositionElement;
  @override

  /// [preAuthRef] Reference from the Insurer which is used in later
  ///  communications which refers to this adjudication.
  List<String>? get preAuthRef;
  @override

  /// [preAuthRefElement] ("_preAuthRef") Extensions for preAuthRef
  @JsonKey(name: '_preAuthRef')
  List<Element>? get preAuthRefElement;
  @override

  /// [preAuthRefPeriod] The timeframe during which the supplied
  ///  preauthorization reference may be quoted on claims to obtain the
  ///  adjudication as provided.
  List<Period>? get preAuthRefPeriod;
  @override

  /// [diagnosisRelatedGroup] A package billing code or bundle code used to
  ///  group products and services to a particular health condition (such as
  ///  heart attack) which is based on a predetermined grouping code system.
  CodeableConcept? get diagnosisRelatedGroup;
  @override

  /// [careTeam] The members of the team who provided the products and
  ///  services.
  List<ExplanationOfBenefitCareTeam>? get careTeam;
  @override

  /// [supportingInfo] Additional information codes regarding exceptions,
  ///  special considerations, the condition, situation, prior or concurrent
  ///  issues.
  List<ExplanationOfBenefitSupportingInfo>? get supportingInfo;
  @override

  /// [diagnosis] Information about diagnoses relevant to the claim items.
  List<ExplanationOfBenefitDiagnosis>? get diagnosis;
  @override

  /// [procedure] Procedures performed on the patient relevant to the billing
  ///  items with the claim.
  List<ExplanationOfBenefitProcedure>? get procedure;
  @override

  /// [precedence] This indicates the relative order of a series of EOBs
  ///  related to different coverages for the same suite of services.
  FhirPositiveInt? get precedence;
  @override

  /// [precedenceElement] ("_precedence") Extensions for precedence
  @JsonKey(name: '_precedence')
  Element? get precedenceElement;
  @override

  /// [insurance] Financial instruments for reimbursement for the health care
  ///  products and services specified on the claim.
  List<ExplanationOfBenefitInsurance>? get insurance;
  @override

  /// [accident] Details of a accident which resulted in injuries which
  ///  required the products and services listed in the claim.
  ExplanationOfBenefitAccident? get accident;
  @override

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid;
  @override

  /// [item] A claim line. Either a simple (a product or service) or a
  ///  'group' of details which can also be a simple items or groups of
  ///  sub-details.
  List<ExplanationOfBenefitItem>? get item;
  @override

  /// [addItem] The first-tier service adjudications for payor added product
  ///  or service lines.
  List<ExplanationOfBenefitAddItem>? get addItem;
  @override

  /// [adjudication] The adjudication results which are presented at the
  ///  header level rather than at the line-item or add-item levels.
  List<ExplanationOfBenefitAdjudication>? get adjudication;
  @override

  /// [total] Categorized monetary totals for the adjudication.
  List<ExplanationOfBenefitTotal>? get total;
  @override

  /// [payment] Payment details for the adjudication of the claim.
  ExplanationOfBenefitPayment? get payment;
  @override

  /// [formCode] A code for the form to be used for printing the content.
  CodeableConcept? get formCode;
  @override

  /// [form] The actual form, by reference or inclusion, for printing the
  ///  content or an EOB.
  Attachment? get form;
  @override

  /// [processNote] A note that describes or explains adjudication results in
  ///  a human readable form.
  List<ExplanationOfBenefitProcessNote>? get processNote;
  @override

  /// [benefitPeriod] The term of the benefits documented in this response.
  Period? get benefitPeriod;
  @override

  /// [benefitBalance] Balance by Benefit Category.
  List<ExplanationOfBenefitBenefitBalance>? get benefitBalance;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitImplCopyWith<_$ExplanationOfBenefitImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitRelated _$ExplanationOfBenefitRelatedFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitRelated.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitRelated {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [claim] Reference to a related claim.
  Reference? get claim => throw _privateConstructorUsedError;

  /// [relationship] A code to convey how the claims are related.
  CodeableConcept? get relationship => throw _privateConstructorUsedError;

  /// [reference] An alternate organizational reference to the case or file
  ///  to which this particular claim pertains.
  Identifier? get reference => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitRelatedCopyWith<ExplanationOfBenefitRelated>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitRelatedCopyWith<$Res> {
  factory $ExplanationOfBenefitRelatedCopyWith(
          ExplanationOfBenefitRelated value,
          $Res Function(ExplanationOfBenefitRelated) then) =
      _$ExplanationOfBenefitRelatedCopyWithImpl<$Res,
          ExplanationOfBenefitRelated>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference? claim,
      CodeableConcept? relationship,
      Identifier? reference});

  $ReferenceCopyWith<$Res>? get claim;
  $CodeableConceptCopyWith<$Res>? get relationship;
  $IdentifierCopyWith<$Res>? get reference;
}

/// @nodoc
class _$ExplanationOfBenefitRelatedCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitRelated>
    implements $ExplanationOfBenefitRelatedCopyWith<$Res> {
  _$ExplanationOfBenefitRelatedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? claim = freezed,
    Object? relationship = freezed,
    Object? reference = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      claim: freezed == claim
          ? _value.claim
          : claim // ignore: cast_nullable_to_non_nullable
              as Reference?,
      relationship: freezed == relationship
          ? _value.relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      reference: freezed == reference
          ? _value.reference
          : reference // ignore: cast_nullable_to_non_nullable
              as Identifier?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get claim {
    if (_value.claim == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.claim!, (value) {
      return _then(_value.copyWith(claim: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get relationship {
    if (_value.relationship == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.relationship!, (value) {
      return _then(_value.copyWith(relationship: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get reference {
    if (_value.reference == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.reference!, (value) {
      return _then(_value.copyWith(reference: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitRelatedImplCopyWith<$Res>
    implements $ExplanationOfBenefitRelatedCopyWith<$Res> {
  factory _$$ExplanationOfBenefitRelatedImplCopyWith(
          _$ExplanationOfBenefitRelatedImpl value,
          $Res Function(_$ExplanationOfBenefitRelatedImpl) then) =
      __$$ExplanationOfBenefitRelatedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference? claim,
      CodeableConcept? relationship,
      Identifier? reference});

  @override
  $ReferenceCopyWith<$Res>? get claim;
  @override
  $CodeableConceptCopyWith<$Res>? get relationship;
  @override
  $IdentifierCopyWith<$Res>? get reference;
}

/// @nodoc
class __$$ExplanationOfBenefitRelatedImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitRelatedCopyWithImpl<$Res,
        _$ExplanationOfBenefitRelatedImpl>
    implements _$$ExplanationOfBenefitRelatedImplCopyWith<$Res> {
  __$$ExplanationOfBenefitRelatedImplCopyWithImpl(
      _$ExplanationOfBenefitRelatedImpl _value,
      $Res Function(_$ExplanationOfBenefitRelatedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? claim = freezed,
    Object? relationship = freezed,
    Object? reference = freezed,
  }) {
    return _then(_$ExplanationOfBenefitRelatedImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      claim: freezed == claim
          ? _value.claim
          : claim // ignore: cast_nullable_to_non_nullable
              as Reference?,
      relationship: freezed == relationship
          ? _value.relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      reference: freezed == reference
          ? _value.reference
          : reference // ignore: cast_nullable_to_non_nullable
              as Identifier?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitRelatedImpl extends _ExplanationOfBenefitRelated {
  const _$ExplanationOfBenefitRelatedImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.claim,
      this.relationship,
      this.reference})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ExplanationOfBenefitRelatedImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitRelatedImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [claim] Reference to a related claim.
  @override
  final Reference? claim;

  /// [relationship] A code to convey how the claims are related.
  @override
  final CodeableConcept? relationship;

  /// [reference] An alternate organizational reference to the case or file
  ///  to which this particular claim pertains.
  @override
  final Identifier? reference;

  @override
  String toString() {
    return 'ExplanationOfBenefitRelated(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, claim: $claim, relationship: $relationship, reference: $reference)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitRelatedImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.claim, claim) || other.claim == claim) &&
            (identical(other.relationship, relationship) ||
                other.relationship == relationship) &&
            (identical(other.reference, reference) ||
                other.reference == reference));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      claim,
      relationship,
      reference);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitRelatedImplCopyWith<_$ExplanationOfBenefitRelatedImpl>
      get copyWith => __$$ExplanationOfBenefitRelatedImplCopyWithImpl<
          _$ExplanationOfBenefitRelatedImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitRelatedImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitRelated
    extends ExplanationOfBenefitRelated {
  const factory _ExplanationOfBenefitRelated(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Reference? claim,
      final CodeableConcept? relationship,
      final Identifier? reference}) = _$ExplanationOfBenefitRelatedImpl;
  const _ExplanationOfBenefitRelated._() : super._();

  factory _ExplanationOfBenefitRelated.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitRelatedImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [claim] Reference to a related claim.
  Reference? get claim;
  @override

  /// [relationship] A code to convey how the claims are related.
  CodeableConcept? get relationship;
  @override

  /// [reference] An alternate organizational reference to the case or file
  ///  to which this particular claim pertains.
  Identifier? get reference;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitRelatedImplCopyWith<_$ExplanationOfBenefitRelatedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitEvent _$ExplanationOfBenefitEventFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitEvent.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitEvent {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] A coded event such as when a service is expected or a card
  ///  printed.
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [whenDateTime] A date or period in the past or future indicating when
  ///  the event occurred or is expectd to occur.
  FhirDateTime? get whenDateTime => throw _privateConstructorUsedError;

  /// [whenDateTimeElement] ("_whenDateTime") Extensions for whenDateTime
  @JsonKey(name: '_whenDateTime')
  Element? get whenDateTimeElement => throw _privateConstructorUsedError;

  /// [whenPeriod] A date or period in the past or future indicating when the
  ///  event occurred or is expectd to occur.
  Period? get whenPeriod => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitEventCopyWith<ExplanationOfBenefitEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitEventCopyWith<$Res> {
  factory $ExplanationOfBenefitEventCopyWith(ExplanationOfBenefitEvent value,
          $Res Function(ExplanationOfBenefitEvent) then) =
      _$ExplanationOfBenefitEventCopyWithImpl<$Res, ExplanationOfBenefitEvent>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      FhirDateTime? whenDateTime,
      @JsonKey(name: '_whenDateTime') Element? whenDateTimeElement,
      Period? whenPeriod});

  $CodeableConceptCopyWith<$Res> get type;
  $ElementCopyWith<$Res>? get whenDateTimeElement;
  $PeriodCopyWith<$Res>? get whenPeriod;
}

/// @nodoc
class _$ExplanationOfBenefitEventCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitEvent>
    implements $ExplanationOfBenefitEventCopyWith<$Res> {
  _$ExplanationOfBenefitEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? whenDateTime = freezed,
    Object? whenDateTimeElement = freezed,
    Object? whenPeriod = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      whenDateTime: freezed == whenDateTime
          ? _value.whenDateTime
          : whenDateTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      whenDateTimeElement: freezed == whenDateTimeElement
          ? _value.whenDateTimeElement
          : whenDateTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      whenPeriod: freezed == whenPeriod
          ? _value.whenPeriod
          : whenPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get whenDateTimeElement {
    if (_value.whenDateTimeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.whenDateTimeElement!, (value) {
      return _then(_value.copyWith(whenDateTimeElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get whenPeriod {
    if (_value.whenPeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.whenPeriod!, (value) {
      return _then(_value.copyWith(whenPeriod: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitEventImplCopyWith<$Res>
    implements $ExplanationOfBenefitEventCopyWith<$Res> {
  factory _$$ExplanationOfBenefitEventImplCopyWith(
          _$ExplanationOfBenefitEventImpl value,
          $Res Function(_$ExplanationOfBenefitEventImpl) then) =
      __$$ExplanationOfBenefitEventImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      FhirDateTime? whenDateTime,
      @JsonKey(name: '_whenDateTime') Element? whenDateTimeElement,
      Period? whenPeriod});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $ElementCopyWith<$Res>? get whenDateTimeElement;
  @override
  $PeriodCopyWith<$Res>? get whenPeriod;
}

/// @nodoc
class __$$ExplanationOfBenefitEventImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitEventCopyWithImpl<$Res,
        _$ExplanationOfBenefitEventImpl>
    implements _$$ExplanationOfBenefitEventImplCopyWith<$Res> {
  __$$ExplanationOfBenefitEventImplCopyWithImpl(
      _$ExplanationOfBenefitEventImpl _value,
      $Res Function(_$ExplanationOfBenefitEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? whenDateTime = freezed,
    Object? whenDateTimeElement = freezed,
    Object? whenPeriod = freezed,
  }) {
    return _then(_$ExplanationOfBenefitEventImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      whenDateTime: freezed == whenDateTime
          ? _value.whenDateTime
          : whenDateTime // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      whenDateTimeElement: freezed == whenDateTimeElement
          ? _value.whenDateTimeElement
          : whenDateTimeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      whenPeriod: freezed == whenPeriod
          ? _value.whenPeriod
          : whenPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitEventImpl extends _ExplanationOfBenefitEvent {
  const _$ExplanationOfBenefitEventImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.whenDateTime,
      @JsonKey(name: '_whenDateTime') this.whenDateTimeElement,
      this.whenPeriod})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ExplanationOfBenefitEventImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitEventImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] A coded event such as when a service is expected or a card
  ///  printed.
  @override
  final CodeableConcept type;

  /// [whenDateTime] A date or period in the past or future indicating when
  ///  the event occurred or is expectd to occur.
  @override
  final FhirDateTime? whenDateTime;

  /// [whenDateTimeElement] ("_whenDateTime") Extensions for whenDateTime
  @override
  @JsonKey(name: '_whenDateTime')
  final Element? whenDateTimeElement;

  /// [whenPeriod] A date or period in the past or future indicating when the
  ///  event occurred or is expectd to occur.
  @override
  final Period? whenPeriod;

  @override
  String toString() {
    return 'ExplanationOfBenefitEvent(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, whenDateTime: $whenDateTime, whenDateTimeElement: $whenDateTimeElement, whenPeriod: $whenPeriod)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitEventImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.whenDateTime, whenDateTime) ||
                other.whenDateTime == whenDateTime) &&
            (identical(other.whenDateTimeElement, whenDateTimeElement) ||
                other.whenDateTimeElement == whenDateTimeElement) &&
            (identical(other.whenPeriod, whenPeriod) ||
                other.whenPeriod == whenPeriod));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      whenDateTime,
      whenDateTimeElement,
      whenPeriod);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitEventImplCopyWith<_$ExplanationOfBenefitEventImpl>
      get copyWith => __$$ExplanationOfBenefitEventImplCopyWithImpl<
          _$ExplanationOfBenefitEventImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitEventImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitEvent extends ExplanationOfBenefitEvent {
  const factory _ExplanationOfBenefitEvent(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableConcept type,
      final FhirDateTime? whenDateTime,
      @JsonKey(name: '_whenDateTime') final Element? whenDateTimeElement,
      final Period? whenPeriod}) = _$ExplanationOfBenefitEventImpl;
  const _ExplanationOfBenefitEvent._() : super._();

  factory _ExplanationOfBenefitEvent.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitEventImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] A coded event such as when a service is expected or a card
  ///  printed.
  CodeableConcept get type;
  @override

  /// [whenDateTime] A date or period in the past or future indicating when
  ///  the event occurred or is expectd to occur.
  FhirDateTime? get whenDateTime;
  @override

  /// [whenDateTimeElement] ("_whenDateTime") Extensions for whenDateTime
  @JsonKey(name: '_whenDateTime')
  Element? get whenDateTimeElement;
  @override

  /// [whenPeriod] A date or period in the past or future indicating when the
  ///  event occurred or is expectd to occur.
  Period? get whenPeriod;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitEventImplCopyWith<_$ExplanationOfBenefitEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitPayee _$ExplanationOfBenefitPayeeFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitPayee.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitPayee {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Type of Party to be reimbursed: Subscriber, provider, other.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [party] Reference to the individual or organization to whom any payment
  ///  will be made.
  Reference? get party => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitPayeeCopyWith<ExplanationOfBenefitPayee> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitPayeeCopyWith<$Res> {
  factory $ExplanationOfBenefitPayeeCopyWith(ExplanationOfBenefitPayee value,
          $Res Function(ExplanationOfBenefitPayee) then) =
      _$ExplanationOfBenefitPayeeCopyWithImpl<$Res, ExplanationOfBenefitPayee>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      Reference? party});

  $CodeableConceptCopyWith<$Res>? get type;
  $ReferenceCopyWith<$Res>? get party;
}

/// @nodoc
class _$ExplanationOfBenefitPayeeCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitPayee>
    implements $ExplanationOfBenefitPayeeCopyWith<$Res> {
  _$ExplanationOfBenefitPayeeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? party = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      party: freezed == party
          ? _value.party
          : party // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get party {
    if (_value.party == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.party!, (value) {
      return _then(_value.copyWith(party: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitPayeeImplCopyWith<$Res>
    implements $ExplanationOfBenefitPayeeCopyWith<$Res> {
  factory _$$ExplanationOfBenefitPayeeImplCopyWith(
          _$ExplanationOfBenefitPayeeImpl value,
          $Res Function(_$ExplanationOfBenefitPayeeImpl) then) =
      __$$ExplanationOfBenefitPayeeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      Reference? party});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ReferenceCopyWith<$Res>? get party;
}

/// @nodoc
class __$$ExplanationOfBenefitPayeeImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitPayeeCopyWithImpl<$Res,
        _$ExplanationOfBenefitPayeeImpl>
    implements _$$ExplanationOfBenefitPayeeImplCopyWith<$Res> {
  __$$ExplanationOfBenefitPayeeImplCopyWithImpl(
      _$ExplanationOfBenefitPayeeImpl _value,
      $Res Function(_$ExplanationOfBenefitPayeeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? party = freezed,
  }) {
    return _then(_$ExplanationOfBenefitPayeeImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      party: freezed == party
          ? _value.party
          : party // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitPayeeImpl extends _ExplanationOfBenefitPayee {
  const _$ExplanationOfBenefitPayeeImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      this.party})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ExplanationOfBenefitPayeeImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitPayeeImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Type of Party to be reimbursed: Subscriber, provider, other.
  @override
  final CodeableConcept? type;

  /// [party] Reference to the individual or organization to whom any payment
  ///  will be made.
  @override
  final Reference? party;

  @override
  String toString() {
    return 'ExplanationOfBenefitPayee(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, party: $party)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitPayeeImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.party, party) || other.party == party));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      party);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitPayeeImplCopyWith<_$ExplanationOfBenefitPayeeImpl>
      get copyWith => __$$ExplanationOfBenefitPayeeImplCopyWithImpl<
          _$ExplanationOfBenefitPayeeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitPayeeImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitPayee extends ExplanationOfBenefitPayee {
  const factory _ExplanationOfBenefitPayee(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? type,
      final Reference? party}) = _$ExplanationOfBenefitPayeeImpl;
  const _ExplanationOfBenefitPayee._() : super._();

  factory _ExplanationOfBenefitPayee.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitPayeeImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Type of Party to be reimbursed: Subscriber, provider, other.
  CodeableConcept? get type;
  @override

  /// [party] Reference to the individual or organization to whom any payment
  ///  will be made.
  Reference? get party;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitPayeeImplCopyWith<_$ExplanationOfBenefitPayeeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitCareTeam _$ExplanationOfBenefitCareTeamFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitCareTeam.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitCareTeam {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [sequence] A number to uniquely identify care team entries.
  FhirPositiveInt? get sequence => throw _privateConstructorUsedError;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement => throw _privateConstructorUsedError;

  /// [provider] Member of the team who provided the product or service.
  Reference get provider => throw _privateConstructorUsedError;

  /// [responsible] The party who is billing and/or responsible for the
  ///  claimed products or services.
  FhirBoolean? get responsible => throw _privateConstructorUsedError;

  /// [responsibleElement] ("_responsible") Extensions for responsible
  @JsonKey(name: '_responsible')
  Element? get responsibleElement => throw _privateConstructorUsedError;

  /// [role] The lead, assisting or supervising practitioner and their
  ///  discipline if a multidisciplinary team.
  CodeableConcept? get role => throw _privateConstructorUsedError;

  /// [specialty] The specialization of the practitioner or provider which is
  ///  applicable for this service.
  CodeableConcept? get specialty => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitCareTeamCopyWith<ExplanationOfBenefitCareTeam>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitCareTeamCopyWith<$Res> {
  factory $ExplanationOfBenefitCareTeamCopyWith(
          ExplanationOfBenefitCareTeam value,
          $Res Function(ExplanationOfBenefitCareTeam) then) =
      _$ExplanationOfBenefitCareTeamCopyWithImpl<$Res,
          ExplanationOfBenefitCareTeam>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      Reference provider,
      FhirBoolean? responsible,
      @JsonKey(name: '_responsible') Element? responsibleElement,
      CodeableConcept? role,
      CodeableConcept? specialty});

  $ElementCopyWith<$Res>? get sequenceElement;
  $ReferenceCopyWith<$Res> get provider;
  $ElementCopyWith<$Res>? get responsibleElement;
  $CodeableConceptCopyWith<$Res>? get role;
  $CodeableConceptCopyWith<$Res>? get specialty;
}

/// @nodoc
class _$ExplanationOfBenefitCareTeamCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitCareTeam>
    implements $ExplanationOfBenefitCareTeamCopyWith<$Res> {
  _$ExplanationOfBenefitCareTeamCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? provider = null,
    Object? responsible = freezed,
    Object? responsibleElement = freezed,
    Object? role = freezed,
    Object? specialty = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      provider: null == provider
          ? _value.provider
          : provider // ignore: cast_nullable_to_non_nullable
              as Reference,
      responsible: freezed == responsible
          ? _value.responsible
          : responsible // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      responsibleElement: freezed == responsibleElement
          ? _value.responsibleElement
          : responsibleElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      specialty: freezed == specialty
          ? _value.specialty
          : specialty // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get sequenceElement {
    if (_value.sequenceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.sequenceElement!, (value) {
      return _then(_value.copyWith(sequenceElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get provider {
    return $ReferenceCopyWith<$Res>(_value.provider, (value) {
      return _then(_value.copyWith(provider: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get responsibleElement {
    if (_value.responsibleElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.responsibleElement!, (value) {
      return _then(_value.copyWith(responsibleElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get role {
    if (_value.role == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.role!, (value) {
      return _then(_value.copyWith(role: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get specialty {
    if (_value.specialty == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.specialty!, (value) {
      return _then(_value.copyWith(specialty: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitCareTeamImplCopyWith<$Res>
    implements $ExplanationOfBenefitCareTeamCopyWith<$Res> {
  factory _$$ExplanationOfBenefitCareTeamImplCopyWith(
          _$ExplanationOfBenefitCareTeamImpl value,
          $Res Function(_$ExplanationOfBenefitCareTeamImpl) then) =
      __$$ExplanationOfBenefitCareTeamImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      Reference provider,
      FhirBoolean? responsible,
      @JsonKey(name: '_responsible') Element? responsibleElement,
      CodeableConcept? role,
      CodeableConcept? specialty});

  @override
  $ElementCopyWith<$Res>? get sequenceElement;
  @override
  $ReferenceCopyWith<$Res> get provider;
  @override
  $ElementCopyWith<$Res>? get responsibleElement;
  @override
  $CodeableConceptCopyWith<$Res>? get role;
  @override
  $CodeableConceptCopyWith<$Res>? get specialty;
}

/// @nodoc
class __$$ExplanationOfBenefitCareTeamImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitCareTeamCopyWithImpl<$Res,
        _$ExplanationOfBenefitCareTeamImpl>
    implements _$$ExplanationOfBenefitCareTeamImplCopyWith<$Res> {
  __$$ExplanationOfBenefitCareTeamImplCopyWithImpl(
      _$ExplanationOfBenefitCareTeamImpl _value,
      $Res Function(_$ExplanationOfBenefitCareTeamImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? provider = null,
    Object? responsible = freezed,
    Object? responsibleElement = freezed,
    Object? role = freezed,
    Object? specialty = freezed,
  }) {
    return _then(_$ExplanationOfBenefitCareTeamImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      provider: null == provider
          ? _value.provider
          : provider // ignore: cast_nullable_to_non_nullable
              as Reference,
      responsible: freezed == responsible
          ? _value.responsible
          : responsible // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      responsibleElement: freezed == responsibleElement
          ? _value.responsibleElement
          : responsibleElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      role: freezed == role
          ? _value.role
          : role // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      specialty: freezed == specialty
          ? _value.specialty
          : specialty // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitCareTeamImpl extends _ExplanationOfBenefitCareTeam {
  const _$ExplanationOfBenefitCareTeamImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.sequence,
      @JsonKey(name: '_sequence') this.sequenceElement,
      required this.provider,
      this.responsible,
      @JsonKey(name: '_responsible') this.responsibleElement,
      this.role,
      this.specialty})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ExplanationOfBenefitCareTeamImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitCareTeamImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sequence] A number to uniquely identify care team entries.
  @override
  final FhirPositiveInt? sequence;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @override
  @JsonKey(name: '_sequence')
  final Element? sequenceElement;

  /// [provider] Member of the team who provided the product or service.
  @override
  final Reference provider;

  /// [responsible] The party who is billing and/or responsible for the
  ///  claimed products or services.
  @override
  final FhirBoolean? responsible;

  /// [responsibleElement] ("_responsible") Extensions for responsible
  @override
  @JsonKey(name: '_responsible')
  final Element? responsibleElement;

  /// [role] The lead, assisting or supervising practitioner and their
  ///  discipline if a multidisciplinary team.
  @override
  final CodeableConcept? role;

  /// [specialty] The specialization of the practitioner or provider which is
  ///  applicable for this service.
  @override
  final CodeableConcept? specialty;

  @override
  String toString() {
    return 'ExplanationOfBenefitCareTeam(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, sequence: $sequence, sequenceElement: $sequenceElement, provider: $provider, responsible: $responsible, responsibleElement: $responsibleElement, role: $role, specialty: $specialty)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitCareTeamImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.sequence, sequence) ||
                other.sequence == sequence) &&
            (identical(other.sequenceElement, sequenceElement) ||
                other.sequenceElement == sequenceElement) &&
            (identical(other.provider, provider) ||
                other.provider == provider) &&
            (identical(other.responsible, responsible) ||
                other.responsible == responsible) &&
            (identical(other.responsibleElement, responsibleElement) ||
                other.responsibleElement == responsibleElement) &&
            (identical(other.role, role) || other.role == role) &&
            (identical(other.specialty, specialty) ||
                other.specialty == specialty));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      sequence,
      sequenceElement,
      provider,
      responsible,
      responsibleElement,
      role,
      specialty);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitCareTeamImplCopyWith<
          _$ExplanationOfBenefitCareTeamImpl>
      get copyWith => __$$ExplanationOfBenefitCareTeamImplCopyWithImpl<
          _$ExplanationOfBenefitCareTeamImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitCareTeamImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitCareTeam
    extends ExplanationOfBenefitCareTeam {
  const factory _ExplanationOfBenefitCareTeam(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') final Element? sequenceElement,
      required final Reference provider,
      final FhirBoolean? responsible,
      @JsonKey(name: '_responsible') final Element? responsibleElement,
      final CodeableConcept? role,
      final CodeableConcept? specialty}) = _$ExplanationOfBenefitCareTeamImpl;
  const _ExplanationOfBenefitCareTeam._() : super._();

  factory _ExplanationOfBenefitCareTeam.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitCareTeamImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [sequence] A number to uniquely identify care team entries.
  FhirPositiveInt? get sequence;
  @override

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement;
  @override

  /// [provider] Member of the team who provided the product or service.
  Reference get provider;
  @override

  /// [responsible] The party who is billing and/or responsible for the
  ///  claimed products or services.
  FhirBoolean? get responsible;
  @override

  /// [responsibleElement] ("_responsible") Extensions for responsible
  @JsonKey(name: '_responsible')
  Element? get responsibleElement;
  @override

  /// [role] The lead, assisting or supervising practitioner and their
  ///  discipline if a multidisciplinary team.
  CodeableConcept? get role;
  @override

  /// [specialty] The specialization of the practitioner or provider which is
  ///  applicable for this service.
  CodeableConcept? get specialty;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitCareTeamImplCopyWith<
          _$ExplanationOfBenefitCareTeamImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitSupportingInfo _$ExplanationOfBenefitSupportingInfoFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitSupportingInfo.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitSupportingInfo {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [sequence] A number to uniquely identify supporting information entries.
  FhirPositiveInt? get sequence => throw _privateConstructorUsedError;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement => throw _privateConstructorUsedError;

  /// [category] The general class of the information supplied: information;
  ///  exception; accident, employment; onset, etc.
  CodeableConcept get category => throw _privateConstructorUsedError;

  /// [code] System and code pertaining to the specific information regarding
  ///  special conditions relating to the setting, treatment or patient  for
  ///  which care is sought.
  CodeableConcept? get code => throw _privateConstructorUsedError;

  /// [timingDate] The date when or period to which this information refers.
  FhirDate? get timingDate => throw _privateConstructorUsedError;

  /// [timingDateElement] ("_timingDate") Extensions for timingDate
  @JsonKey(name: '_timingDate')
  Element? get timingDateElement => throw _privateConstructorUsedError;

  /// [timingPeriod] The date when or period to which this information refers.
  Period? get timingPeriod => throw _privateConstructorUsedError;

  /// [valueBoolean] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  FhirBoolean? get valueBoolean => throw _privateConstructorUsedError;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement => throw _privateConstructorUsedError;

  /// [valueString] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  String? get valueString => throw _privateConstructorUsedError;

  /// [valueStringElement] ("_valueString") Extensions for valueString
  @JsonKey(name: '_valueString')
  Element? get valueStringElement => throw _privateConstructorUsedError;

  /// [valueQuantity] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  Quantity? get valueQuantity => throw _privateConstructorUsedError;

  /// [valueAttachment] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  Attachment? get valueAttachment => throw _privateConstructorUsedError;

  /// [valueReference] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  Reference? get valueReference => throw _privateConstructorUsedError;

  /// [valueIdentifier] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  Identifier? get valueIdentifier => throw _privateConstructorUsedError;

  /// [reason] Provides the reason in the situation where a reason code is
  ///  required in addition to the content.
  Coding? get reason => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitSupportingInfoCopyWith<
          ExplanationOfBenefitSupportingInfo>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitSupportingInfoCopyWith<$Res> {
  factory $ExplanationOfBenefitSupportingInfoCopyWith(
          ExplanationOfBenefitSupportingInfo value,
          $Res Function(ExplanationOfBenefitSupportingInfo) then) =
      _$ExplanationOfBenefitSupportingInfoCopyWithImpl<$Res,
          ExplanationOfBenefitSupportingInfo>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      CodeableConcept category,
      CodeableConcept? code,
      FhirDate? timingDate,
      @JsonKey(name: '_timingDate') Element? timingDateElement,
      Period? timingPeriod,
      FhirBoolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      String? valueString,
      @JsonKey(name: '_valueString') Element? valueStringElement,
      Quantity? valueQuantity,
      Attachment? valueAttachment,
      Reference? valueReference,
      Identifier? valueIdentifier,
      Coding? reason});

  $ElementCopyWith<$Res>? get sequenceElement;
  $CodeableConceptCopyWith<$Res> get category;
  $CodeableConceptCopyWith<$Res>? get code;
  $ElementCopyWith<$Res>? get timingDateElement;
  $PeriodCopyWith<$Res>? get timingPeriod;
  $ElementCopyWith<$Res>? get valueBooleanElement;
  $ElementCopyWith<$Res>? get valueStringElement;
  $QuantityCopyWith<$Res>? get valueQuantity;
  $AttachmentCopyWith<$Res>? get valueAttachment;
  $ReferenceCopyWith<$Res>? get valueReference;
  $IdentifierCopyWith<$Res>? get valueIdentifier;
  $CodingCopyWith<$Res>? get reason;
}

/// @nodoc
class _$ExplanationOfBenefitSupportingInfoCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitSupportingInfo>
    implements $ExplanationOfBenefitSupportingInfoCopyWith<$Res> {
  _$ExplanationOfBenefitSupportingInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? category = null,
    Object? code = freezed,
    Object? timingDate = freezed,
    Object? timingDateElement = freezed,
    Object? timingPeriod = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueString = freezed,
    Object? valueStringElement = freezed,
    Object? valueQuantity = freezed,
    Object? valueAttachment = freezed,
    Object? valueReference = freezed,
    Object? valueIdentifier = freezed,
    Object? reason = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      timingDate: freezed == timingDate
          ? _value.timingDate
          : timingDate // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      timingDateElement: freezed == timingDateElement
          ? _value.timingDateElement
          : timingDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      timingPeriod: freezed == timingPeriod
          ? _value.timingPeriod
          : timingPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueString: freezed == valueString
          ? _value.valueString
          : valueString // ignore: cast_nullable_to_non_nullable
              as String?,
      valueStringElement: freezed == valueStringElement
          ? _value.valueStringElement
          : valueStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      valueReference: freezed == valueReference
          ? _value.valueReference
          : valueReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      valueIdentifier: freezed == valueIdentifier
          ? _value.valueIdentifier
          : valueIdentifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as Coding?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get sequenceElement {
    if (_value.sequenceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.sequenceElement!, (value) {
      return _then(_value.copyWith(sequenceElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get category {
    return $CodeableConceptCopyWith<$Res>(_value.category, (value) {
      return _then(_value.copyWith(category: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get code {
    if (_value.code == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.code!, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get timingDateElement {
    if (_value.timingDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.timingDateElement!, (value) {
      return _then(_value.copyWith(timingDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get timingPeriod {
    if (_value.timingPeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.timingPeriod!, (value) {
      return _then(_value.copyWith(timingPeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueBooleanElement {
    if (_value.valueBooleanElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueBooleanElement!, (value) {
      return _then(_value.copyWith(valueBooleanElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get valueStringElement {
    if (_value.valueStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.valueStringElement!, (value) {
      return _then(_value.copyWith(valueStringElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get valueQuantity {
    if (_value.valueQuantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.valueQuantity!, (value) {
      return _then(_value.copyWith(valueQuantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AttachmentCopyWith<$Res>? get valueAttachment {
    if (_value.valueAttachment == null) {
      return null;
    }

    return $AttachmentCopyWith<$Res>(_value.valueAttachment!, (value) {
      return _then(_value.copyWith(valueAttachment: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get valueReference {
    if (_value.valueReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.valueReference!, (value) {
      return _then(_value.copyWith(valueReference: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get valueIdentifier {
    if (_value.valueIdentifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.valueIdentifier!, (value) {
      return _then(_value.copyWith(valueIdentifier: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodingCopyWith<$Res>? get reason {
    if (_value.reason == null) {
      return null;
    }

    return $CodingCopyWith<$Res>(_value.reason!, (value) {
      return _then(_value.copyWith(reason: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitSupportingInfoImplCopyWith<$Res>
    implements $ExplanationOfBenefitSupportingInfoCopyWith<$Res> {
  factory _$$ExplanationOfBenefitSupportingInfoImplCopyWith(
          _$ExplanationOfBenefitSupportingInfoImpl value,
          $Res Function(_$ExplanationOfBenefitSupportingInfoImpl) then) =
      __$$ExplanationOfBenefitSupportingInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      CodeableConcept category,
      CodeableConcept? code,
      FhirDate? timingDate,
      @JsonKey(name: '_timingDate') Element? timingDateElement,
      Period? timingPeriod,
      FhirBoolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') Element? valueBooleanElement,
      String? valueString,
      @JsonKey(name: '_valueString') Element? valueStringElement,
      Quantity? valueQuantity,
      Attachment? valueAttachment,
      Reference? valueReference,
      Identifier? valueIdentifier,
      Coding? reason});

  @override
  $ElementCopyWith<$Res>? get sequenceElement;
  @override
  $CodeableConceptCopyWith<$Res> get category;
  @override
  $CodeableConceptCopyWith<$Res>? get code;
  @override
  $ElementCopyWith<$Res>? get timingDateElement;
  @override
  $PeriodCopyWith<$Res>? get timingPeriod;
  @override
  $ElementCopyWith<$Res>? get valueBooleanElement;
  @override
  $ElementCopyWith<$Res>? get valueStringElement;
  @override
  $QuantityCopyWith<$Res>? get valueQuantity;
  @override
  $AttachmentCopyWith<$Res>? get valueAttachment;
  @override
  $ReferenceCopyWith<$Res>? get valueReference;
  @override
  $IdentifierCopyWith<$Res>? get valueIdentifier;
  @override
  $CodingCopyWith<$Res>? get reason;
}

/// @nodoc
class __$$ExplanationOfBenefitSupportingInfoImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitSupportingInfoCopyWithImpl<$Res,
        _$ExplanationOfBenefitSupportingInfoImpl>
    implements _$$ExplanationOfBenefitSupportingInfoImplCopyWith<$Res> {
  __$$ExplanationOfBenefitSupportingInfoImplCopyWithImpl(
      _$ExplanationOfBenefitSupportingInfoImpl _value,
      $Res Function(_$ExplanationOfBenefitSupportingInfoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? category = null,
    Object? code = freezed,
    Object? timingDate = freezed,
    Object? timingDateElement = freezed,
    Object? timingPeriod = freezed,
    Object? valueBoolean = freezed,
    Object? valueBooleanElement = freezed,
    Object? valueString = freezed,
    Object? valueStringElement = freezed,
    Object? valueQuantity = freezed,
    Object? valueAttachment = freezed,
    Object? valueReference = freezed,
    Object? valueIdentifier = freezed,
    Object? reason = freezed,
  }) {
    return _then(_$ExplanationOfBenefitSupportingInfoImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      timingDate: freezed == timingDate
          ? _value.timingDate
          : timingDate // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      timingDateElement: freezed == timingDateElement
          ? _value.timingDateElement
          : timingDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      timingPeriod: freezed == timingPeriod
          ? _value.timingPeriod
          : timingPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      valueBoolean: freezed == valueBoolean
          ? _value.valueBoolean
          : valueBoolean // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      valueBooleanElement: freezed == valueBooleanElement
          ? _value.valueBooleanElement
          : valueBooleanElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueString: freezed == valueString
          ? _value.valueString
          : valueString // ignore: cast_nullable_to_non_nullable
              as String?,
      valueStringElement: freezed == valueStringElement
          ? _value.valueStringElement
          : valueStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      valueQuantity: freezed == valueQuantity
          ? _value.valueQuantity
          : valueQuantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      valueAttachment: freezed == valueAttachment
          ? _value.valueAttachment
          : valueAttachment // ignore: cast_nullable_to_non_nullable
              as Attachment?,
      valueReference: freezed == valueReference
          ? _value.valueReference
          : valueReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      valueIdentifier: freezed == valueIdentifier
          ? _value.valueIdentifier
          : valueIdentifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as Coding?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitSupportingInfoImpl
    extends _ExplanationOfBenefitSupportingInfo {
  const _$ExplanationOfBenefitSupportingInfoImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.sequence,
      @JsonKey(name: '_sequence') this.sequenceElement,
      required this.category,
      this.code,
      this.timingDate,
      @JsonKey(name: '_timingDate') this.timingDateElement,
      this.timingPeriod,
      this.valueBoolean,
      @JsonKey(name: '_valueBoolean') this.valueBooleanElement,
      this.valueString,
      @JsonKey(name: '_valueString') this.valueStringElement,
      this.valueQuantity,
      this.valueAttachment,
      this.valueReference,
      this.valueIdentifier,
      this.reason})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ExplanationOfBenefitSupportingInfoImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitSupportingInfoImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sequence] A number to uniquely identify supporting information entries.
  @override
  final FhirPositiveInt? sequence;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @override
  @JsonKey(name: '_sequence')
  final Element? sequenceElement;

  /// [category] The general class of the information supplied: information;
  ///  exception; accident, employment; onset, etc.
  @override
  final CodeableConcept category;

  /// [code] System and code pertaining to the specific information regarding
  ///  special conditions relating to the setting, treatment or patient  for
  ///  which care is sought.
  @override
  final CodeableConcept? code;

  /// [timingDate] The date when or period to which this information refers.
  @override
  final FhirDate? timingDate;

  /// [timingDateElement] ("_timingDate") Extensions for timingDate
  @override
  @JsonKey(name: '_timingDate')
  final Element? timingDateElement;

  /// [timingPeriod] The date when or period to which this information refers.
  @override
  final Period? timingPeriod;

  /// [valueBoolean] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  @override
  final FhirBoolean? valueBoolean;

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @override
  @JsonKey(name: '_valueBoolean')
  final Element? valueBooleanElement;

  /// [valueString] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  @override
  final String? valueString;

  /// [valueStringElement] ("_valueString") Extensions for valueString
  @override
  @JsonKey(name: '_valueString')
  final Element? valueStringElement;

  /// [valueQuantity] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  @override
  final Quantity? valueQuantity;

  /// [valueAttachment] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  @override
  final Attachment? valueAttachment;

  /// [valueReference] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  @override
  final Reference? valueReference;

  /// [valueIdentifier] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  @override
  final Identifier? valueIdentifier;

  /// [reason] Provides the reason in the situation where a reason code is
  ///  required in addition to the content.
  @override
  final Coding? reason;

  @override
  String toString() {
    return 'ExplanationOfBenefitSupportingInfo(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, sequence: $sequence, sequenceElement: $sequenceElement, category: $category, code: $code, timingDate: $timingDate, timingDateElement: $timingDateElement, timingPeriod: $timingPeriod, valueBoolean: $valueBoolean, valueBooleanElement: $valueBooleanElement, valueString: $valueString, valueStringElement: $valueStringElement, valueQuantity: $valueQuantity, valueAttachment: $valueAttachment, valueReference: $valueReference, valueIdentifier: $valueIdentifier, reason: $reason)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitSupportingInfoImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.sequence, sequence) ||
                other.sequence == sequence) &&
            (identical(other.sequenceElement, sequenceElement) ||
                other.sequenceElement == sequenceElement) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.timingDate, timingDate) ||
                other.timingDate == timingDate) &&
            (identical(other.timingDateElement, timingDateElement) ||
                other.timingDateElement == timingDateElement) &&
            (identical(other.timingPeriod, timingPeriod) ||
                other.timingPeriod == timingPeriod) &&
            (identical(other.valueBoolean, valueBoolean) ||
                other.valueBoolean == valueBoolean) &&
            (identical(other.valueBooleanElement, valueBooleanElement) ||
                other.valueBooleanElement == valueBooleanElement) &&
            (identical(other.valueString, valueString) ||
                other.valueString == valueString) &&
            (identical(other.valueStringElement, valueStringElement) ||
                other.valueStringElement == valueStringElement) &&
            (identical(other.valueQuantity, valueQuantity) ||
                other.valueQuantity == valueQuantity) &&
            (identical(other.valueAttachment, valueAttachment) ||
                other.valueAttachment == valueAttachment) &&
            (identical(other.valueReference, valueReference) ||
                other.valueReference == valueReference) &&
            (identical(other.valueIdentifier, valueIdentifier) ||
                other.valueIdentifier == valueIdentifier) &&
            (identical(other.reason, reason) || other.reason == reason));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        sequence,
        sequenceElement,
        category,
        code,
        timingDate,
        timingDateElement,
        timingPeriod,
        valueBoolean,
        valueBooleanElement,
        valueString,
        valueStringElement,
        valueQuantity,
        valueAttachment,
        valueReference,
        valueIdentifier,
        reason
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitSupportingInfoImplCopyWith<
          _$ExplanationOfBenefitSupportingInfoImpl>
      get copyWith => __$$ExplanationOfBenefitSupportingInfoImplCopyWithImpl<
          _$ExplanationOfBenefitSupportingInfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitSupportingInfoImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitSupportingInfo
    extends ExplanationOfBenefitSupportingInfo {
  const factory _ExplanationOfBenefitSupportingInfo(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') final Element? sequenceElement,
      required final CodeableConcept category,
      final CodeableConcept? code,
      final FhirDate? timingDate,
      @JsonKey(name: '_timingDate') final Element? timingDateElement,
      final Period? timingPeriod,
      final FhirBoolean? valueBoolean,
      @JsonKey(name: '_valueBoolean') final Element? valueBooleanElement,
      final String? valueString,
      @JsonKey(name: '_valueString') final Element? valueStringElement,
      final Quantity? valueQuantity,
      final Attachment? valueAttachment,
      final Reference? valueReference,
      final Identifier? valueIdentifier,
      final Coding? reason}) = _$ExplanationOfBenefitSupportingInfoImpl;
  const _ExplanationOfBenefitSupportingInfo._() : super._();

  factory _ExplanationOfBenefitSupportingInfo.fromJson(
          Map<String, dynamic> json) =
      _$ExplanationOfBenefitSupportingInfoImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [sequence] A number to uniquely identify supporting information entries.
  FhirPositiveInt? get sequence;
  @override

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement;
  @override

  /// [category] The general class of the information supplied: information;
  ///  exception; accident, employment; onset, etc.
  CodeableConcept get category;
  @override

  /// [code] System and code pertaining to the specific information regarding
  ///  special conditions relating to the setting, treatment or patient  for
  ///  which care is sought.
  CodeableConcept? get code;
  @override

  /// [timingDate] The date when or period to which this information refers.
  FhirDate? get timingDate;
  @override

  /// [timingDateElement] ("_timingDate") Extensions for timingDate
  @JsonKey(name: '_timingDate')
  Element? get timingDateElement;
  @override

  /// [timingPeriod] The date when or period to which this information refers.
  Period? get timingPeriod;
  @override

  /// [valueBoolean] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  FhirBoolean? get valueBoolean;
  @override

  /// [valueBooleanElement] ("_valueBoolean") Extensions for valueBoolean
  @JsonKey(name: '_valueBoolean')
  Element? get valueBooleanElement;
  @override

  /// [valueString] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  String? get valueString;
  @override

  /// [valueStringElement] ("_valueString") Extensions for valueString
  @JsonKey(name: '_valueString')
  Element? get valueStringElement;
  @override

  /// [valueQuantity] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  Quantity? get valueQuantity;
  @override

  /// [valueAttachment] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  Attachment? get valueAttachment;
  @override

  /// [valueReference] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  Reference? get valueReference;
  @override

  /// [valueIdentifier] Additional data or information such as resources,
  ///  documents, images etc. including references to the data or the actual
  ///  inclusion of the data.
  Identifier? get valueIdentifier;
  @override

  /// [reason] Provides the reason in the situation where a reason code is
  ///  required in addition to the content.
  Coding? get reason;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitSupportingInfoImplCopyWith<
          _$ExplanationOfBenefitSupportingInfoImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitDiagnosis _$ExplanationOfBenefitDiagnosisFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitDiagnosis.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitDiagnosis {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [sequence] A number to uniquely identify diagnosis entries.
  FhirPositiveInt? get sequence => throw _privateConstructorUsedError;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement => throw _privateConstructorUsedError;

  /// [diagnosisCodeableConcept] The nature of illness or problem in a coded
  ///  form or as a reference to an external defined Condition.
  CodeableConcept? get diagnosisCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [diagnosisReference] The nature of illness or problem in a coded form
  ///  or as a reference to an external defined Condition.
  Reference? get diagnosisReference => throw _privateConstructorUsedError;

  /// [type] When the condition was observed or the relative ranking.
  List<CodeableConcept>? get type => throw _privateConstructorUsedError;

  /// [onAdmission] Indication of whether the diagnosis was present on
  ///  admission to a facility.
  CodeableConcept? get onAdmission => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitDiagnosisCopyWith<ExplanationOfBenefitDiagnosis>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitDiagnosisCopyWith<$Res> {
  factory $ExplanationOfBenefitDiagnosisCopyWith(
          ExplanationOfBenefitDiagnosis value,
          $Res Function(ExplanationOfBenefitDiagnosis) then) =
      _$ExplanationOfBenefitDiagnosisCopyWithImpl<$Res,
          ExplanationOfBenefitDiagnosis>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      CodeableConcept? diagnosisCodeableConcept,
      Reference? diagnosisReference,
      List<CodeableConcept>? type,
      CodeableConcept? onAdmission});

  $ElementCopyWith<$Res>? get sequenceElement;
  $CodeableConceptCopyWith<$Res>? get diagnosisCodeableConcept;
  $ReferenceCopyWith<$Res>? get diagnosisReference;
  $CodeableConceptCopyWith<$Res>? get onAdmission;
}

/// @nodoc
class _$ExplanationOfBenefitDiagnosisCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitDiagnosis>
    implements $ExplanationOfBenefitDiagnosisCopyWith<$Res> {
  _$ExplanationOfBenefitDiagnosisCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? diagnosisCodeableConcept = freezed,
    Object? diagnosisReference = freezed,
    Object? type = freezed,
    Object? onAdmission = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      diagnosisCodeableConcept: freezed == diagnosisCodeableConcept
          ? _value.diagnosisCodeableConcept
          : diagnosisCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      diagnosisReference: freezed == diagnosisReference
          ? _value.diagnosisReference
          : diagnosisReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      onAdmission: freezed == onAdmission
          ? _value.onAdmission
          : onAdmission // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get sequenceElement {
    if (_value.sequenceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.sequenceElement!, (value) {
      return _then(_value.copyWith(sequenceElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get diagnosisCodeableConcept {
    if (_value.diagnosisCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.diagnosisCodeableConcept!,
        (value) {
      return _then(_value.copyWith(diagnosisCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get diagnosisReference {
    if (_value.diagnosisReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.diagnosisReference!, (value) {
      return _then(_value.copyWith(diagnosisReference: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get onAdmission {
    if (_value.onAdmission == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.onAdmission!, (value) {
      return _then(_value.copyWith(onAdmission: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitDiagnosisImplCopyWith<$Res>
    implements $ExplanationOfBenefitDiagnosisCopyWith<$Res> {
  factory _$$ExplanationOfBenefitDiagnosisImplCopyWith(
          _$ExplanationOfBenefitDiagnosisImpl value,
          $Res Function(_$ExplanationOfBenefitDiagnosisImpl) then) =
      __$$ExplanationOfBenefitDiagnosisImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      CodeableConcept? diagnosisCodeableConcept,
      Reference? diagnosisReference,
      List<CodeableConcept>? type,
      CodeableConcept? onAdmission});

  @override
  $ElementCopyWith<$Res>? get sequenceElement;
  @override
  $CodeableConceptCopyWith<$Res>? get diagnosisCodeableConcept;
  @override
  $ReferenceCopyWith<$Res>? get diagnosisReference;
  @override
  $CodeableConceptCopyWith<$Res>? get onAdmission;
}

/// @nodoc
class __$$ExplanationOfBenefitDiagnosisImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitDiagnosisCopyWithImpl<$Res,
        _$ExplanationOfBenefitDiagnosisImpl>
    implements _$$ExplanationOfBenefitDiagnosisImplCopyWith<$Res> {
  __$$ExplanationOfBenefitDiagnosisImplCopyWithImpl(
      _$ExplanationOfBenefitDiagnosisImpl _value,
      $Res Function(_$ExplanationOfBenefitDiagnosisImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? diagnosisCodeableConcept = freezed,
    Object? diagnosisReference = freezed,
    Object? type = freezed,
    Object? onAdmission = freezed,
  }) {
    return _then(_$ExplanationOfBenefitDiagnosisImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      diagnosisCodeableConcept: freezed == diagnosisCodeableConcept
          ? _value.diagnosisCodeableConcept
          : diagnosisCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      diagnosisReference: freezed == diagnosisReference
          ? _value.diagnosisReference
          : diagnosisReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      type: freezed == type
          ? _value._type
          : type // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      onAdmission: freezed == onAdmission
          ? _value.onAdmission
          : onAdmission // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitDiagnosisImpl
    extends _ExplanationOfBenefitDiagnosis {
  const _$ExplanationOfBenefitDiagnosisImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.sequence,
      @JsonKey(name: '_sequence') this.sequenceElement,
      this.diagnosisCodeableConcept,
      this.diagnosisReference,
      final List<CodeableConcept>? type,
      this.onAdmission})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _type = type,
        super._();

  factory _$ExplanationOfBenefitDiagnosisImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitDiagnosisImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sequence] A number to uniquely identify diagnosis entries.
  @override
  final FhirPositiveInt? sequence;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @override
  @JsonKey(name: '_sequence')
  final Element? sequenceElement;

  /// [diagnosisCodeableConcept] The nature of illness or problem in a coded
  ///  form or as a reference to an external defined Condition.
  @override
  final CodeableConcept? diagnosisCodeableConcept;

  /// [diagnosisReference] The nature of illness or problem in a coded form
  ///  or as a reference to an external defined Condition.
  @override
  final Reference? diagnosisReference;

  /// [type] When the condition was observed or the relative ranking.
  final List<CodeableConcept>? _type;

  /// [type] When the condition was observed or the relative ranking.
  @override
  List<CodeableConcept>? get type {
    final value = _type;
    if (value == null) return null;
    if (_type is EqualUnmodifiableListView) return _type;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [onAdmission] Indication of whether the diagnosis was present on
  ///  admission to a facility.
  @override
  final CodeableConcept? onAdmission;

  @override
  String toString() {
    return 'ExplanationOfBenefitDiagnosis(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, sequence: $sequence, sequenceElement: $sequenceElement, diagnosisCodeableConcept: $diagnosisCodeableConcept, diagnosisReference: $diagnosisReference, type: $type, onAdmission: $onAdmission)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitDiagnosisImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.sequence, sequence) ||
                other.sequence == sequence) &&
            (identical(other.sequenceElement, sequenceElement) ||
                other.sequenceElement == sequenceElement) &&
            (identical(
                    other.diagnosisCodeableConcept, diagnosisCodeableConcept) ||
                other.diagnosisCodeableConcept == diagnosisCodeableConcept) &&
            (identical(other.diagnosisReference, diagnosisReference) ||
                other.diagnosisReference == diagnosisReference) &&
            const DeepCollectionEquality().equals(other._type, _type) &&
            (identical(other.onAdmission, onAdmission) ||
                other.onAdmission == onAdmission));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      sequence,
      sequenceElement,
      diagnosisCodeableConcept,
      diagnosisReference,
      const DeepCollectionEquality().hash(_type),
      onAdmission);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitDiagnosisImplCopyWith<
          _$ExplanationOfBenefitDiagnosisImpl>
      get copyWith => __$$ExplanationOfBenefitDiagnosisImplCopyWithImpl<
          _$ExplanationOfBenefitDiagnosisImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitDiagnosisImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitDiagnosis
    extends ExplanationOfBenefitDiagnosis {
  const factory _ExplanationOfBenefitDiagnosis(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final FhirPositiveInt? sequence,
          @JsonKey(name: '_sequence') final Element? sequenceElement,
          final CodeableConcept? diagnosisCodeableConcept,
          final Reference? diagnosisReference,
          final List<CodeableConcept>? type,
          final CodeableConcept? onAdmission}) =
      _$ExplanationOfBenefitDiagnosisImpl;
  const _ExplanationOfBenefitDiagnosis._() : super._();

  factory _ExplanationOfBenefitDiagnosis.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitDiagnosisImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [sequence] A number to uniquely identify diagnosis entries.
  FhirPositiveInt? get sequence;
  @override

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement;
  @override

  /// [diagnosisCodeableConcept] The nature of illness or problem in a coded
  ///  form or as a reference to an external defined Condition.
  CodeableConcept? get diagnosisCodeableConcept;
  @override

  /// [diagnosisReference] The nature of illness or problem in a coded form
  ///  or as a reference to an external defined Condition.
  Reference? get diagnosisReference;
  @override

  /// [type] When the condition was observed or the relative ranking.
  List<CodeableConcept>? get type;
  @override

  /// [onAdmission] Indication of whether the diagnosis was present on
  ///  admission to a facility.
  CodeableConcept? get onAdmission;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitDiagnosisImplCopyWith<
          _$ExplanationOfBenefitDiagnosisImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitProcedure _$ExplanationOfBenefitProcedureFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitProcedure.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitProcedure {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [sequence] A number to uniquely identify procedure entries.
  FhirPositiveInt? get sequence => throw _privateConstructorUsedError;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement => throw _privateConstructorUsedError;

  /// [type] When the condition was observed or the relative ranking.
  List<CodeableConcept>? get type => throw _privateConstructorUsedError;

  /// [date] Date and optionally time the procedure was performed.
  FhirDateTime? get date => throw _privateConstructorUsedError;

  /// [dateElement] ("_date") Extensions for date
  @JsonKey(name: '_date')
  Element? get dateElement => throw _privateConstructorUsedError;

  /// [procedureCodeableConcept] The code or reference to a Procedure
  ///  resource which identifies the clinical intervention performed.
  CodeableConcept? get procedureCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [procedureReference] The code or reference to a Procedure resource
  ///  which identifies the clinical intervention performed.
  Reference? get procedureReference => throw _privateConstructorUsedError;

  /// [udi] Unique Device Identifiers associated with this line item.
  List<Reference>? get udi => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitProcedureCopyWith<ExplanationOfBenefitProcedure>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitProcedureCopyWith<$Res> {
  factory $ExplanationOfBenefitProcedureCopyWith(
          ExplanationOfBenefitProcedure value,
          $Res Function(ExplanationOfBenefitProcedure) then) =
      _$ExplanationOfBenefitProcedureCopyWithImpl<$Res,
          ExplanationOfBenefitProcedure>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      List<CodeableConcept>? type,
      FhirDateTime? date,
      @JsonKey(name: '_date') Element? dateElement,
      CodeableConcept? procedureCodeableConcept,
      Reference? procedureReference,
      List<Reference>? udi});

  $ElementCopyWith<$Res>? get sequenceElement;
  $ElementCopyWith<$Res>? get dateElement;
  $CodeableConceptCopyWith<$Res>? get procedureCodeableConcept;
  $ReferenceCopyWith<$Res>? get procedureReference;
}

/// @nodoc
class _$ExplanationOfBenefitProcedureCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitProcedure>
    implements $ExplanationOfBenefitProcedureCopyWith<$Res> {
  _$ExplanationOfBenefitProcedureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? type = freezed,
    Object? date = freezed,
    Object? dateElement = freezed,
    Object? procedureCodeableConcept = freezed,
    Object? procedureReference = freezed,
    Object? udi = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateElement: freezed == dateElement
          ? _value.dateElement
          : dateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      procedureCodeableConcept: freezed == procedureCodeableConcept
          ? _value.procedureCodeableConcept
          : procedureCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      procedureReference: freezed == procedureReference
          ? _value.procedureReference
          : procedureReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      udi: freezed == udi
          ? _value.udi
          : udi // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get sequenceElement {
    if (_value.sequenceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.sequenceElement!, (value) {
      return _then(_value.copyWith(sequenceElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get dateElement {
    if (_value.dateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.dateElement!, (value) {
      return _then(_value.copyWith(dateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get procedureCodeableConcept {
    if (_value.procedureCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.procedureCodeableConcept!,
        (value) {
      return _then(_value.copyWith(procedureCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get procedureReference {
    if (_value.procedureReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.procedureReference!, (value) {
      return _then(_value.copyWith(procedureReference: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitProcedureImplCopyWith<$Res>
    implements $ExplanationOfBenefitProcedureCopyWith<$Res> {
  factory _$$ExplanationOfBenefitProcedureImplCopyWith(
          _$ExplanationOfBenefitProcedureImpl value,
          $Res Function(_$ExplanationOfBenefitProcedureImpl) then) =
      __$$ExplanationOfBenefitProcedureImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      List<CodeableConcept>? type,
      FhirDateTime? date,
      @JsonKey(name: '_date') Element? dateElement,
      CodeableConcept? procedureCodeableConcept,
      Reference? procedureReference,
      List<Reference>? udi});

  @override
  $ElementCopyWith<$Res>? get sequenceElement;
  @override
  $ElementCopyWith<$Res>? get dateElement;
  @override
  $CodeableConceptCopyWith<$Res>? get procedureCodeableConcept;
  @override
  $ReferenceCopyWith<$Res>? get procedureReference;
}

/// @nodoc
class __$$ExplanationOfBenefitProcedureImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitProcedureCopyWithImpl<$Res,
        _$ExplanationOfBenefitProcedureImpl>
    implements _$$ExplanationOfBenefitProcedureImplCopyWith<$Res> {
  __$$ExplanationOfBenefitProcedureImplCopyWithImpl(
      _$ExplanationOfBenefitProcedureImpl _value,
      $Res Function(_$ExplanationOfBenefitProcedureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? type = freezed,
    Object? date = freezed,
    Object? dateElement = freezed,
    Object? procedureCodeableConcept = freezed,
    Object? procedureReference = freezed,
    Object? udi = freezed,
  }) {
    return _then(_$ExplanationOfBenefitProcedureImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value._type
          : type // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as FhirDateTime?,
      dateElement: freezed == dateElement
          ? _value.dateElement
          : dateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      procedureCodeableConcept: freezed == procedureCodeableConcept
          ? _value.procedureCodeableConcept
          : procedureCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      procedureReference: freezed == procedureReference
          ? _value.procedureReference
          : procedureReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      udi: freezed == udi
          ? _value._udi
          : udi // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitProcedureImpl
    extends _ExplanationOfBenefitProcedure {
  const _$ExplanationOfBenefitProcedureImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.sequence,
      @JsonKey(name: '_sequence') this.sequenceElement,
      final List<CodeableConcept>? type,
      this.date,
      @JsonKey(name: '_date') this.dateElement,
      this.procedureCodeableConcept,
      this.procedureReference,
      final List<Reference>? udi})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _type = type,
        _udi = udi,
        super._();

  factory _$ExplanationOfBenefitProcedureImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitProcedureImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sequence] A number to uniquely identify procedure entries.
  @override
  final FhirPositiveInt? sequence;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @override
  @JsonKey(name: '_sequence')
  final Element? sequenceElement;

  /// [type] When the condition was observed or the relative ranking.
  final List<CodeableConcept>? _type;

  /// [type] When the condition was observed or the relative ranking.
  @override
  List<CodeableConcept>? get type {
    final value = _type;
    if (value == null) return null;
    if (_type is EqualUnmodifiableListView) return _type;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [date] Date and optionally time the procedure was performed.
  @override
  final FhirDateTime? date;

  /// [dateElement] ("_date") Extensions for date
  @override
  @JsonKey(name: '_date')
  final Element? dateElement;

  /// [procedureCodeableConcept] The code or reference to a Procedure
  ///  resource which identifies the clinical intervention performed.
  @override
  final CodeableConcept? procedureCodeableConcept;

  /// [procedureReference] The code or reference to a Procedure resource
  ///  which identifies the clinical intervention performed.
  @override
  final Reference? procedureReference;

  /// [udi] Unique Device Identifiers associated with this line item.
  final List<Reference>? _udi;

  /// [udi] Unique Device Identifiers associated with this line item.
  @override
  List<Reference>? get udi {
    final value = _udi;
    if (value == null) return null;
    if (_udi is EqualUnmodifiableListView) return _udi;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExplanationOfBenefitProcedure(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, sequence: $sequence, sequenceElement: $sequenceElement, type: $type, date: $date, dateElement: $dateElement, procedureCodeableConcept: $procedureCodeableConcept, procedureReference: $procedureReference, udi: $udi)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitProcedureImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.sequence, sequence) ||
                other.sequence == sequence) &&
            (identical(other.sequenceElement, sequenceElement) ||
                other.sequenceElement == sequenceElement) &&
            const DeepCollectionEquality().equals(other._type, _type) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.dateElement, dateElement) ||
                other.dateElement == dateElement) &&
            (identical(
                    other.procedureCodeableConcept, procedureCodeableConcept) ||
                other.procedureCodeableConcept == procedureCodeableConcept) &&
            (identical(other.procedureReference, procedureReference) ||
                other.procedureReference == procedureReference) &&
            const DeepCollectionEquality().equals(other._udi, _udi));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      sequence,
      sequenceElement,
      const DeepCollectionEquality().hash(_type),
      date,
      dateElement,
      procedureCodeableConcept,
      procedureReference,
      const DeepCollectionEquality().hash(_udi));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitProcedureImplCopyWith<
          _$ExplanationOfBenefitProcedureImpl>
      get copyWith => __$$ExplanationOfBenefitProcedureImplCopyWithImpl<
          _$ExplanationOfBenefitProcedureImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitProcedureImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitProcedure
    extends ExplanationOfBenefitProcedure {
  const factory _ExplanationOfBenefitProcedure(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') final Element? sequenceElement,
      final List<CodeableConcept>? type,
      final FhirDateTime? date,
      @JsonKey(name: '_date') final Element? dateElement,
      final CodeableConcept? procedureCodeableConcept,
      final Reference? procedureReference,
      final List<Reference>? udi}) = _$ExplanationOfBenefitProcedureImpl;
  const _ExplanationOfBenefitProcedure._() : super._();

  factory _ExplanationOfBenefitProcedure.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitProcedureImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [sequence] A number to uniquely identify procedure entries.
  FhirPositiveInt? get sequence;
  @override

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement;
  @override

  /// [type] When the condition was observed or the relative ranking.
  List<CodeableConcept>? get type;
  @override

  /// [date] Date and optionally time the procedure was performed.
  FhirDateTime? get date;
  @override

  /// [dateElement] ("_date") Extensions for date
  @JsonKey(name: '_date')
  Element? get dateElement;
  @override

  /// [procedureCodeableConcept] The code or reference to a Procedure
  ///  resource which identifies the clinical intervention performed.
  CodeableConcept? get procedureCodeableConcept;
  @override

  /// [procedureReference] The code or reference to a Procedure resource
  ///  which identifies the clinical intervention performed.
  Reference? get procedureReference;
  @override

  /// [udi] Unique Device Identifiers associated with this line item.
  List<Reference>? get udi;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitProcedureImplCopyWith<
          _$ExplanationOfBenefitProcedureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitInsurance _$ExplanationOfBenefitInsuranceFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitInsurance.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitInsurance {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [focal] A flag to indicate that this Coverage is to be used for
  ///  adjudication of this claim when set to true.
  FhirBoolean? get focal => throw _privateConstructorUsedError;

  /// [focalElement] ("_focal") Extensions for focal
  @JsonKey(name: '_focal')
  Element? get focalElement => throw _privateConstructorUsedError;

  /// [coverage] Reference to the insurance card level information contained
  ///  in the Coverage resource. The coverage issuing insurer will use these
  ///  details to locate the patient's actual coverage within the insurer's
  ///  information system.
  Reference get coverage => throw _privateConstructorUsedError;

  /// [preAuthRef] Reference numbers previously provided by the insurer to
  ///  the provider to be quoted on subsequent claims containing services or
  ///  products related to the prior authorization.
  List<String>? get preAuthRef => throw _privateConstructorUsedError;

  /// [preAuthRefElement] ("_preAuthRef") Extensions for preAuthRef
  @JsonKey(name: '_preAuthRef')
  List<Element>? get preAuthRefElement => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitInsuranceCopyWith<ExplanationOfBenefitInsurance>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitInsuranceCopyWith<$Res> {
  factory $ExplanationOfBenefitInsuranceCopyWith(
          ExplanationOfBenefitInsurance value,
          $Res Function(ExplanationOfBenefitInsurance) then) =
      _$ExplanationOfBenefitInsuranceCopyWithImpl<$Res,
          ExplanationOfBenefitInsurance>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirBoolean? focal,
      @JsonKey(name: '_focal') Element? focalElement,
      Reference coverage,
      List<String>? preAuthRef,
      @JsonKey(name: '_preAuthRef') List<Element>? preAuthRefElement});

  $ElementCopyWith<$Res>? get focalElement;
  $ReferenceCopyWith<$Res> get coverage;
}

/// @nodoc
class _$ExplanationOfBenefitInsuranceCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitInsurance>
    implements $ExplanationOfBenefitInsuranceCopyWith<$Res> {
  _$ExplanationOfBenefitInsuranceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? focal = freezed,
    Object? focalElement = freezed,
    Object? coverage = null,
    Object? preAuthRef = freezed,
    Object? preAuthRefElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      focal: freezed == focal
          ? _value.focal
          : focal // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      focalElement: freezed == focalElement
          ? _value.focalElement
          : focalElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      coverage: null == coverage
          ? _value.coverage
          : coverage // ignore: cast_nullable_to_non_nullable
              as Reference,
      preAuthRef: freezed == preAuthRef
          ? _value.preAuthRef
          : preAuthRef // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      preAuthRefElement: freezed == preAuthRefElement
          ? _value.preAuthRefElement
          : preAuthRefElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get focalElement {
    if (_value.focalElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.focalElement!, (value) {
      return _then(_value.copyWith(focalElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get coverage {
    return $ReferenceCopyWith<$Res>(_value.coverage, (value) {
      return _then(_value.copyWith(coverage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitInsuranceImplCopyWith<$Res>
    implements $ExplanationOfBenefitInsuranceCopyWith<$Res> {
  factory _$$ExplanationOfBenefitInsuranceImplCopyWith(
          _$ExplanationOfBenefitInsuranceImpl value,
          $Res Function(_$ExplanationOfBenefitInsuranceImpl) then) =
      __$$ExplanationOfBenefitInsuranceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirBoolean? focal,
      @JsonKey(name: '_focal') Element? focalElement,
      Reference coverage,
      List<String>? preAuthRef,
      @JsonKey(name: '_preAuthRef') List<Element>? preAuthRefElement});

  @override
  $ElementCopyWith<$Res>? get focalElement;
  @override
  $ReferenceCopyWith<$Res> get coverage;
}

/// @nodoc
class __$$ExplanationOfBenefitInsuranceImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitInsuranceCopyWithImpl<$Res,
        _$ExplanationOfBenefitInsuranceImpl>
    implements _$$ExplanationOfBenefitInsuranceImplCopyWith<$Res> {
  __$$ExplanationOfBenefitInsuranceImplCopyWithImpl(
      _$ExplanationOfBenefitInsuranceImpl _value,
      $Res Function(_$ExplanationOfBenefitInsuranceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? focal = freezed,
    Object? focalElement = freezed,
    Object? coverage = null,
    Object? preAuthRef = freezed,
    Object? preAuthRefElement = freezed,
  }) {
    return _then(_$ExplanationOfBenefitInsuranceImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      focal: freezed == focal
          ? _value.focal
          : focal // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      focalElement: freezed == focalElement
          ? _value.focalElement
          : focalElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      coverage: null == coverage
          ? _value.coverage
          : coverage // ignore: cast_nullable_to_non_nullable
              as Reference,
      preAuthRef: freezed == preAuthRef
          ? _value._preAuthRef
          : preAuthRef // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      preAuthRefElement: freezed == preAuthRefElement
          ? _value._preAuthRefElement
          : preAuthRefElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitInsuranceImpl
    extends _ExplanationOfBenefitInsurance {
  const _$ExplanationOfBenefitInsuranceImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.focal,
      @JsonKey(name: '_focal') this.focalElement,
      required this.coverage,
      final List<String>? preAuthRef,
      @JsonKey(name: '_preAuthRef') final List<Element>? preAuthRefElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _preAuthRef = preAuthRef,
        _preAuthRefElement = preAuthRefElement,
        super._();

  factory _$ExplanationOfBenefitInsuranceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitInsuranceImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [focal] A flag to indicate that this Coverage is to be used for
  ///  adjudication of this claim when set to true.
  @override
  final FhirBoolean? focal;

  /// [focalElement] ("_focal") Extensions for focal
  @override
  @JsonKey(name: '_focal')
  final Element? focalElement;

  /// [coverage] Reference to the insurance card level information contained
  ///  in the Coverage resource. The coverage issuing insurer will use these
  ///  details to locate the patient's actual coverage within the insurer's
  ///  information system.
  @override
  final Reference coverage;

  /// [preAuthRef] Reference numbers previously provided by the insurer to
  ///  the provider to be quoted on subsequent claims containing services or
  ///  products related to the prior authorization.
  final List<String>? _preAuthRef;

  /// [preAuthRef] Reference numbers previously provided by the insurer to
  ///  the provider to be quoted on subsequent claims containing services or
  ///  products related to the prior authorization.
  @override
  List<String>? get preAuthRef {
    final value = _preAuthRef;
    if (value == null) return null;
    if (_preAuthRef is EqualUnmodifiableListView) return _preAuthRef;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [preAuthRefElement] ("_preAuthRef") Extensions for preAuthRef
  final List<Element>? _preAuthRefElement;

  /// [preAuthRefElement] ("_preAuthRef") Extensions for preAuthRef
  @override
  @JsonKey(name: '_preAuthRef')
  List<Element>? get preAuthRefElement {
    final value = _preAuthRefElement;
    if (value == null) return null;
    if (_preAuthRefElement is EqualUnmodifiableListView)
      return _preAuthRefElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExplanationOfBenefitInsurance(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, focal: $focal, focalElement: $focalElement, coverage: $coverage, preAuthRef: $preAuthRef, preAuthRefElement: $preAuthRefElement)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitInsuranceImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.focal, focal) || other.focal == focal) &&
            (identical(other.focalElement, focalElement) ||
                other.focalElement == focalElement) &&
            (identical(other.coverage, coverage) ||
                other.coverage == coverage) &&
            const DeepCollectionEquality()
                .equals(other._preAuthRef, _preAuthRef) &&
            const DeepCollectionEquality()
                .equals(other._preAuthRefElement, _preAuthRefElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      focal,
      focalElement,
      coverage,
      const DeepCollectionEquality().hash(_preAuthRef),
      const DeepCollectionEquality().hash(_preAuthRefElement));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitInsuranceImplCopyWith<
          _$ExplanationOfBenefitInsuranceImpl>
      get copyWith => __$$ExplanationOfBenefitInsuranceImplCopyWithImpl<
          _$ExplanationOfBenefitInsuranceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitInsuranceImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitInsurance
    extends ExplanationOfBenefitInsurance {
  const factory _ExplanationOfBenefitInsurance(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final FhirBoolean? focal,
          @JsonKey(name: '_focal') final Element? focalElement,
          required final Reference coverage,
          final List<String>? preAuthRef,
          @JsonKey(name: '_preAuthRef')
          final List<Element>? preAuthRefElement}) =
      _$ExplanationOfBenefitInsuranceImpl;
  const _ExplanationOfBenefitInsurance._() : super._();

  factory _ExplanationOfBenefitInsurance.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitInsuranceImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [focal] A flag to indicate that this Coverage is to be used for
  ///  adjudication of this claim when set to true.
  FhirBoolean? get focal;
  @override

  /// [focalElement] ("_focal") Extensions for focal
  @JsonKey(name: '_focal')
  Element? get focalElement;
  @override

  /// [coverage] Reference to the insurance card level information contained
  ///  in the Coverage resource. The coverage issuing insurer will use these
  ///  details to locate the patient's actual coverage within the insurer's
  ///  information system.
  Reference get coverage;
  @override

  /// [preAuthRef] Reference numbers previously provided by the insurer to
  ///  the provider to be quoted on subsequent claims containing services or
  ///  products related to the prior authorization.
  List<String>? get preAuthRef;
  @override

  /// [preAuthRefElement] ("_preAuthRef") Extensions for preAuthRef
  @JsonKey(name: '_preAuthRef')
  List<Element>? get preAuthRefElement;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitInsuranceImplCopyWith<
          _$ExplanationOfBenefitInsuranceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitAccident _$ExplanationOfBenefitAccidentFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitAccident.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitAccident {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [date] Date of an accident event  related to the products and services
  ///  contained in the claim.
  FhirDate? get date => throw _privateConstructorUsedError;

  /// [dateElement] ("_date") Extensions for date
  @JsonKey(name: '_date')
  Element? get dateElement => throw _privateConstructorUsedError;

  /// [type] The type or context of the accident event for the purposes of
  ///  selection of potential insurance coverages and determination of
  ///  coordination between insurers.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [locationAddress] The physical location of the accident event.
  Address? get locationAddress => throw _privateConstructorUsedError;

  /// [locationReference] The physical location of the accident event.
  Reference? get locationReference => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitAccidentCopyWith<ExplanationOfBenefitAccident>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitAccidentCopyWith<$Res> {
  factory $ExplanationOfBenefitAccidentCopyWith(
          ExplanationOfBenefitAccident value,
          $Res Function(ExplanationOfBenefitAccident) then) =
      _$ExplanationOfBenefitAccidentCopyWithImpl<$Res,
          ExplanationOfBenefitAccident>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirDate? date,
      @JsonKey(name: '_date') Element? dateElement,
      CodeableConcept? type,
      Address? locationAddress,
      Reference? locationReference});

  $ElementCopyWith<$Res>? get dateElement;
  $CodeableConceptCopyWith<$Res>? get type;
  $AddressCopyWith<$Res>? get locationAddress;
  $ReferenceCopyWith<$Res>? get locationReference;
}

/// @nodoc
class _$ExplanationOfBenefitAccidentCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitAccident>
    implements $ExplanationOfBenefitAccidentCopyWith<$Res> {
  _$ExplanationOfBenefitAccidentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? date = freezed,
    Object? dateElement = freezed,
    Object? type = freezed,
    Object? locationAddress = freezed,
    Object? locationReference = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      dateElement: freezed == dateElement
          ? _value.dateElement
          : dateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      locationAddress: freezed == locationAddress
          ? _value.locationAddress
          : locationAddress // ignore: cast_nullable_to_non_nullable
              as Address?,
      locationReference: freezed == locationReference
          ? _value.locationReference
          : locationReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get dateElement {
    if (_value.dateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.dateElement!, (value) {
      return _then(_value.copyWith(dateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AddressCopyWith<$Res>? get locationAddress {
    if (_value.locationAddress == null) {
      return null;
    }

    return $AddressCopyWith<$Res>(_value.locationAddress!, (value) {
      return _then(_value.copyWith(locationAddress: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get locationReference {
    if (_value.locationReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.locationReference!, (value) {
      return _then(_value.copyWith(locationReference: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitAccidentImplCopyWith<$Res>
    implements $ExplanationOfBenefitAccidentCopyWith<$Res> {
  factory _$$ExplanationOfBenefitAccidentImplCopyWith(
          _$ExplanationOfBenefitAccidentImpl value,
          $Res Function(_$ExplanationOfBenefitAccidentImpl) then) =
      __$$ExplanationOfBenefitAccidentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirDate? date,
      @JsonKey(name: '_date') Element? dateElement,
      CodeableConcept? type,
      Address? locationAddress,
      Reference? locationReference});

  @override
  $ElementCopyWith<$Res>? get dateElement;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $AddressCopyWith<$Res>? get locationAddress;
  @override
  $ReferenceCopyWith<$Res>? get locationReference;
}

/// @nodoc
class __$$ExplanationOfBenefitAccidentImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitAccidentCopyWithImpl<$Res,
        _$ExplanationOfBenefitAccidentImpl>
    implements _$$ExplanationOfBenefitAccidentImplCopyWith<$Res> {
  __$$ExplanationOfBenefitAccidentImplCopyWithImpl(
      _$ExplanationOfBenefitAccidentImpl _value,
      $Res Function(_$ExplanationOfBenefitAccidentImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? date = freezed,
    Object? dateElement = freezed,
    Object? type = freezed,
    Object? locationAddress = freezed,
    Object? locationReference = freezed,
  }) {
    return _then(_$ExplanationOfBenefitAccidentImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      dateElement: freezed == dateElement
          ? _value.dateElement
          : dateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      locationAddress: freezed == locationAddress
          ? _value.locationAddress
          : locationAddress // ignore: cast_nullable_to_non_nullable
              as Address?,
      locationReference: freezed == locationReference
          ? _value.locationReference
          : locationReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitAccidentImpl extends _ExplanationOfBenefitAccident {
  const _$ExplanationOfBenefitAccidentImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.date,
      @JsonKey(name: '_date') this.dateElement,
      this.type,
      this.locationAddress,
      this.locationReference})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ExplanationOfBenefitAccidentImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitAccidentImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [date] Date of an accident event  related to the products and services
  ///  contained in the claim.
  @override
  final FhirDate? date;

  /// [dateElement] ("_date") Extensions for date
  @override
  @JsonKey(name: '_date')
  final Element? dateElement;

  /// [type] The type or context of the accident event for the purposes of
  ///  selection of potential insurance coverages and determination of
  ///  coordination between insurers.
  @override
  final CodeableConcept? type;

  /// [locationAddress] The physical location of the accident event.
  @override
  final Address? locationAddress;

  /// [locationReference] The physical location of the accident event.
  @override
  final Reference? locationReference;

  @override
  String toString() {
    return 'ExplanationOfBenefitAccident(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, date: $date, dateElement: $dateElement, type: $type, locationAddress: $locationAddress, locationReference: $locationReference)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitAccidentImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.dateElement, dateElement) ||
                other.dateElement == dateElement) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.locationAddress, locationAddress) ||
                other.locationAddress == locationAddress) &&
            (identical(other.locationReference, locationReference) ||
                other.locationReference == locationReference));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      date,
      dateElement,
      type,
      locationAddress,
      locationReference);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitAccidentImplCopyWith<
          _$ExplanationOfBenefitAccidentImpl>
      get copyWith => __$$ExplanationOfBenefitAccidentImplCopyWithImpl<
          _$ExplanationOfBenefitAccidentImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitAccidentImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitAccident
    extends ExplanationOfBenefitAccident {
  const factory _ExplanationOfBenefitAccident(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final FhirDate? date,
      @JsonKey(name: '_date') final Element? dateElement,
      final CodeableConcept? type,
      final Address? locationAddress,
      final Reference? locationReference}) = _$ExplanationOfBenefitAccidentImpl;
  const _ExplanationOfBenefitAccident._() : super._();

  factory _ExplanationOfBenefitAccident.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitAccidentImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [date] Date of an accident event  related to the products and services
  ///  contained in the claim.
  FhirDate? get date;
  @override

  /// [dateElement] ("_date") Extensions for date
  @JsonKey(name: '_date')
  Element? get dateElement;
  @override

  /// [type] The type or context of the accident event for the purposes of
  ///  selection of potential insurance coverages and determination of
  ///  coordination between insurers.
  CodeableConcept? get type;
  @override

  /// [locationAddress] The physical location of the accident event.
  Address? get locationAddress;
  @override

  /// [locationReference] The physical location of the accident event.
  Reference? get locationReference;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitAccidentImplCopyWith<
          _$ExplanationOfBenefitAccidentImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitItem _$ExplanationOfBenefitItemFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitItem.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitItem {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [sequence] A number to uniquely identify item entries.
  FhirPositiveInt? get sequence => throw _privateConstructorUsedError;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement => throw _privateConstructorUsedError;

  /// [careTeamSequence] Care team members related to this service or product.
  List<FhirPositiveInt>? get careTeamSequence =>
      throw _privateConstructorUsedError;

  /// [careTeamSequenceElement] ("_careTeamSequence") Extensions for
  ///  careTeamSequence
  @JsonKey(name: '_careTeamSequence')
  List<Element>? get careTeamSequenceElement =>
      throw _privateConstructorUsedError;

  /// [diagnosisSequence] Diagnoses applicable for this service or product.
  List<FhirPositiveInt>? get diagnosisSequence =>
      throw _privateConstructorUsedError;

  /// [diagnosisSequenceElement] ("_diagnosisSequence") Extensions for
  ///  diagnosisSequence
  @JsonKey(name: '_diagnosisSequence')
  List<Element>? get diagnosisSequenceElement =>
      throw _privateConstructorUsedError;

  /// [procedureSequence] Procedures applicable for this service or product.
  List<FhirPositiveInt>? get procedureSequence =>
      throw _privateConstructorUsedError;

  /// [procedureSequenceElement] ("_procedureSequence") Extensions for
  ///  procedureSequence
  @JsonKey(name: '_procedureSequence')
  List<Element>? get procedureSequenceElement =>
      throw _privateConstructorUsedError;

  /// [informationSequence] Exceptions, special conditions and supporting
  ///  information applicable for this service or product.
  List<FhirPositiveInt>? get informationSequence =>
      throw _privateConstructorUsedError;

  /// [informationSequenceElement] ("_informationSequence") Extensions for
  ///  informationSequence
  @JsonKey(name: '_informationSequence')
  List<Element>? get informationSequenceElement =>
      throw _privateConstructorUsedError;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber => throw _privateConstructorUsedError;

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  CodeableConcept? get revenue => throw _privateConstructorUsedError;

  /// [category] Code to identify the general type of benefits under which
  ///  products and services are provided.
  CodeableConcept? get category => throw _privateConstructorUsedError;

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  CodeableConcept? get productOrService => throw _privateConstructorUsedError;

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  CodeableConcept? get productOrServiceEnd =>
      throw _privateConstructorUsedError;

  /// [request] Request or Referral for Goods or Service to be rendered.
  List<Reference>? get request => throw _privateConstructorUsedError;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  List<CodeableConcept>? get modifier => throw _privateConstructorUsedError;

  /// [programCode] Identifies the program under which this may be recovered.
  List<CodeableConcept>? get programCode => throw _privateConstructorUsedError;

  /// [servicedDate] The date or dates when the service or product was
  ///  supplied, performed or completed.
  FhirDate? get servicedDate => throw _privateConstructorUsedError;

  /// [servicedDateElement] ("_servicedDate") Extensions for servicedDate
  @JsonKey(name: '_servicedDate')
  Element? get servicedDateElement => throw _privateConstructorUsedError;

  /// [servicedPeriod] The date or dates when the service or product was
  ///  supplied, performed or completed.
  Period? get servicedPeriod => throw _privateConstructorUsedError;

  /// [locationCodeableConcept] Where the product or service was provided.
  CodeableConcept? get locationCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [locationAddress] Where the product or service was provided.
  Address? get locationAddress => throw _privateConstructorUsedError;

  /// [locationReference] Where the product or service was provided.
  Reference? get locationReference => throw _privateConstructorUsedError;

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid => throw _privateConstructorUsedError;

  /// [quantity] The number of repetitions of a service or product.
  Quantity? get quantity => throw _privateConstructorUsedError;

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  Money? get unitPrice => throw _privateConstructorUsedError;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  FhirDecimal? get factor => throw _privateConstructorUsedError;

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement => throw _privateConstructorUsedError;

  /// [tax] The total of taxes applicable for this product or service.
  Money? get tax => throw _privateConstructorUsedError;

  /// [net] The total amount claimed for the group (if a grouper) or the line
  ///  item. Net = unit price * quantity * factor.
  Money? get net => throw _privateConstructorUsedError;

  /// [udi] Unique Device Identifiers associated with this line item.
  List<Reference>? get udi => throw _privateConstructorUsedError;

  /// [bodySite] Physical location where the service is performed or applies.
  List<ExplanationOfBenefitBodySite>? get bodySite =>
      throw _privateConstructorUsedError;

  /// [encounter] Healthcare encounters related to this claim.
  List<Reference>? get encounter => throw _privateConstructorUsedError;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  List<FhirPositiveInt>? get noteNumber => throw _privateConstructorUsedError;

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement => throw _privateConstructorUsedError;

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  ExplanationOfBenefitReviewOutcome? get reviewOutcome =>
      throw _privateConstructorUsedError;

  /// [adjudication] If this item is a group then the values here are a
  ///  summary of the adjudication of the detail items. If this item is a
  ///  simple product or service then this is the result of the adjudication
  ///  of this item.
  List<ExplanationOfBenefitAdjudication>? get adjudication =>
      throw _privateConstructorUsedError;

  /// [detail] Second-tier of goods and services.
  List<ExplanationOfBenefitDetail>? get detail =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitItemCopyWith<ExplanationOfBenefitItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitItemCopyWith<$Res> {
  factory $ExplanationOfBenefitItemCopyWith(ExplanationOfBenefitItem value,
          $Res Function(ExplanationOfBenefitItem) then) =
      _$ExplanationOfBenefitItemCopyWithImpl<$Res, ExplanationOfBenefitItem>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      List<FhirPositiveInt>? careTeamSequence,
      @JsonKey(name: '_careTeamSequence')
      List<Element>? careTeamSequenceElement,
      List<FhirPositiveInt>? diagnosisSequence,
      @JsonKey(name: '_diagnosisSequence')
      List<Element>? diagnosisSequenceElement,
      List<FhirPositiveInt>? procedureSequence,
      @JsonKey(name: '_procedureSequence')
      List<Element>? procedureSequenceElement,
      List<FhirPositiveInt>? informationSequence,
      @JsonKey(name: '_informationSequence')
      List<Element>? informationSequenceElement,
      List<Identifier>? traceNumber,
      CodeableConcept? revenue,
      CodeableConcept? category,
      CodeableConcept? productOrService,
      CodeableConcept? productOrServiceEnd,
      List<Reference>? request,
      List<CodeableConcept>? modifier,
      List<CodeableConcept>? programCode,
      FhirDate? servicedDate,
      @JsonKey(name: '_servicedDate') Element? servicedDateElement,
      Period? servicedPeriod,
      CodeableConcept? locationCodeableConcept,
      Address? locationAddress,
      Reference? locationReference,
      Money? patientPaid,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      Money? tax,
      Money? net,
      List<Reference>? udi,
      List<ExplanationOfBenefitBodySite>? bodySite,
      List<Reference>? encounter,
      List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') List<Element>? noteNumberElement,
      ExplanationOfBenefitReviewOutcome? reviewOutcome,
      List<ExplanationOfBenefitAdjudication>? adjudication,
      List<ExplanationOfBenefitDetail>? detail});

  $ElementCopyWith<$Res>? get sequenceElement;
  $CodeableConceptCopyWith<$Res>? get revenue;
  $CodeableConceptCopyWith<$Res>? get category;
  $CodeableConceptCopyWith<$Res>? get productOrService;
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd;
  $ElementCopyWith<$Res>? get servicedDateElement;
  $PeriodCopyWith<$Res>? get servicedPeriod;
  $CodeableConceptCopyWith<$Res>? get locationCodeableConcept;
  $AddressCopyWith<$Res>? get locationAddress;
  $ReferenceCopyWith<$Res>? get locationReference;
  $MoneyCopyWith<$Res>? get patientPaid;
  $QuantityCopyWith<$Res>? get quantity;
  $MoneyCopyWith<$Res>? get unitPrice;
  $ElementCopyWith<$Res>? get factorElement;
  $MoneyCopyWith<$Res>? get tax;
  $MoneyCopyWith<$Res>? get net;
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome;
}

/// @nodoc
class _$ExplanationOfBenefitItemCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitItem>
    implements $ExplanationOfBenefitItemCopyWith<$Res> {
  _$ExplanationOfBenefitItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? careTeamSequence = freezed,
    Object? careTeamSequenceElement = freezed,
    Object? diagnosisSequence = freezed,
    Object? diagnosisSequenceElement = freezed,
    Object? procedureSequence = freezed,
    Object? procedureSequenceElement = freezed,
    Object? informationSequence = freezed,
    Object? informationSequenceElement = freezed,
    Object? traceNumber = freezed,
    Object? revenue = freezed,
    Object? category = freezed,
    Object? productOrService = freezed,
    Object? productOrServiceEnd = freezed,
    Object? request = freezed,
    Object? modifier = freezed,
    Object? programCode = freezed,
    Object? servicedDate = freezed,
    Object? servicedDateElement = freezed,
    Object? servicedPeriod = freezed,
    Object? locationCodeableConcept = freezed,
    Object? locationAddress = freezed,
    Object? locationReference = freezed,
    Object? patientPaid = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? tax = freezed,
    Object? net = freezed,
    Object? udi = freezed,
    Object? bodySite = freezed,
    Object? encounter = freezed,
    Object? noteNumber = freezed,
    Object? noteNumberElement = freezed,
    Object? reviewOutcome = freezed,
    Object? adjudication = freezed,
    Object? detail = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      careTeamSequence: freezed == careTeamSequence
          ? _value.careTeamSequence
          : careTeamSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      careTeamSequenceElement: freezed == careTeamSequenceElement
          ? _value.careTeamSequenceElement
          : careTeamSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      diagnosisSequence: freezed == diagnosisSequence
          ? _value.diagnosisSequence
          : diagnosisSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      diagnosisSequenceElement: freezed == diagnosisSequenceElement
          ? _value.diagnosisSequenceElement
          : diagnosisSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      procedureSequence: freezed == procedureSequence
          ? _value.procedureSequence
          : procedureSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      procedureSequenceElement: freezed == procedureSequenceElement
          ? _value.procedureSequenceElement
          : procedureSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      informationSequence: freezed == informationSequence
          ? _value.informationSequence
          : informationSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      informationSequenceElement: freezed == informationSequenceElement
          ? _value.informationSequenceElement
          : informationSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      traceNumber: freezed == traceNumber
          ? _value.traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      revenue: freezed == revenue
          ? _value.revenue
          : revenue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrService: freezed == productOrService
          ? _value.productOrService
          : productOrService // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrServiceEnd: freezed == productOrServiceEnd
          ? _value.productOrServiceEnd
          : productOrServiceEnd // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      request: freezed == request
          ? _value.request
          : request // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      modifier: freezed == modifier
          ? _value.modifier
          : modifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      programCode: freezed == programCode
          ? _value.programCode
          : programCode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      servicedDate: freezed == servicedDate
          ? _value.servicedDate
          : servicedDate // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      servicedDateElement: freezed == servicedDateElement
          ? _value.servicedDateElement
          : servicedDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      servicedPeriod: freezed == servicedPeriod
          ? _value.servicedPeriod
          : servicedPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      locationCodeableConcept: freezed == locationCodeableConcept
          ? _value.locationCodeableConcept
          : locationCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      locationAddress: freezed == locationAddress
          ? _value.locationAddress
          : locationAddress // ignore: cast_nullable_to_non_nullable
              as Address?,
      locationReference: freezed == locationReference
          ? _value.locationReference
          : locationReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      tax: freezed == tax
          ? _value.tax
          : tax // ignore: cast_nullable_to_non_nullable
              as Money?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      udi: freezed == udi
          ? _value.udi
          : udi // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      bodySite: freezed == bodySite
          ? _value.bodySite
          : bodySite // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitBodySite>?,
      encounter: freezed == encounter
          ? _value.encounter
          : encounter // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      noteNumber: freezed == noteNumber
          ? _value.noteNumber
          : noteNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      noteNumberElement: freezed == noteNumberElement
          ? _value.noteNumberElement
          : noteNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reviewOutcome: freezed == reviewOutcome
          ? _value.reviewOutcome
          : reviewOutcome // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitReviewOutcome?,
      adjudication: freezed == adjudication
          ? _value.adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
      detail: freezed == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitDetail>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get sequenceElement {
    if (_value.sequenceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.sequenceElement!, (value) {
      return _then(_value.copyWith(sequenceElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get revenue {
    if (_value.revenue == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.revenue!, (value) {
      return _then(_value.copyWith(revenue: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get category {
    if (_value.category == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.category!, (value) {
      return _then(_value.copyWith(category: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get productOrService {
    if (_value.productOrService == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.productOrService!, (value) {
      return _then(_value.copyWith(productOrService: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd {
    if (_value.productOrServiceEnd == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.productOrServiceEnd!, (value) {
      return _then(_value.copyWith(productOrServiceEnd: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get servicedDateElement {
    if (_value.servicedDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.servicedDateElement!, (value) {
      return _then(_value.copyWith(servicedDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get servicedPeriod {
    if (_value.servicedPeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.servicedPeriod!, (value) {
      return _then(_value.copyWith(servicedPeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get locationCodeableConcept {
    if (_value.locationCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.locationCodeableConcept!,
        (value) {
      return _then(_value.copyWith(locationCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AddressCopyWith<$Res>? get locationAddress {
    if (_value.locationAddress == null) {
      return null;
    }

    return $AddressCopyWith<$Res>(_value.locationAddress!, (value) {
      return _then(_value.copyWith(locationAddress: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get locationReference {
    if (_value.locationReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.locationReference!, (value) {
      return _then(_value.copyWith(locationReference: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get patientPaid {
    if (_value.patientPaid == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.patientPaid!, (value) {
      return _then(_value.copyWith(patientPaid: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get quantity {
    if (_value.quantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.quantity!, (value) {
      return _then(_value.copyWith(quantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get unitPrice {
    if (_value.unitPrice == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.unitPrice!, (value) {
      return _then(_value.copyWith(unitPrice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get factorElement {
    if (_value.factorElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.factorElement!, (value) {
      return _then(_value.copyWith(factorElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get tax {
    if (_value.tax == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.tax!, (value) {
      return _then(_value.copyWith(tax: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get net {
    if (_value.net == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.net!, (value) {
      return _then(_value.copyWith(net: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome {
    if (_value.reviewOutcome == null) {
      return null;
    }

    return $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>(
        _value.reviewOutcome!, (value) {
      return _then(_value.copyWith(reviewOutcome: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitItemImplCopyWith<$Res>
    implements $ExplanationOfBenefitItemCopyWith<$Res> {
  factory _$$ExplanationOfBenefitItemImplCopyWith(
          _$ExplanationOfBenefitItemImpl value,
          $Res Function(_$ExplanationOfBenefitItemImpl) then) =
      __$$ExplanationOfBenefitItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      List<FhirPositiveInt>? careTeamSequence,
      @JsonKey(name: '_careTeamSequence')
      List<Element>? careTeamSequenceElement,
      List<FhirPositiveInt>? diagnosisSequence,
      @JsonKey(name: '_diagnosisSequence')
      List<Element>? diagnosisSequenceElement,
      List<FhirPositiveInt>? procedureSequence,
      @JsonKey(name: '_procedureSequence')
      List<Element>? procedureSequenceElement,
      List<FhirPositiveInt>? informationSequence,
      @JsonKey(name: '_informationSequence')
      List<Element>? informationSequenceElement,
      List<Identifier>? traceNumber,
      CodeableConcept? revenue,
      CodeableConcept? category,
      CodeableConcept? productOrService,
      CodeableConcept? productOrServiceEnd,
      List<Reference>? request,
      List<CodeableConcept>? modifier,
      List<CodeableConcept>? programCode,
      FhirDate? servicedDate,
      @JsonKey(name: '_servicedDate') Element? servicedDateElement,
      Period? servicedPeriod,
      CodeableConcept? locationCodeableConcept,
      Address? locationAddress,
      Reference? locationReference,
      Money? patientPaid,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      Money? tax,
      Money? net,
      List<Reference>? udi,
      List<ExplanationOfBenefitBodySite>? bodySite,
      List<Reference>? encounter,
      List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') List<Element>? noteNumberElement,
      ExplanationOfBenefitReviewOutcome? reviewOutcome,
      List<ExplanationOfBenefitAdjudication>? adjudication,
      List<ExplanationOfBenefitDetail>? detail});

  @override
  $ElementCopyWith<$Res>? get sequenceElement;
  @override
  $CodeableConceptCopyWith<$Res>? get revenue;
  @override
  $CodeableConceptCopyWith<$Res>? get category;
  @override
  $CodeableConceptCopyWith<$Res>? get productOrService;
  @override
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd;
  @override
  $ElementCopyWith<$Res>? get servicedDateElement;
  @override
  $PeriodCopyWith<$Res>? get servicedPeriod;
  @override
  $CodeableConceptCopyWith<$Res>? get locationCodeableConcept;
  @override
  $AddressCopyWith<$Res>? get locationAddress;
  @override
  $ReferenceCopyWith<$Res>? get locationReference;
  @override
  $MoneyCopyWith<$Res>? get patientPaid;
  @override
  $QuantityCopyWith<$Res>? get quantity;
  @override
  $MoneyCopyWith<$Res>? get unitPrice;
  @override
  $ElementCopyWith<$Res>? get factorElement;
  @override
  $MoneyCopyWith<$Res>? get tax;
  @override
  $MoneyCopyWith<$Res>? get net;
  @override
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome;
}

/// @nodoc
class __$$ExplanationOfBenefitItemImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitItemCopyWithImpl<$Res,
        _$ExplanationOfBenefitItemImpl>
    implements _$$ExplanationOfBenefitItemImplCopyWith<$Res> {
  __$$ExplanationOfBenefitItemImplCopyWithImpl(
      _$ExplanationOfBenefitItemImpl _value,
      $Res Function(_$ExplanationOfBenefitItemImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? careTeamSequence = freezed,
    Object? careTeamSequenceElement = freezed,
    Object? diagnosisSequence = freezed,
    Object? diagnosisSequenceElement = freezed,
    Object? procedureSequence = freezed,
    Object? procedureSequenceElement = freezed,
    Object? informationSequence = freezed,
    Object? informationSequenceElement = freezed,
    Object? traceNumber = freezed,
    Object? revenue = freezed,
    Object? category = freezed,
    Object? productOrService = freezed,
    Object? productOrServiceEnd = freezed,
    Object? request = freezed,
    Object? modifier = freezed,
    Object? programCode = freezed,
    Object? servicedDate = freezed,
    Object? servicedDateElement = freezed,
    Object? servicedPeriod = freezed,
    Object? locationCodeableConcept = freezed,
    Object? locationAddress = freezed,
    Object? locationReference = freezed,
    Object? patientPaid = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? tax = freezed,
    Object? net = freezed,
    Object? udi = freezed,
    Object? bodySite = freezed,
    Object? encounter = freezed,
    Object? noteNumber = freezed,
    Object? noteNumberElement = freezed,
    Object? reviewOutcome = freezed,
    Object? adjudication = freezed,
    Object? detail = freezed,
  }) {
    return _then(_$ExplanationOfBenefitItemImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      careTeamSequence: freezed == careTeamSequence
          ? _value._careTeamSequence
          : careTeamSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      careTeamSequenceElement: freezed == careTeamSequenceElement
          ? _value._careTeamSequenceElement
          : careTeamSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      diagnosisSequence: freezed == diagnosisSequence
          ? _value._diagnosisSequence
          : diagnosisSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      diagnosisSequenceElement: freezed == diagnosisSequenceElement
          ? _value._diagnosisSequenceElement
          : diagnosisSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      procedureSequence: freezed == procedureSequence
          ? _value._procedureSequence
          : procedureSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      procedureSequenceElement: freezed == procedureSequenceElement
          ? _value._procedureSequenceElement
          : procedureSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      informationSequence: freezed == informationSequence
          ? _value._informationSequence
          : informationSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      informationSequenceElement: freezed == informationSequenceElement
          ? _value._informationSequenceElement
          : informationSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      traceNumber: freezed == traceNumber
          ? _value._traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      revenue: freezed == revenue
          ? _value.revenue
          : revenue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrService: freezed == productOrService
          ? _value.productOrService
          : productOrService // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrServiceEnd: freezed == productOrServiceEnd
          ? _value.productOrServiceEnd
          : productOrServiceEnd // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      request: freezed == request
          ? _value._request
          : request // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      modifier: freezed == modifier
          ? _value._modifier
          : modifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      programCode: freezed == programCode
          ? _value._programCode
          : programCode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      servicedDate: freezed == servicedDate
          ? _value.servicedDate
          : servicedDate // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      servicedDateElement: freezed == servicedDateElement
          ? _value.servicedDateElement
          : servicedDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      servicedPeriod: freezed == servicedPeriod
          ? _value.servicedPeriod
          : servicedPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      locationCodeableConcept: freezed == locationCodeableConcept
          ? _value.locationCodeableConcept
          : locationCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      locationAddress: freezed == locationAddress
          ? _value.locationAddress
          : locationAddress // ignore: cast_nullable_to_non_nullable
              as Address?,
      locationReference: freezed == locationReference
          ? _value.locationReference
          : locationReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      tax: freezed == tax
          ? _value.tax
          : tax // ignore: cast_nullable_to_non_nullable
              as Money?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      udi: freezed == udi
          ? _value._udi
          : udi // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      bodySite: freezed == bodySite
          ? _value._bodySite
          : bodySite // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitBodySite>?,
      encounter: freezed == encounter
          ? _value._encounter
          : encounter // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      noteNumber: freezed == noteNumber
          ? _value._noteNumber
          : noteNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      noteNumberElement: freezed == noteNumberElement
          ? _value._noteNumberElement
          : noteNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reviewOutcome: freezed == reviewOutcome
          ? _value.reviewOutcome
          : reviewOutcome // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitReviewOutcome?,
      adjudication: freezed == adjudication
          ? _value._adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
      detail: freezed == detail
          ? _value._detail
          : detail // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitDetail>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitItemImpl extends _ExplanationOfBenefitItem {
  const _$ExplanationOfBenefitItemImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.sequence,
      @JsonKey(name: '_sequence') this.sequenceElement,
      final List<FhirPositiveInt>? careTeamSequence,
      @JsonKey(name: '_careTeamSequence')
      final List<Element>? careTeamSequenceElement,
      final List<FhirPositiveInt>? diagnosisSequence,
      @JsonKey(name: '_diagnosisSequence')
      final List<Element>? diagnosisSequenceElement,
      final List<FhirPositiveInt>? procedureSequence,
      @JsonKey(name: '_procedureSequence')
      final List<Element>? procedureSequenceElement,
      final List<FhirPositiveInt>? informationSequence,
      @JsonKey(name: '_informationSequence')
      final List<Element>? informationSequenceElement,
      final List<Identifier>? traceNumber,
      this.revenue,
      this.category,
      this.productOrService,
      this.productOrServiceEnd,
      final List<Reference>? request,
      final List<CodeableConcept>? modifier,
      final List<CodeableConcept>? programCode,
      this.servicedDate,
      @JsonKey(name: '_servicedDate') this.servicedDateElement,
      this.servicedPeriod,
      this.locationCodeableConcept,
      this.locationAddress,
      this.locationReference,
      this.patientPaid,
      this.quantity,
      this.unitPrice,
      this.factor,
      @JsonKey(name: '_factor') this.factorElement,
      this.tax,
      this.net,
      final List<Reference>? udi,
      final List<ExplanationOfBenefitBodySite>? bodySite,
      final List<Reference>? encounter,
      final List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') final List<Element>? noteNumberElement,
      this.reviewOutcome,
      final List<ExplanationOfBenefitAdjudication>? adjudication,
      final List<ExplanationOfBenefitDetail>? detail})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _careTeamSequence = careTeamSequence,
        _careTeamSequenceElement = careTeamSequenceElement,
        _diagnosisSequence = diagnosisSequence,
        _diagnosisSequenceElement = diagnosisSequenceElement,
        _procedureSequence = procedureSequence,
        _procedureSequenceElement = procedureSequenceElement,
        _informationSequence = informationSequence,
        _informationSequenceElement = informationSequenceElement,
        _traceNumber = traceNumber,
        _request = request,
        _modifier = modifier,
        _programCode = programCode,
        _udi = udi,
        _bodySite = bodySite,
        _encounter = encounter,
        _noteNumber = noteNumber,
        _noteNumberElement = noteNumberElement,
        _adjudication = adjudication,
        _detail = detail,
        super._();

  factory _$ExplanationOfBenefitItemImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitItemImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sequence] A number to uniquely identify item entries.
  @override
  final FhirPositiveInt? sequence;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @override
  @JsonKey(name: '_sequence')
  final Element? sequenceElement;

  /// [careTeamSequence] Care team members related to this service or product.
  final List<FhirPositiveInt>? _careTeamSequence;

  /// [careTeamSequence] Care team members related to this service or product.
  @override
  List<FhirPositiveInt>? get careTeamSequence {
    final value = _careTeamSequence;
    if (value == null) return null;
    if (_careTeamSequence is EqualUnmodifiableListView)
      return _careTeamSequence;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [careTeamSequenceElement] ("_careTeamSequence") Extensions for
  ///  careTeamSequence
  final List<Element>? _careTeamSequenceElement;

  /// [careTeamSequenceElement] ("_careTeamSequence") Extensions for
  ///  careTeamSequence
  @override
  @JsonKey(name: '_careTeamSequence')
  List<Element>? get careTeamSequenceElement {
    final value = _careTeamSequenceElement;
    if (value == null) return null;
    if (_careTeamSequenceElement is EqualUnmodifiableListView)
      return _careTeamSequenceElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [diagnosisSequence] Diagnoses applicable for this service or product.
  final List<FhirPositiveInt>? _diagnosisSequence;

  /// [diagnosisSequence] Diagnoses applicable for this service or product.
  @override
  List<FhirPositiveInt>? get diagnosisSequence {
    final value = _diagnosisSequence;
    if (value == null) return null;
    if (_diagnosisSequence is EqualUnmodifiableListView)
      return _diagnosisSequence;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [diagnosisSequenceElement] ("_diagnosisSequence") Extensions for
  ///  diagnosisSequence
  final List<Element>? _diagnosisSequenceElement;

  /// [diagnosisSequenceElement] ("_diagnosisSequence") Extensions for
  ///  diagnosisSequence
  @override
  @JsonKey(name: '_diagnosisSequence')
  List<Element>? get diagnosisSequenceElement {
    final value = _diagnosisSequenceElement;
    if (value == null) return null;
    if (_diagnosisSequenceElement is EqualUnmodifiableListView)
      return _diagnosisSequenceElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [procedureSequence] Procedures applicable for this service or product.
  final List<FhirPositiveInt>? _procedureSequence;

  /// [procedureSequence] Procedures applicable for this service or product.
  @override
  List<FhirPositiveInt>? get procedureSequence {
    final value = _procedureSequence;
    if (value == null) return null;
    if (_procedureSequence is EqualUnmodifiableListView)
      return _procedureSequence;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [procedureSequenceElement] ("_procedureSequence") Extensions for
  ///  procedureSequence
  final List<Element>? _procedureSequenceElement;

  /// [procedureSequenceElement] ("_procedureSequence") Extensions for
  ///  procedureSequence
  @override
  @JsonKey(name: '_procedureSequence')
  List<Element>? get procedureSequenceElement {
    final value = _procedureSequenceElement;
    if (value == null) return null;
    if (_procedureSequenceElement is EqualUnmodifiableListView)
      return _procedureSequenceElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [informationSequence] Exceptions, special conditions and supporting
  ///  information applicable for this service or product.
  final List<FhirPositiveInt>? _informationSequence;

  /// [informationSequence] Exceptions, special conditions and supporting
  ///  information applicable for this service or product.
  @override
  List<FhirPositiveInt>? get informationSequence {
    final value = _informationSequence;
    if (value == null) return null;
    if (_informationSequence is EqualUnmodifiableListView)
      return _informationSequence;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [informationSequenceElement] ("_informationSequence") Extensions for
  ///  informationSequence
  final List<Element>? _informationSequenceElement;

  /// [informationSequenceElement] ("_informationSequence") Extensions for
  ///  informationSequence
  @override
  @JsonKey(name: '_informationSequence')
  List<Element>? get informationSequenceElement {
    final value = _informationSequenceElement;
    if (value == null) return null;
    if (_informationSequenceElement is EqualUnmodifiableListView)
      return _informationSequenceElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  final List<Identifier>? _traceNumber;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  @override
  List<Identifier>? get traceNumber {
    final value = _traceNumber;
    if (value == null) return null;
    if (_traceNumber is EqualUnmodifiableListView) return _traceNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  @override
  final CodeableConcept? revenue;

  /// [category] Code to identify the general type of benefits under which
  ///  products and services are provided.
  @override
  final CodeableConcept? category;

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  @override
  final CodeableConcept? productOrService;

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  @override
  final CodeableConcept? productOrServiceEnd;

  /// [request] Request or Referral for Goods or Service to be rendered.
  final List<Reference>? _request;

  /// [request] Request or Referral for Goods or Service to be rendered.
  @override
  List<Reference>? get request {
    final value = _request;
    if (value == null) return null;
    if (_request is EqualUnmodifiableListView) return _request;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  final List<CodeableConcept>? _modifier;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  @override
  List<CodeableConcept>? get modifier {
    final value = _modifier;
    if (value == null) return null;
    if (_modifier is EqualUnmodifiableListView) return _modifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [programCode] Identifies the program under which this may be recovered.
  final List<CodeableConcept>? _programCode;

  /// [programCode] Identifies the program under which this may be recovered.
  @override
  List<CodeableConcept>? get programCode {
    final value = _programCode;
    if (value == null) return null;
    if (_programCode is EqualUnmodifiableListView) return _programCode;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [servicedDate] The date or dates when the service or product was
  ///  supplied, performed or completed.
  @override
  final FhirDate? servicedDate;

  /// [servicedDateElement] ("_servicedDate") Extensions for servicedDate
  @override
  @JsonKey(name: '_servicedDate')
  final Element? servicedDateElement;

  /// [servicedPeriod] The date or dates when the service or product was
  ///  supplied, performed or completed.
  @override
  final Period? servicedPeriod;

  /// [locationCodeableConcept] Where the product or service was provided.
  @override
  final CodeableConcept? locationCodeableConcept;

  /// [locationAddress] Where the product or service was provided.
  @override
  final Address? locationAddress;

  /// [locationReference] Where the product or service was provided.
  @override
  final Reference? locationReference;

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  @override
  final Money? patientPaid;

  /// [quantity] The number of repetitions of a service or product.
  @override
  final Quantity? quantity;

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  @override
  final Money? unitPrice;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  @override
  final FhirDecimal? factor;

  /// [factorElement] ("_factor") Extensions for factor
  @override
  @JsonKey(name: '_factor')
  final Element? factorElement;

  /// [tax] The total of taxes applicable for this product or service.
  @override
  final Money? tax;

  /// [net] The total amount claimed for the group (if a grouper) or the line
  ///  item. Net = unit price * quantity * factor.
  @override
  final Money? net;

  /// [udi] Unique Device Identifiers associated with this line item.
  final List<Reference>? _udi;

  /// [udi] Unique Device Identifiers associated with this line item.
  @override
  List<Reference>? get udi {
    final value = _udi;
    if (value == null) return null;
    if (_udi is EqualUnmodifiableListView) return _udi;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [bodySite] Physical location where the service is performed or applies.
  final List<ExplanationOfBenefitBodySite>? _bodySite;

  /// [bodySite] Physical location where the service is performed or applies.
  @override
  List<ExplanationOfBenefitBodySite>? get bodySite {
    final value = _bodySite;
    if (value == null) return null;
    if (_bodySite is EqualUnmodifiableListView) return _bodySite;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [encounter] Healthcare encounters related to this claim.
  final List<Reference>? _encounter;

  /// [encounter] Healthcare encounters related to this claim.
  @override
  List<Reference>? get encounter {
    final value = _encounter;
    if (value == null) return null;
    if (_encounter is EqualUnmodifiableListView) return _encounter;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  final List<FhirPositiveInt>? _noteNumber;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  @override
  List<FhirPositiveInt>? get noteNumber {
    final value = _noteNumber;
    if (value == null) return null;
    if (_noteNumber is EqualUnmodifiableListView) return _noteNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  final List<Element>? _noteNumberElement;

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @override
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement {
    final value = _noteNumberElement;
    if (value == null) return null;
    if (_noteNumberElement is EqualUnmodifiableListView)
      return _noteNumberElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  @override
  final ExplanationOfBenefitReviewOutcome? reviewOutcome;

  /// [adjudication] If this item is a group then the values here are a
  ///  summary of the adjudication of the detail items. If this item is a
  ///  simple product or service then this is the result of the adjudication
  ///  of this item.
  final List<ExplanationOfBenefitAdjudication>? _adjudication;

  /// [adjudication] If this item is a group then the values here are a
  ///  summary of the adjudication of the detail items. If this item is a
  ///  simple product or service then this is the result of the adjudication
  ///  of this item.
  @override
  List<ExplanationOfBenefitAdjudication>? get adjudication {
    final value = _adjudication;
    if (value == null) return null;
    if (_adjudication is EqualUnmodifiableListView) return _adjudication;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [detail] Second-tier of goods and services.
  final List<ExplanationOfBenefitDetail>? _detail;

  /// [detail] Second-tier of goods and services.
  @override
  List<ExplanationOfBenefitDetail>? get detail {
    final value = _detail;
    if (value == null) return null;
    if (_detail is EqualUnmodifiableListView) return _detail;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExplanationOfBenefitItem(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, sequence: $sequence, sequenceElement: $sequenceElement, careTeamSequence: $careTeamSequence, careTeamSequenceElement: $careTeamSequenceElement, diagnosisSequence: $diagnosisSequence, diagnosisSequenceElement: $diagnosisSequenceElement, procedureSequence: $procedureSequence, procedureSequenceElement: $procedureSequenceElement, informationSequence: $informationSequence, informationSequenceElement: $informationSequenceElement, traceNumber: $traceNumber, revenue: $revenue, category: $category, productOrService: $productOrService, productOrServiceEnd: $productOrServiceEnd, request: $request, modifier: $modifier, programCode: $programCode, servicedDate: $servicedDate, servicedDateElement: $servicedDateElement, servicedPeriod: $servicedPeriod, locationCodeableConcept: $locationCodeableConcept, locationAddress: $locationAddress, locationReference: $locationReference, patientPaid: $patientPaid, quantity: $quantity, unitPrice: $unitPrice, factor: $factor, factorElement: $factorElement, tax: $tax, net: $net, udi: $udi, bodySite: $bodySite, encounter: $encounter, noteNumber: $noteNumber, noteNumberElement: $noteNumberElement, reviewOutcome: $reviewOutcome, adjudication: $adjudication, detail: $detail)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitItemImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.sequence, sequence) ||
                other.sequence == sequence) &&
            (identical(other.sequenceElement, sequenceElement) ||
                other.sequenceElement == sequenceElement) &&
            const DeepCollectionEquality()
                .equals(other._careTeamSequence, _careTeamSequence) &&
            const DeepCollectionEquality().equals(
                other._careTeamSequenceElement, _careTeamSequenceElement) &&
            const DeepCollectionEquality()
                .equals(other._diagnosisSequence, _diagnosisSequence) &&
            const DeepCollectionEquality().equals(
                other._diagnosisSequenceElement, _diagnosisSequenceElement) &&
            const DeepCollectionEquality()
                .equals(other._procedureSequence, _procedureSequence) &&
            const DeepCollectionEquality().equals(
                other._procedureSequenceElement, _procedureSequenceElement) &&
            const DeepCollectionEquality()
                .equals(other._informationSequence, _informationSequence) &&
            const DeepCollectionEquality().equals(
                other._informationSequenceElement,
                _informationSequenceElement) &&
            const DeepCollectionEquality()
                .equals(other._traceNumber, _traceNumber) &&
            (identical(other.revenue, revenue) || other.revenue == revenue) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.productOrService, productOrService) ||
                other.productOrService == productOrService) &&
            (identical(other.productOrServiceEnd, productOrServiceEnd) ||
                other.productOrServiceEnd == productOrServiceEnd) &&
            const DeepCollectionEquality().equals(other._request, _request) &&
            const DeepCollectionEquality().equals(other._modifier, _modifier) &&
            const DeepCollectionEquality()
                .equals(other._programCode, _programCode) &&
            (identical(other.servicedDate, servicedDate) ||
                other.servicedDate == servicedDate) &&
            (identical(other.servicedDateElement, servicedDateElement) ||
                other.servicedDateElement == servicedDateElement) &&
            (identical(other.servicedPeriod, servicedPeriod) ||
                other.servicedPeriod == servicedPeriod) &&
            (identical(
                    other.locationCodeableConcept, locationCodeableConcept) ||
                other.locationCodeableConcept == locationCodeableConcept) &&
            (identical(other.locationAddress, locationAddress) ||
                other.locationAddress == locationAddress) &&
            (identical(other.locationReference, locationReference) ||
                other.locationReference == locationReference) &&
            (identical(other.patientPaid, patientPaid) ||
                other.patientPaid == patientPaid) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.unitPrice, unitPrice) ||
                other.unitPrice == unitPrice) &&
            (identical(other.factor, factor) || other.factor == factor) &&
            (identical(other.factorElement, factorElement) ||
                other.factorElement == factorElement) &&
            (identical(other.tax, tax) || other.tax == tax) &&
            (identical(other.net, net) || other.net == net) &&
            const DeepCollectionEquality().equals(other._udi, _udi) &&
            const DeepCollectionEquality().equals(other._bodySite, _bodySite) &&
            const DeepCollectionEquality()
                .equals(other._encounter, _encounter) &&
            const DeepCollectionEquality()
                .equals(other._noteNumber, _noteNumber) &&
            const DeepCollectionEquality()
                .equals(other._noteNumberElement, _noteNumberElement) &&
            (identical(other.reviewOutcome, reviewOutcome) ||
                other.reviewOutcome == reviewOutcome) &&
            const DeepCollectionEquality()
                .equals(other._adjudication, _adjudication) &&
            const DeepCollectionEquality().equals(other._detail, _detail));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        sequence,
        sequenceElement,
        const DeepCollectionEquality().hash(_careTeamSequence),
        const DeepCollectionEquality().hash(_careTeamSequenceElement),
        const DeepCollectionEquality().hash(_diagnosisSequence),
        const DeepCollectionEquality().hash(_diagnosisSequenceElement),
        const DeepCollectionEquality().hash(_procedureSequence),
        const DeepCollectionEquality().hash(_procedureSequenceElement),
        const DeepCollectionEquality().hash(_informationSequence),
        const DeepCollectionEquality().hash(_informationSequenceElement),
        const DeepCollectionEquality().hash(_traceNumber),
        revenue,
        category,
        productOrService,
        productOrServiceEnd,
        const DeepCollectionEquality().hash(_request),
        const DeepCollectionEquality().hash(_modifier),
        const DeepCollectionEquality().hash(_programCode),
        servicedDate,
        servicedDateElement,
        servicedPeriod,
        locationCodeableConcept,
        locationAddress,
        locationReference,
        patientPaid,
        quantity,
        unitPrice,
        factor,
        factorElement,
        tax,
        net,
        const DeepCollectionEquality().hash(_udi),
        const DeepCollectionEquality().hash(_bodySite),
        const DeepCollectionEquality().hash(_encounter),
        const DeepCollectionEquality().hash(_noteNumber),
        const DeepCollectionEquality().hash(_noteNumberElement),
        reviewOutcome,
        const DeepCollectionEquality().hash(_adjudication),
        const DeepCollectionEquality().hash(_detail)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitItemImplCopyWith<_$ExplanationOfBenefitItemImpl>
      get copyWith => __$$ExplanationOfBenefitItemImplCopyWithImpl<
          _$ExplanationOfBenefitItemImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitItemImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitItem extends ExplanationOfBenefitItem {
  const factory _ExplanationOfBenefitItem(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final FhirPositiveInt? sequence,
          @JsonKey(name: '_sequence') final Element? sequenceElement,
          final List<FhirPositiveInt>? careTeamSequence,
          @JsonKey(name: '_careTeamSequence')
          final List<Element>? careTeamSequenceElement,
          final List<FhirPositiveInt>? diagnosisSequence,
          @JsonKey(name: '_diagnosisSequence')
          final List<Element>? diagnosisSequenceElement,
          final List<FhirPositiveInt>? procedureSequence,
          @JsonKey(name: '_procedureSequence')
          final List<Element>? procedureSequenceElement,
          final List<FhirPositiveInt>? informationSequence,
          @JsonKey(name: '_informationSequence')
          final List<Element>? informationSequenceElement,
          final List<Identifier>? traceNumber,
          final CodeableConcept? revenue,
          final CodeableConcept? category,
          final CodeableConcept? productOrService,
          final CodeableConcept? productOrServiceEnd,
          final List<Reference>? request,
          final List<CodeableConcept>? modifier,
          final List<CodeableConcept>? programCode,
          final FhirDate? servicedDate,
          @JsonKey(name: '_servicedDate') final Element? servicedDateElement,
          final Period? servicedPeriod,
          final CodeableConcept? locationCodeableConcept,
          final Address? locationAddress,
          final Reference? locationReference,
          final Money? patientPaid,
          final Quantity? quantity,
          final Money? unitPrice,
          final FhirDecimal? factor,
          @JsonKey(name: '_factor') final Element? factorElement,
          final Money? tax,
          final Money? net,
          final List<Reference>? udi,
          final List<ExplanationOfBenefitBodySite>? bodySite,
          final List<Reference>? encounter,
          final List<FhirPositiveInt>? noteNumber,
          @JsonKey(name: '_noteNumber') final List<Element>? noteNumberElement,
          final ExplanationOfBenefitReviewOutcome? reviewOutcome,
          final List<ExplanationOfBenefitAdjudication>? adjudication,
          final List<ExplanationOfBenefitDetail>? detail}) =
      _$ExplanationOfBenefitItemImpl;
  const _ExplanationOfBenefitItem._() : super._();

  factory _ExplanationOfBenefitItem.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitItemImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [sequence] A number to uniquely identify item entries.
  FhirPositiveInt? get sequence;
  @override

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement;
  @override

  /// [careTeamSequence] Care team members related to this service or product.
  List<FhirPositiveInt>? get careTeamSequence;
  @override

  /// [careTeamSequenceElement] ("_careTeamSequence") Extensions for
  ///  careTeamSequence
  @JsonKey(name: '_careTeamSequence')
  List<Element>? get careTeamSequenceElement;
  @override

  /// [diagnosisSequence] Diagnoses applicable for this service or product.
  List<FhirPositiveInt>? get diagnosisSequence;
  @override

  /// [diagnosisSequenceElement] ("_diagnosisSequence") Extensions for
  ///  diagnosisSequence
  @JsonKey(name: '_diagnosisSequence')
  List<Element>? get diagnosisSequenceElement;
  @override

  /// [procedureSequence] Procedures applicable for this service or product.
  List<FhirPositiveInt>? get procedureSequence;
  @override

  /// [procedureSequenceElement] ("_procedureSequence") Extensions for
  ///  procedureSequence
  @JsonKey(name: '_procedureSequence')
  List<Element>? get procedureSequenceElement;
  @override

  /// [informationSequence] Exceptions, special conditions and supporting
  ///  information applicable for this service or product.
  List<FhirPositiveInt>? get informationSequence;
  @override

  /// [informationSequenceElement] ("_informationSequence") Extensions for
  ///  informationSequence
  @JsonKey(name: '_informationSequence')
  List<Element>? get informationSequenceElement;
  @override

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber;
  @override

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  CodeableConcept? get revenue;
  @override

  /// [category] Code to identify the general type of benefits under which
  ///  products and services are provided.
  CodeableConcept? get category;
  @override

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  CodeableConcept? get productOrService;
  @override

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  CodeableConcept? get productOrServiceEnd;
  @override

  /// [request] Request or Referral for Goods or Service to be rendered.
  List<Reference>? get request;
  @override

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  List<CodeableConcept>? get modifier;
  @override

  /// [programCode] Identifies the program under which this may be recovered.
  List<CodeableConcept>? get programCode;
  @override

  /// [servicedDate] The date or dates when the service or product was
  ///  supplied, performed or completed.
  FhirDate? get servicedDate;
  @override

  /// [servicedDateElement] ("_servicedDate") Extensions for servicedDate
  @JsonKey(name: '_servicedDate')
  Element? get servicedDateElement;
  @override

  /// [servicedPeriod] The date or dates when the service or product was
  ///  supplied, performed or completed.
  Period? get servicedPeriod;
  @override

  /// [locationCodeableConcept] Where the product or service was provided.
  CodeableConcept? get locationCodeableConcept;
  @override

  /// [locationAddress] Where the product or service was provided.
  Address? get locationAddress;
  @override

  /// [locationReference] Where the product or service was provided.
  Reference? get locationReference;
  @override

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid;
  @override

  /// [quantity] The number of repetitions of a service or product.
  Quantity? get quantity;
  @override

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  Money? get unitPrice;
  @override

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  FhirDecimal? get factor;
  @override

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement;
  @override

  /// [tax] The total of taxes applicable for this product or service.
  Money? get tax;
  @override

  /// [net] The total amount claimed for the group (if a grouper) or the line
  ///  item. Net = unit price * quantity * factor.
  Money? get net;
  @override

  /// [udi] Unique Device Identifiers associated with this line item.
  List<Reference>? get udi;
  @override

  /// [bodySite] Physical location where the service is performed or applies.
  List<ExplanationOfBenefitBodySite>? get bodySite;
  @override

  /// [encounter] Healthcare encounters related to this claim.
  List<Reference>? get encounter;
  @override

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  List<FhirPositiveInt>? get noteNumber;
  @override

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement;
  @override

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  ExplanationOfBenefitReviewOutcome? get reviewOutcome;
  @override

  /// [adjudication] If this item is a group then the values here are a
  ///  summary of the adjudication of the detail items. If this item is a
  ///  simple product or service then this is the result of the adjudication
  ///  of this item.
  List<ExplanationOfBenefitAdjudication>? get adjudication;
  @override

  /// [detail] Second-tier of goods and services.
  List<ExplanationOfBenefitDetail>? get detail;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitItemImplCopyWith<_$ExplanationOfBenefitItemImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitBodySite _$ExplanationOfBenefitBodySiteFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitBodySite.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitBodySite {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [site] Physical service site on the patient (limb, tooth, etc.).
  List<CodeableReference> get site => throw _privateConstructorUsedError;

  /// [subSite] A region or surface of the bodySite, e.g. limb region or
  ///  tooth surface(s).
  List<CodeableConcept>? get subSite => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitBodySiteCopyWith<ExplanationOfBenefitBodySite>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitBodySiteCopyWith<$Res> {
  factory $ExplanationOfBenefitBodySiteCopyWith(
          ExplanationOfBenefitBodySite value,
          $Res Function(ExplanationOfBenefitBodySite) then) =
      _$ExplanationOfBenefitBodySiteCopyWithImpl<$Res,
          ExplanationOfBenefitBodySite>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<CodeableReference> site,
      List<CodeableConcept>? subSite});
}

/// @nodoc
class _$ExplanationOfBenefitBodySiteCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitBodySite>
    implements $ExplanationOfBenefitBodySiteCopyWith<$Res> {
  _$ExplanationOfBenefitBodySiteCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? site = null,
    Object? subSite = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      site: null == site
          ? _value.site
          : site // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>,
      subSite: freezed == subSite
          ? _value.subSite
          : subSite // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitBodySiteImplCopyWith<$Res>
    implements $ExplanationOfBenefitBodySiteCopyWith<$Res> {
  factory _$$ExplanationOfBenefitBodySiteImplCopyWith(
          _$ExplanationOfBenefitBodySiteImpl value,
          $Res Function(_$ExplanationOfBenefitBodySiteImpl) then) =
      __$$ExplanationOfBenefitBodySiteImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<CodeableReference> site,
      List<CodeableConcept>? subSite});
}

/// @nodoc
class __$$ExplanationOfBenefitBodySiteImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitBodySiteCopyWithImpl<$Res,
        _$ExplanationOfBenefitBodySiteImpl>
    implements _$$ExplanationOfBenefitBodySiteImplCopyWith<$Res> {
  __$$ExplanationOfBenefitBodySiteImplCopyWithImpl(
      _$ExplanationOfBenefitBodySiteImpl _value,
      $Res Function(_$ExplanationOfBenefitBodySiteImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? site = null,
    Object? subSite = freezed,
  }) {
    return _then(_$ExplanationOfBenefitBodySiteImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      site: null == site
          ? _value._site
          : site // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>,
      subSite: freezed == subSite
          ? _value._subSite
          : subSite // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitBodySiteImpl extends _ExplanationOfBenefitBodySite {
  const _$ExplanationOfBenefitBodySiteImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final List<CodeableReference> site,
      final List<CodeableConcept>? subSite})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _site = site,
        _subSite = subSite,
        super._();

  factory _$ExplanationOfBenefitBodySiteImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitBodySiteImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [site] Physical service site on the patient (limb, tooth, etc.).
  final List<CodeableReference> _site;

  /// [site] Physical service site on the patient (limb, tooth, etc.).
  @override
  List<CodeableReference> get site {
    if (_site is EqualUnmodifiableListView) return _site;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_site);
  }

  /// [subSite] A region or surface of the bodySite, e.g. limb region or
  ///  tooth surface(s).
  final List<CodeableConcept>? _subSite;

  /// [subSite] A region or surface of the bodySite, e.g. limb region or
  ///  tooth surface(s).
  @override
  List<CodeableConcept>? get subSite {
    final value = _subSite;
    if (value == null) return null;
    if (_subSite is EqualUnmodifiableListView) return _subSite;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExplanationOfBenefitBodySite(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, site: $site, subSite: $subSite)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitBodySiteImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality().equals(other._site, _site) &&
            const DeepCollectionEquality().equals(other._subSite, _subSite));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_site),
      const DeepCollectionEquality().hash(_subSite));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitBodySiteImplCopyWith<
          _$ExplanationOfBenefitBodySiteImpl>
      get copyWith => __$$ExplanationOfBenefitBodySiteImplCopyWithImpl<
          _$ExplanationOfBenefitBodySiteImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitBodySiteImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitBodySite
    extends ExplanationOfBenefitBodySite {
  const factory _ExplanationOfBenefitBodySite(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final List<CodeableReference> site,
          final List<CodeableConcept>? subSite}) =
      _$ExplanationOfBenefitBodySiteImpl;
  const _ExplanationOfBenefitBodySite._() : super._();

  factory _ExplanationOfBenefitBodySite.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitBodySiteImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [site] Physical service site on the patient (limb, tooth, etc.).
  List<CodeableReference> get site;
  @override

  /// [subSite] A region or surface of the bodySite, e.g. limb region or
  ///  tooth surface(s).
  List<CodeableConcept>? get subSite;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitBodySiteImplCopyWith<
          _$ExplanationOfBenefitBodySiteImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitReviewOutcome _$ExplanationOfBenefitReviewOutcomeFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitReviewOutcome.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitReviewOutcome {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [decision] The result of the claim, predetermination, or
  ///  preauthorization adjudication.
  CodeableConcept? get decision => throw _privateConstructorUsedError;

  /// [reason] The reasons for the result of the claim, predetermination, or
  ///  preauthorization adjudication.
  List<CodeableConcept>? get reason => throw _privateConstructorUsedError;

  /// [preAuthRef] Reference from the Insurer which is used in later
  ///  communications which refers to this adjudication.
  String? get preAuthRef => throw _privateConstructorUsedError;

  /// [preAuthRefElement] ("_preAuthRef") Extensions for preAuthRef
  @JsonKey(name: '_preAuthRef')
  Element? get preAuthRefElement => throw _privateConstructorUsedError;

  /// [preAuthPeriod] The time frame during which this authorization is
  ///  effective.
  Period? get preAuthPeriod => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitReviewOutcomeCopyWith<ExplanationOfBenefitReviewOutcome>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitReviewOutcomeCopyWith<$Res> {
  factory $ExplanationOfBenefitReviewOutcomeCopyWith(
          ExplanationOfBenefitReviewOutcome value,
          $Res Function(ExplanationOfBenefitReviewOutcome) then) =
      _$ExplanationOfBenefitReviewOutcomeCopyWithImpl<$Res,
          ExplanationOfBenefitReviewOutcome>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? decision,
      List<CodeableConcept>? reason,
      String? preAuthRef,
      @JsonKey(name: '_preAuthRef') Element? preAuthRefElement,
      Period? preAuthPeriod});

  $CodeableConceptCopyWith<$Res>? get decision;
  $ElementCopyWith<$Res>? get preAuthRefElement;
  $PeriodCopyWith<$Res>? get preAuthPeriod;
}

/// @nodoc
class _$ExplanationOfBenefitReviewOutcomeCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitReviewOutcome>
    implements $ExplanationOfBenefitReviewOutcomeCopyWith<$Res> {
  _$ExplanationOfBenefitReviewOutcomeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? decision = freezed,
    Object? reason = freezed,
    Object? preAuthRef = freezed,
    Object? preAuthRefElement = freezed,
    Object? preAuthPeriod = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      decision: freezed == decision
          ? _value.decision
          : decision // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      preAuthRef: freezed == preAuthRef
          ? _value.preAuthRef
          : preAuthRef // ignore: cast_nullable_to_non_nullable
              as String?,
      preAuthRefElement: freezed == preAuthRefElement
          ? _value.preAuthRefElement
          : preAuthRefElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      preAuthPeriod: freezed == preAuthPeriod
          ? _value.preAuthPeriod
          : preAuthPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get decision {
    if (_value.decision == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.decision!, (value) {
      return _then(_value.copyWith(decision: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get preAuthRefElement {
    if (_value.preAuthRefElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.preAuthRefElement!, (value) {
      return _then(_value.copyWith(preAuthRefElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get preAuthPeriod {
    if (_value.preAuthPeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.preAuthPeriod!, (value) {
      return _then(_value.copyWith(preAuthPeriod: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitReviewOutcomeImplCopyWith<$Res>
    implements $ExplanationOfBenefitReviewOutcomeCopyWith<$Res> {
  factory _$$ExplanationOfBenefitReviewOutcomeImplCopyWith(
          _$ExplanationOfBenefitReviewOutcomeImpl value,
          $Res Function(_$ExplanationOfBenefitReviewOutcomeImpl) then) =
      __$$ExplanationOfBenefitReviewOutcomeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? decision,
      List<CodeableConcept>? reason,
      String? preAuthRef,
      @JsonKey(name: '_preAuthRef') Element? preAuthRefElement,
      Period? preAuthPeriod});

  @override
  $CodeableConceptCopyWith<$Res>? get decision;
  @override
  $ElementCopyWith<$Res>? get preAuthRefElement;
  @override
  $PeriodCopyWith<$Res>? get preAuthPeriod;
}

/// @nodoc
class __$$ExplanationOfBenefitReviewOutcomeImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitReviewOutcomeCopyWithImpl<$Res,
        _$ExplanationOfBenefitReviewOutcomeImpl>
    implements _$$ExplanationOfBenefitReviewOutcomeImplCopyWith<$Res> {
  __$$ExplanationOfBenefitReviewOutcomeImplCopyWithImpl(
      _$ExplanationOfBenefitReviewOutcomeImpl _value,
      $Res Function(_$ExplanationOfBenefitReviewOutcomeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? decision = freezed,
    Object? reason = freezed,
    Object? preAuthRef = freezed,
    Object? preAuthRefElement = freezed,
    Object? preAuthPeriod = freezed,
  }) {
    return _then(_$ExplanationOfBenefitReviewOutcomeImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      decision: freezed == decision
          ? _value.decision
          : decision // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      reason: freezed == reason
          ? _value._reason
          : reason // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      preAuthRef: freezed == preAuthRef
          ? _value.preAuthRef
          : preAuthRef // ignore: cast_nullable_to_non_nullable
              as String?,
      preAuthRefElement: freezed == preAuthRefElement
          ? _value.preAuthRefElement
          : preAuthRefElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      preAuthPeriod: freezed == preAuthPeriod
          ? _value.preAuthPeriod
          : preAuthPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitReviewOutcomeImpl
    extends _ExplanationOfBenefitReviewOutcome {
  const _$ExplanationOfBenefitReviewOutcomeImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.decision,
      final List<CodeableConcept>? reason,
      this.preAuthRef,
      @JsonKey(name: '_preAuthRef') this.preAuthRefElement,
      this.preAuthPeriod})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _reason = reason,
        super._();

  factory _$ExplanationOfBenefitReviewOutcomeImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitReviewOutcomeImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [decision] The result of the claim, predetermination, or
  ///  preauthorization adjudication.
  @override
  final CodeableConcept? decision;

  /// [reason] The reasons for the result of the claim, predetermination, or
  ///  preauthorization adjudication.
  final List<CodeableConcept>? _reason;

  /// [reason] The reasons for the result of the claim, predetermination, or
  ///  preauthorization adjudication.
  @override
  List<CodeableConcept>? get reason {
    final value = _reason;
    if (value == null) return null;
    if (_reason is EqualUnmodifiableListView) return _reason;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [preAuthRef] Reference from the Insurer which is used in later
  ///  communications which refers to this adjudication.
  @override
  final String? preAuthRef;

  /// [preAuthRefElement] ("_preAuthRef") Extensions for preAuthRef
  @override
  @JsonKey(name: '_preAuthRef')
  final Element? preAuthRefElement;

  /// [preAuthPeriod] The time frame during which this authorization is
  ///  effective.
  @override
  final Period? preAuthPeriod;

  @override
  String toString() {
    return 'ExplanationOfBenefitReviewOutcome(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, decision: $decision, reason: $reason, preAuthRef: $preAuthRef, preAuthRefElement: $preAuthRefElement, preAuthPeriod: $preAuthPeriod)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitReviewOutcomeImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.decision, decision) ||
                other.decision == decision) &&
            const DeepCollectionEquality().equals(other._reason, _reason) &&
            (identical(other.preAuthRef, preAuthRef) ||
                other.preAuthRef == preAuthRef) &&
            (identical(other.preAuthRefElement, preAuthRefElement) ||
                other.preAuthRefElement == preAuthRefElement) &&
            (identical(other.preAuthPeriod, preAuthPeriod) ||
                other.preAuthPeriod == preAuthPeriod));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      decision,
      const DeepCollectionEquality().hash(_reason),
      preAuthRef,
      preAuthRefElement,
      preAuthPeriod);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitReviewOutcomeImplCopyWith<
          _$ExplanationOfBenefitReviewOutcomeImpl>
      get copyWith => __$$ExplanationOfBenefitReviewOutcomeImplCopyWithImpl<
          _$ExplanationOfBenefitReviewOutcomeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitReviewOutcomeImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitReviewOutcome
    extends ExplanationOfBenefitReviewOutcome {
  const factory _ExplanationOfBenefitReviewOutcome(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? decision,
      final List<CodeableConcept>? reason,
      final String? preAuthRef,
      @JsonKey(name: '_preAuthRef') final Element? preAuthRefElement,
      final Period? preAuthPeriod}) = _$ExplanationOfBenefitReviewOutcomeImpl;
  const _ExplanationOfBenefitReviewOutcome._() : super._();

  factory _ExplanationOfBenefitReviewOutcome.fromJson(
          Map<String, dynamic> json) =
      _$ExplanationOfBenefitReviewOutcomeImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [decision] The result of the claim, predetermination, or
  ///  preauthorization adjudication.
  CodeableConcept? get decision;
  @override

  /// [reason] The reasons for the result of the claim, predetermination, or
  ///  preauthorization adjudication.
  List<CodeableConcept>? get reason;
  @override

  /// [preAuthRef] Reference from the Insurer which is used in later
  ///  communications which refers to this adjudication.
  String? get preAuthRef;
  @override

  /// [preAuthRefElement] ("_preAuthRef") Extensions for preAuthRef
  @JsonKey(name: '_preAuthRef')
  Element? get preAuthRefElement;
  @override

  /// [preAuthPeriod] The time frame during which this authorization is
  ///  effective.
  Period? get preAuthPeriod;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitReviewOutcomeImplCopyWith<
          _$ExplanationOfBenefitReviewOutcomeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitAdjudication _$ExplanationOfBenefitAdjudicationFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitAdjudication.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitAdjudication {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [category] A code to indicate the information type of this adjudication
  ///  record. Information types may include: the value submitted, maximum
  ///  values or percentages allowed or payable under the plan, amounts that
  ///  the patient is responsible for in-aggregate or pertaining to this
  ///  item, amounts paid by other coverages, and the benefit payable for
  ///  this item.
  CodeableConcept get category => throw _privateConstructorUsedError;

  /// [reason] A code supporting the understanding of the adjudication result
  ///  and explaining variance from expected amount.
  CodeableConcept? get reason => throw _privateConstructorUsedError;

  /// [amount] Monetary amount associated with the category.
  Money? get amount => throw _privateConstructorUsedError;

  /// [quantity] A non-monetary value associated with the category. Mutually
  ///  exclusive to the amount element above.
  Quantity? get quantity => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitAdjudicationCopyWith<ExplanationOfBenefitAdjudication>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitAdjudicationCopyWith<$Res> {
  factory $ExplanationOfBenefitAdjudicationCopyWith(
          ExplanationOfBenefitAdjudication value,
          $Res Function(ExplanationOfBenefitAdjudication) then) =
      _$ExplanationOfBenefitAdjudicationCopyWithImpl<$Res,
          ExplanationOfBenefitAdjudication>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept category,
      CodeableConcept? reason,
      Money? amount,
      Quantity? quantity});

  $CodeableConceptCopyWith<$Res> get category;
  $CodeableConceptCopyWith<$Res>? get reason;
  $MoneyCopyWith<$Res>? get amount;
  $QuantityCopyWith<$Res>? get quantity;
}

/// @nodoc
class _$ExplanationOfBenefitAdjudicationCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitAdjudication>
    implements $ExplanationOfBenefitAdjudicationCopyWith<$Res> {
  _$ExplanationOfBenefitAdjudicationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? category = null,
    Object? reason = freezed,
    Object? amount = freezed,
    Object? quantity = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get category {
    return $CodeableConceptCopyWith<$Res>(_value.category, (value) {
      return _then(_value.copyWith(category: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get reason {
    if (_value.reason == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.reason!, (value) {
      return _then(_value.copyWith(reason: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get amount {
    if (_value.amount == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.amount!, (value) {
      return _then(_value.copyWith(amount: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get quantity {
    if (_value.quantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.quantity!, (value) {
      return _then(_value.copyWith(quantity: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitAdjudicationImplCopyWith<$Res>
    implements $ExplanationOfBenefitAdjudicationCopyWith<$Res> {
  factory _$$ExplanationOfBenefitAdjudicationImplCopyWith(
          _$ExplanationOfBenefitAdjudicationImpl value,
          $Res Function(_$ExplanationOfBenefitAdjudicationImpl) then) =
      __$$ExplanationOfBenefitAdjudicationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept category,
      CodeableConcept? reason,
      Money? amount,
      Quantity? quantity});

  @override
  $CodeableConceptCopyWith<$Res> get category;
  @override
  $CodeableConceptCopyWith<$Res>? get reason;
  @override
  $MoneyCopyWith<$Res>? get amount;
  @override
  $QuantityCopyWith<$Res>? get quantity;
}

/// @nodoc
class __$$ExplanationOfBenefitAdjudicationImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitAdjudicationCopyWithImpl<$Res,
        _$ExplanationOfBenefitAdjudicationImpl>
    implements _$$ExplanationOfBenefitAdjudicationImplCopyWith<$Res> {
  __$$ExplanationOfBenefitAdjudicationImplCopyWithImpl(
      _$ExplanationOfBenefitAdjudicationImpl _value,
      $Res Function(_$ExplanationOfBenefitAdjudicationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? category = null,
    Object? reason = freezed,
    Object? amount = freezed,
    Object? quantity = freezed,
  }) {
    return _then(_$ExplanationOfBenefitAdjudicationImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      reason: freezed == reason
          ? _value.reason
          : reason // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitAdjudicationImpl
    extends _ExplanationOfBenefitAdjudication {
  const _$ExplanationOfBenefitAdjudicationImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.category,
      this.reason,
      this.amount,
      this.quantity})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ExplanationOfBenefitAdjudicationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitAdjudicationImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [category] A code to indicate the information type of this adjudication
  ///  record. Information types may include: the value submitted, maximum
  ///  values or percentages allowed or payable under the plan, amounts that
  ///  the patient is responsible for in-aggregate or pertaining to this
  ///  item, amounts paid by other coverages, and the benefit payable for
  ///  this item.
  @override
  final CodeableConcept category;

  /// [reason] A code supporting the understanding of the adjudication result
  ///  and explaining variance from expected amount.
  @override
  final CodeableConcept? reason;

  /// [amount] Monetary amount associated with the category.
  @override
  final Money? amount;

  /// [quantity] A non-monetary value associated with the category. Mutually
  ///  exclusive to the amount element above.
  @override
  final Quantity? quantity;

  @override
  String toString() {
    return 'ExplanationOfBenefitAdjudication(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, category: $category, reason: $reason, amount: $amount, quantity: $quantity)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitAdjudicationImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.reason, reason) || other.reason == reason) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      category,
      reason,
      amount,
      quantity);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitAdjudicationImplCopyWith<
          _$ExplanationOfBenefitAdjudicationImpl>
      get copyWith => __$$ExplanationOfBenefitAdjudicationImplCopyWithImpl<
          _$ExplanationOfBenefitAdjudicationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitAdjudicationImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitAdjudication
    extends ExplanationOfBenefitAdjudication {
  const factory _ExplanationOfBenefitAdjudication(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableConcept category,
      final CodeableConcept? reason,
      final Money? amount,
      final Quantity? quantity}) = _$ExplanationOfBenefitAdjudicationImpl;
  const _ExplanationOfBenefitAdjudication._() : super._();

  factory _ExplanationOfBenefitAdjudication.fromJson(
          Map<String, dynamic> json) =
      _$ExplanationOfBenefitAdjudicationImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [category] A code to indicate the information type of this adjudication
  ///  record. Information types may include: the value submitted, maximum
  ///  values or percentages allowed or payable under the plan, amounts that
  ///  the patient is responsible for in-aggregate or pertaining to this
  ///  item, amounts paid by other coverages, and the benefit payable for
  ///  this item.
  CodeableConcept get category;
  @override

  /// [reason] A code supporting the understanding of the adjudication result
  ///  and explaining variance from expected amount.
  CodeableConcept? get reason;
  @override

  /// [amount] Monetary amount associated with the category.
  Money? get amount;
  @override

  /// [quantity] A non-monetary value associated with the category. Mutually
  ///  exclusive to the amount element above.
  Quantity? get quantity;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitAdjudicationImplCopyWith<
          _$ExplanationOfBenefitAdjudicationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitDetail _$ExplanationOfBenefitDetailFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitDetail.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitDetail {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [sequence] A claim detail line. Either a simple (a product or service)
  ///  or a 'group' of sub-details which are simple items.
  FhirPositiveInt? get sequence => throw _privateConstructorUsedError;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement => throw _privateConstructorUsedError;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber => throw _privateConstructorUsedError;

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  CodeableConcept? get revenue => throw _privateConstructorUsedError;

  /// [category] Code to identify the general type of benefits under which
  ///  products and services are provided.
  CodeableConcept? get category => throw _privateConstructorUsedError;

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  CodeableConcept? get productOrService => throw _privateConstructorUsedError;

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  CodeableConcept? get productOrServiceEnd =>
      throw _privateConstructorUsedError;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  List<CodeableConcept>? get modifier => throw _privateConstructorUsedError;

  /// [programCode] Identifies the program under which this may be recovered.
  List<CodeableConcept>? get programCode => throw _privateConstructorUsedError;

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid => throw _privateConstructorUsedError;

  /// [quantity] The number of repetitions of a service or product.
  Quantity? get quantity => throw _privateConstructorUsedError;

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  Money? get unitPrice => throw _privateConstructorUsedError;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  FhirDecimal? get factor => throw _privateConstructorUsedError;

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement => throw _privateConstructorUsedError;

  /// [tax] The total of taxes applicable for this product or service.
  Money? get tax => throw _privateConstructorUsedError;

  /// [net] The total amount claimed for the group (if a grouper) or the line
  ///  item.detail. Net = unit price * quantity * factor.
  Money? get net => throw _privateConstructorUsedError;

  /// [udi] Unique Device Identifiers associated with this line item.
  List<Reference>? get udi => throw _privateConstructorUsedError;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  List<FhirPositiveInt>? get noteNumber => throw _privateConstructorUsedError;

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement => throw _privateConstructorUsedError;

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  ExplanationOfBenefitReviewOutcome? get reviewOutcome =>
      throw _privateConstructorUsedError;

  /// [adjudication] The adjudication results.
  List<ExplanationOfBenefitAdjudication>? get adjudication =>
      throw _privateConstructorUsedError;

  /// [subDetail] Third-tier of goods and services.
  List<ExplanationOfBenefitSubDetail>? get subDetail =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitDetailCopyWith<ExplanationOfBenefitDetail>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitDetailCopyWith<$Res> {
  factory $ExplanationOfBenefitDetailCopyWith(ExplanationOfBenefitDetail value,
          $Res Function(ExplanationOfBenefitDetail) then) =
      _$ExplanationOfBenefitDetailCopyWithImpl<$Res,
          ExplanationOfBenefitDetail>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      List<Identifier>? traceNumber,
      CodeableConcept? revenue,
      CodeableConcept? category,
      CodeableConcept? productOrService,
      CodeableConcept? productOrServiceEnd,
      List<CodeableConcept>? modifier,
      List<CodeableConcept>? programCode,
      Money? patientPaid,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      Money? tax,
      Money? net,
      List<Reference>? udi,
      List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') List<Element>? noteNumberElement,
      ExplanationOfBenefitReviewOutcome? reviewOutcome,
      List<ExplanationOfBenefitAdjudication>? adjudication,
      List<ExplanationOfBenefitSubDetail>? subDetail});

  $ElementCopyWith<$Res>? get sequenceElement;
  $CodeableConceptCopyWith<$Res>? get revenue;
  $CodeableConceptCopyWith<$Res>? get category;
  $CodeableConceptCopyWith<$Res>? get productOrService;
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd;
  $MoneyCopyWith<$Res>? get patientPaid;
  $QuantityCopyWith<$Res>? get quantity;
  $MoneyCopyWith<$Res>? get unitPrice;
  $ElementCopyWith<$Res>? get factorElement;
  $MoneyCopyWith<$Res>? get tax;
  $MoneyCopyWith<$Res>? get net;
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome;
}

/// @nodoc
class _$ExplanationOfBenefitDetailCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitDetail>
    implements $ExplanationOfBenefitDetailCopyWith<$Res> {
  _$ExplanationOfBenefitDetailCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? traceNumber = freezed,
    Object? revenue = freezed,
    Object? category = freezed,
    Object? productOrService = freezed,
    Object? productOrServiceEnd = freezed,
    Object? modifier = freezed,
    Object? programCode = freezed,
    Object? patientPaid = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? tax = freezed,
    Object? net = freezed,
    Object? udi = freezed,
    Object? noteNumber = freezed,
    Object? noteNumberElement = freezed,
    Object? reviewOutcome = freezed,
    Object? adjudication = freezed,
    Object? subDetail = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      traceNumber: freezed == traceNumber
          ? _value.traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      revenue: freezed == revenue
          ? _value.revenue
          : revenue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrService: freezed == productOrService
          ? _value.productOrService
          : productOrService // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrServiceEnd: freezed == productOrServiceEnd
          ? _value.productOrServiceEnd
          : productOrServiceEnd // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      modifier: freezed == modifier
          ? _value.modifier
          : modifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      programCode: freezed == programCode
          ? _value.programCode
          : programCode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      tax: freezed == tax
          ? _value.tax
          : tax // ignore: cast_nullable_to_non_nullable
              as Money?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      udi: freezed == udi
          ? _value.udi
          : udi // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      noteNumber: freezed == noteNumber
          ? _value.noteNumber
          : noteNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      noteNumberElement: freezed == noteNumberElement
          ? _value.noteNumberElement
          : noteNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reviewOutcome: freezed == reviewOutcome
          ? _value.reviewOutcome
          : reviewOutcome // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitReviewOutcome?,
      adjudication: freezed == adjudication
          ? _value.adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
      subDetail: freezed == subDetail
          ? _value.subDetail
          : subDetail // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitSubDetail>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get sequenceElement {
    if (_value.sequenceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.sequenceElement!, (value) {
      return _then(_value.copyWith(sequenceElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get revenue {
    if (_value.revenue == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.revenue!, (value) {
      return _then(_value.copyWith(revenue: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get category {
    if (_value.category == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.category!, (value) {
      return _then(_value.copyWith(category: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get productOrService {
    if (_value.productOrService == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.productOrService!, (value) {
      return _then(_value.copyWith(productOrService: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd {
    if (_value.productOrServiceEnd == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.productOrServiceEnd!, (value) {
      return _then(_value.copyWith(productOrServiceEnd: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get patientPaid {
    if (_value.patientPaid == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.patientPaid!, (value) {
      return _then(_value.copyWith(patientPaid: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get quantity {
    if (_value.quantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.quantity!, (value) {
      return _then(_value.copyWith(quantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get unitPrice {
    if (_value.unitPrice == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.unitPrice!, (value) {
      return _then(_value.copyWith(unitPrice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get factorElement {
    if (_value.factorElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.factorElement!, (value) {
      return _then(_value.copyWith(factorElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get tax {
    if (_value.tax == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.tax!, (value) {
      return _then(_value.copyWith(tax: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get net {
    if (_value.net == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.net!, (value) {
      return _then(_value.copyWith(net: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome {
    if (_value.reviewOutcome == null) {
      return null;
    }

    return $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>(
        _value.reviewOutcome!, (value) {
      return _then(_value.copyWith(reviewOutcome: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitDetailImplCopyWith<$Res>
    implements $ExplanationOfBenefitDetailCopyWith<$Res> {
  factory _$$ExplanationOfBenefitDetailImplCopyWith(
          _$ExplanationOfBenefitDetailImpl value,
          $Res Function(_$ExplanationOfBenefitDetailImpl) then) =
      __$$ExplanationOfBenefitDetailImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      List<Identifier>? traceNumber,
      CodeableConcept? revenue,
      CodeableConcept? category,
      CodeableConcept? productOrService,
      CodeableConcept? productOrServiceEnd,
      List<CodeableConcept>? modifier,
      List<CodeableConcept>? programCode,
      Money? patientPaid,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      Money? tax,
      Money? net,
      List<Reference>? udi,
      List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') List<Element>? noteNumberElement,
      ExplanationOfBenefitReviewOutcome? reviewOutcome,
      List<ExplanationOfBenefitAdjudication>? adjudication,
      List<ExplanationOfBenefitSubDetail>? subDetail});

  @override
  $ElementCopyWith<$Res>? get sequenceElement;
  @override
  $CodeableConceptCopyWith<$Res>? get revenue;
  @override
  $CodeableConceptCopyWith<$Res>? get category;
  @override
  $CodeableConceptCopyWith<$Res>? get productOrService;
  @override
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd;
  @override
  $MoneyCopyWith<$Res>? get patientPaid;
  @override
  $QuantityCopyWith<$Res>? get quantity;
  @override
  $MoneyCopyWith<$Res>? get unitPrice;
  @override
  $ElementCopyWith<$Res>? get factorElement;
  @override
  $MoneyCopyWith<$Res>? get tax;
  @override
  $MoneyCopyWith<$Res>? get net;
  @override
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome;
}

/// @nodoc
class __$$ExplanationOfBenefitDetailImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitDetailCopyWithImpl<$Res,
        _$ExplanationOfBenefitDetailImpl>
    implements _$$ExplanationOfBenefitDetailImplCopyWith<$Res> {
  __$$ExplanationOfBenefitDetailImplCopyWithImpl(
      _$ExplanationOfBenefitDetailImpl _value,
      $Res Function(_$ExplanationOfBenefitDetailImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? traceNumber = freezed,
    Object? revenue = freezed,
    Object? category = freezed,
    Object? productOrService = freezed,
    Object? productOrServiceEnd = freezed,
    Object? modifier = freezed,
    Object? programCode = freezed,
    Object? patientPaid = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? tax = freezed,
    Object? net = freezed,
    Object? udi = freezed,
    Object? noteNumber = freezed,
    Object? noteNumberElement = freezed,
    Object? reviewOutcome = freezed,
    Object? adjudication = freezed,
    Object? subDetail = freezed,
  }) {
    return _then(_$ExplanationOfBenefitDetailImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      traceNumber: freezed == traceNumber
          ? _value._traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      revenue: freezed == revenue
          ? _value.revenue
          : revenue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrService: freezed == productOrService
          ? _value.productOrService
          : productOrService // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrServiceEnd: freezed == productOrServiceEnd
          ? _value.productOrServiceEnd
          : productOrServiceEnd // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      modifier: freezed == modifier
          ? _value._modifier
          : modifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      programCode: freezed == programCode
          ? _value._programCode
          : programCode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      tax: freezed == tax
          ? _value.tax
          : tax // ignore: cast_nullable_to_non_nullable
              as Money?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      udi: freezed == udi
          ? _value._udi
          : udi // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      noteNumber: freezed == noteNumber
          ? _value._noteNumber
          : noteNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      noteNumberElement: freezed == noteNumberElement
          ? _value._noteNumberElement
          : noteNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reviewOutcome: freezed == reviewOutcome
          ? _value.reviewOutcome
          : reviewOutcome // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitReviewOutcome?,
      adjudication: freezed == adjudication
          ? _value._adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
      subDetail: freezed == subDetail
          ? _value._subDetail
          : subDetail // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitSubDetail>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitDetailImpl extends _ExplanationOfBenefitDetail {
  const _$ExplanationOfBenefitDetailImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.sequence,
      @JsonKey(name: '_sequence') this.sequenceElement,
      final List<Identifier>? traceNumber,
      this.revenue,
      this.category,
      this.productOrService,
      this.productOrServiceEnd,
      final List<CodeableConcept>? modifier,
      final List<CodeableConcept>? programCode,
      this.patientPaid,
      this.quantity,
      this.unitPrice,
      this.factor,
      @JsonKey(name: '_factor') this.factorElement,
      this.tax,
      this.net,
      final List<Reference>? udi,
      final List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') final List<Element>? noteNumberElement,
      this.reviewOutcome,
      final List<ExplanationOfBenefitAdjudication>? adjudication,
      final List<ExplanationOfBenefitSubDetail>? subDetail})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _traceNumber = traceNumber,
        _modifier = modifier,
        _programCode = programCode,
        _udi = udi,
        _noteNumber = noteNumber,
        _noteNumberElement = noteNumberElement,
        _adjudication = adjudication,
        _subDetail = subDetail,
        super._();

  factory _$ExplanationOfBenefitDetailImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitDetailImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sequence] A claim detail line. Either a simple (a product or service)
  ///  or a 'group' of sub-details which are simple items.
  @override
  final FhirPositiveInt? sequence;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @override
  @JsonKey(name: '_sequence')
  final Element? sequenceElement;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  final List<Identifier>? _traceNumber;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  @override
  List<Identifier>? get traceNumber {
    final value = _traceNumber;
    if (value == null) return null;
    if (_traceNumber is EqualUnmodifiableListView) return _traceNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  @override
  final CodeableConcept? revenue;

  /// [category] Code to identify the general type of benefits under which
  ///  products and services are provided.
  @override
  final CodeableConcept? category;

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  @override
  final CodeableConcept? productOrService;

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  @override
  final CodeableConcept? productOrServiceEnd;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  final List<CodeableConcept>? _modifier;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  @override
  List<CodeableConcept>? get modifier {
    final value = _modifier;
    if (value == null) return null;
    if (_modifier is EqualUnmodifiableListView) return _modifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [programCode] Identifies the program under which this may be recovered.
  final List<CodeableConcept>? _programCode;

  /// [programCode] Identifies the program under which this may be recovered.
  @override
  List<CodeableConcept>? get programCode {
    final value = _programCode;
    if (value == null) return null;
    if (_programCode is EqualUnmodifiableListView) return _programCode;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  @override
  final Money? patientPaid;

  /// [quantity] The number of repetitions of a service or product.
  @override
  final Quantity? quantity;

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  @override
  final Money? unitPrice;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  @override
  final FhirDecimal? factor;

  /// [factorElement] ("_factor") Extensions for factor
  @override
  @JsonKey(name: '_factor')
  final Element? factorElement;

  /// [tax] The total of taxes applicable for this product or service.
  @override
  final Money? tax;

  /// [net] The total amount claimed for the group (if a grouper) or the line
  ///  item.detail. Net = unit price * quantity * factor.
  @override
  final Money? net;

  /// [udi] Unique Device Identifiers associated with this line item.
  final List<Reference>? _udi;

  /// [udi] Unique Device Identifiers associated with this line item.
  @override
  List<Reference>? get udi {
    final value = _udi;
    if (value == null) return null;
    if (_udi is EqualUnmodifiableListView) return _udi;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  final List<FhirPositiveInt>? _noteNumber;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  @override
  List<FhirPositiveInt>? get noteNumber {
    final value = _noteNumber;
    if (value == null) return null;
    if (_noteNumber is EqualUnmodifiableListView) return _noteNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  final List<Element>? _noteNumberElement;

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @override
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement {
    final value = _noteNumberElement;
    if (value == null) return null;
    if (_noteNumberElement is EqualUnmodifiableListView)
      return _noteNumberElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  @override
  final ExplanationOfBenefitReviewOutcome? reviewOutcome;

  /// [adjudication] The adjudication results.
  final List<ExplanationOfBenefitAdjudication>? _adjudication;

  /// [adjudication] The adjudication results.
  @override
  List<ExplanationOfBenefitAdjudication>? get adjudication {
    final value = _adjudication;
    if (value == null) return null;
    if (_adjudication is EqualUnmodifiableListView) return _adjudication;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [subDetail] Third-tier of goods and services.
  final List<ExplanationOfBenefitSubDetail>? _subDetail;

  /// [subDetail] Third-tier of goods and services.
  @override
  List<ExplanationOfBenefitSubDetail>? get subDetail {
    final value = _subDetail;
    if (value == null) return null;
    if (_subDetail is EqualUnmodifiableListView) return _subDetail;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExplanationOfBenefitDetail(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, sequence: $sequence, sequenceElement: $sequenceElement, traceNumber: $traceNumber, revenue: $revenue, category: $category, productOrService: $productOrService, productOrServiceEnd: $productOrServiceEnd, modifier: $modifier, programCode: $programCode, patientPaid: $patientPaid, quantity: $quantity, unitPrice: $unitPrice, factor: $factor, factorElement: $factorElement, tax: $tax, net: $net, udi: $udi, noteNumber: $noteNumber, noteNumberElement: $noteNumberElement, reviewOutcome: $reviewOutcome, adjudication: $adjudication, subDetail: $subDetail)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitDetailImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.sequence, sequence) ||
                other.sequence == sequence) &&
            (identical(other.sequenceElement, sequenceElement) ||
                other.sequenceElement == sequenceElement) &&
            const DeepCollectionEquality()
                .equals(other._traceNumber, _traceNumber) &&
            (identical(other.revenue, revenue) || other.revenue == revenue) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.productOrService, productOrService) ||
                other.productOrService == productOrService) &&
            (identical(other.productOrServiceEnd, productOrServiceEnd) ||
                other.productOrServiceEnd == productOrServiceEnd) &&
            const DeepCollectionEquality().equals(other._modifier, _modifier) &&
            const DeepCollectionEquality()
                .equals(other._programCode, _programCode) &&
            (identical(other.patientPaid, patientPaid) ||
                other.patientPaid == patientPaid) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.unitPrice, unitPrice) ||
                other.unitPrice == unitPrice) &&
            (identical(other.factor, factor) || other.factor == factor) &&
            (identical(other.factorElement, factorElement) ||
                other.factorElement == factorElement) &&
            (identical(other.tax, tax) || other.tax == tax) &&
            (identical(other.net, net) || other.net == net) &&
            const DeepCollectionEquality().equals(other._udi, _udi) &&
            const DeepCollectionEquality()
                .equals(other._noteNumber, _noteNumber) &&
            const DeepCollectionEquality()
                .equals(other._noteNumberElement, _noteNumberElement) &&
            (identical(other.reviewOutcome, reviewOutcome) ||
                other.reviewOutcome == reviewOutcome) &&
            const DeepCollectionEquality()
                .equals(other._adjudication, _adjudication) &&
            const DeepCollectionEquality()
                .equals(other._subDetail, _subDetail));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        sequence,
        sequenceElement,
        const DeepCollectionEquality().hash(_traceNumber),
        revenue,
        category,
        productOrService,
        productOrServiceEnd,
        const DeepCollectionEquality().hash(_modifier),
        const DeepCollectionEquality().hash(_programCode),
        patientPaid,
        quantity,
        unitPrice,
        factor,
        factorElement,
        tax,
        net,
        const DeepCollectionEquality().hash(_udi),
        const DeepCollectionEquality().hash(_noteNumber),
        const DeepCollectionEquality().hash(_noteNumberElement),
        reviewOutcome,
        const DeepCollectionEquality().hash(_adjudication),
        const DeepCollectionEquality().hash(_subDetail)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitDetailImplCopyWith<_$ExplanationOfBenefitDetailImpl>
      get copyWith => __$$ExplanationOfBenefitDetailImplCopyWithImpl<
          _$ExplanationOfBenefitDetailImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitDetailImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitDetail extends ExplanationOfBenefitDetail {
  const factory _ExplanationOfBenefitDetail(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final FhirPositiveInt? sequence,
          @JsonKey(name: '_sequence') final Element? sequenceElement,
          final List<Identifier>? traceNumber,
          final CodeableConcept? revenue,
          final CodeableConcept? category,
          final CodeableConcept? productOrService,
          final CodeableConcept? productOrServiceEnd,
          final List<CodeableConcept>? modifier,
          final List<CodeableConcept>? programCode,
          final Money? patientPaid,
          final Quantity? quantity,
          final Money? unitPrice,
          final FhirDecimal? factor,
          @JsonKey(name: '_factor') final Element? factorElement,
          final Money? tax,
          final Money? net,
          final List<Reference>? udi,
          final List<FhirPositiveInt>? noteNumber,
          @JsonKey(name: '_noteNumber') final List<Element>? noteNumberElement,
          final ExplanationOfBenefitReviewOutcome? reviewOutcome,
          final List<ExplanationOfBenefitAdjudication>? adjudication,
          final List<ExplanationOfBenefitSubDetail>? subDetail}) =
      _$ExplanationOfBenefitDetailImpl;
  const _ExplanationOfBenefitDetail._() : super._();

  factory _ExplanationOfBenefitDetail.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitDetailImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [sequence] A claim detail line. Either a simple (a product or service)
  ///  or a 'group' of sub-details which are simple items.
  FhirPositiveInt? get sequence;
  @override

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement;
  @override

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber;
  @override

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  CodeableConcept? get revenue;
  @override

  /// [category] Code to identify the general type of benefits under which
  ///  products and services are provided.
  CodeableConcept? get category;
  @override

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  CodeableConcept? get productOrService;
  @override

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  CodeableConcept? get productOrServiceEnd;
  @override

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  List<CodeableConcept>? get modifier;
  @override

  /// [programCode] Identifies the program under which this may be recovered.
  List<CodeableConcept>? get programCode;
  @override

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid;
  @override

  /// [quantity] The number of repetitions of a service or product.
  Quantity? get quantity;
  @override

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  Money? get unitPrice;
  @override

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  FhirDecimal? get factor;
  @override

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement;
  @override

  /// [tax] The total of taxes applicable for this product or service.
  Money? get tax;
  @override

  /// [net] The total amount claimed for the group (if a grouper) or the line
  ///  item.detail. Net = unit price * quantity * factor.
  Money? get net;
  @override

  /// [udi] Unique Device Identifiers associated with this line item.
  List<Reference>? get udi;
  @override

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  List<FhirPositiveInt>? get noteNumber;
  @override

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement;
  @override

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  ExplanationOfBenefitReviewOutcome? get reviewOutcome;
  @override

  /// [adjudication] The adjudication results.
  List<ExplanationOfBenefitAdjudication>? get adjudication;
  @override

  /// [subDetail] Third-tier of goods and services.
  List<ExplanationOfBenefitSubDetail>? get subDetail;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitDetailImplCopyWith<_$ExplanationOfBenefitDetailImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitSubDetail _$ExplanationOfBenefitSubDetailFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitSubDetail.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitSubDetail {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [sequence] A claim detail line. Either a simple (a product or service)
  ///  or a 'group' of sub-details which are simple items.
  FhirPositiveInt? get sequence => throw _privateConstructorUsedError;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement => throw _privateConstructorUsedError;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber => throw _privateConstructorUsedError;

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  CodeableConcept? get revenue => throw _privateConstructorUsedError;

  /// [category] Code to identify the general type of benefits under which
  ///  products and services are provided.
  CodeableConcept? get category => throw _privateConstructorUsedError;

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  CodeableConcept? get productOrService => throw _privateConstructorUsedError;

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  CodeableConcept? get productOrServiceEnd =>
      throw _privateConstructorUsedError;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  List<CodeableConcept>? get modifier => throw _privateConstructorUsedError;

  /// [programCode] Identifies the program under which this may be recovered.
  List<CodeableConcept>? get programCode => throw _privateConstructorUsedError;

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid => throw _privateConstructorUsedError;

  /// [quantity] The number of repetitions of a service or product.
  Quantity? get quantity => throw _privateConstructorUsedError;

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  Money? get unitPrice => throw _privateConstructorUsedError;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  FhirDecimal? get factor => throw _privateConstructorUsedError;

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement => throw _privateConstructorUsedError;

  /// [tax] The total of taxes applicable for this product or service.
  Money? get tax => throw _privateConstructorUsedError;

  /// [net] The total amount claimed for the line item.detail.subDetail. Net
  ///  = unit price * quantity * factor.
  Money? get net => throw _privateConstructorUsedError;

  /// [udi] Unique Device Identifiers associated with this line item.
  List<Reference>? get udi => throw _privateConstructorUsedError;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  List<FhirPositiveInt>? get noteNumber => throw _privateConstructorUsedError;

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement => throw _privateConstructorUsedError;

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  ExplanationOfBenefitReviewOutcome? get reviewOutcome =>
      throw _privateConstructorUsedError;

  /// [adjudication] The adjudication results.
  List<ExplanationOfBenefitAdjudication>? get adjudication =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitSubDetailCopyWith<ExplanationOfBenefitSubDetail>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitSubDetailCopyWith<$Res> {
  factory $ExplanationOfBenefitSubDetailCopyWith(
          ExplanationOfBenefitSubDetail value,
          $Res Function(ExplanationOfBenefitSubDetail) then) =
      _$ExplanationOfBenefitSubDetailCopyWithImpl<$Res,
          ExplanationOfBenefitSubDetail>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      List<Identifier>? traceNumber,
      CodeableConcept? revenue,
      CodeableConcept? category,
      CodeableConcept? productOrService,
      CodeableConcept? productOrServiceEnd,
      List<CodeableConcept>? modifier,
      List<CodeableConcept>? programCode,
      Money? patientPaid,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      Money? tax,
      Money? net,
      List<Reference>? udi,
      List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') List<Element>? noteNumberElement,
      ExplanationOfBenefitReviewOutcome? reviewOutcome,
      List<ExplanationOfBenefitAdjudication>? adjudication});

  $ElementCopyWith<$Res>? get sequenceElement;
  $CodeableConceptCopyWith<$Res>? get revenue;
  $CodeableConceptCopyWith<$Res>? get category;
  $CodeableConceptCopyWith<$Res>? get productOrService;
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd;
  $MoneyCopyWith<$Res>? get patientPaid;
  $QuantityCopyWith<$Res>? get quantity;
  $MoneyCopyWith<$Res>? get unitPrice;
  $ElementCopyWith<$Res>? get factorElement;
  $MoneyCopyWith<$Res>? get tax;
  $MoneyCopyWith<$Res>? get net;
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome;
}

/// @nodoc
class _$ExplanationOfBenefitSubDetailCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitSubDetail>
    implements $ExplanationOfBenefitSubDetailCopyWith<$Res> {
  _$ExplanationOfBenefitSubDetailCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? traceNumber = freezed,
    Object? revenue = freezed,
    Object? category = freezed,
    Object? productOrService = freezed,
    Object? productOrServiceEnd = freezed,
    Object? modifier = freezed,
    Object? programCode = freezed,
    Object? patientPaid = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? tax = freezed,
    Object? net = freezed,
    Object? udi = freezed,
    Object? noteNumber = freezed,
    Object? noteNumberElement = freezed,
    Object? reviewOutcome = freezed,
    Object? adjudication = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      traceNumber: freezed == traceNumber
          ? _value.traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      revenue: freezed == revenue
          ? _value.revenue
          : revenue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrService: freezed == productOrService
          ? _value.productOrService
          : productOrService // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrServiceEnd: freezed == productOrServiceEnd
          ? _value.productOrServiceEnd
          : productOrServiceEnd // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      modifier: freezed == modifier
          ? _value.modifier
          : modifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      programCode: freezed == programCode
          ? _value.programCode
          : programCode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      tax: freezed == tax
          ? _value.tax
          : tax // ignore: cast_nullable_to_non_nullable
              as Money?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      udi: freezed == udi
          ? _value.udi
          : udi // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      noteNumber: freezed == noteNumber
          ? _value.noteNumber
          : noteNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      noteNumberElement: freezed == noteNumberElement
          ? _value.noteNumberElement
          : noteNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reviewOutcome: freezed == reviewOutcome
          ? _value.reviewOutcome
          : reviewOutcome // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitReviewOutcome?,
      adjudication: freezed == adjudication
          ? _value.adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get sequenceElement {
    if (_value.sequenceElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.sequenceElement!, (value) {
      return _then(_value.copyWith(sequenceElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get revenue {
    if (_value.revenue == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.revenue!, (value) {
      return _then(_value.copyWith(revenue: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get category {
    if (_value.category == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.category!, (value) {
      return _then(_value.copyWith(category: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get productOrService {
    if (_value.productOrService == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.productOrService!, (value) {
      return _then(_value.copyWith(productOrService: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd {
    if (_value.productOrServiceEnd == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.productOrServiceEnd!, (value) {
      return _then(_value.copyWith(productOrServiceEnd: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get patientPaid {
    if (_value.patientPaid == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.patientPaid!, (value) {
      return _then(_value.copyWith(patientPaid: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get quantity {
    if (_value.quantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.quantity!, (value) {
      return _then(_value.copyWith(quantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get unitPrice {
    if (_value.unitPrice == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.unitPrice!, (value) {
      return _then(_value.copyWith(unitPrice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get factorElement {
    if (_value.factorElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.factorElement!, (value) {
      return _then(_value.copyWith(factorElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get tax {
    if (_value.tax == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.tax!, (value) {
      return _then(_value.copyWith(tax: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get net {
    if (_value.net == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.net!, (value) {
      return _then(_value.copyWith(net: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome {
    if (_value.reviewOutcome == null) {
      return null;
    }

    return $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>(
        _value.reviewOutcome!, (value) {
      return _then(_value.copyWith(reviewOutcome: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitSubDetailImplCopyWith<$Res>
    implements $ExplanationOfBenefitSubDetailCopyWith<$Res> {
  factory _$$ExplanationOfBenefitSubDetailImplCopyWith(
          _$ExplanationOfBenefitSubDetailImpl value,
          $Res Function(_$ExplanationOfBenefitSubDetailImpl) then) =
      __$$ExplanationOfBenefitSubDetailImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? sequence,
      @JsonKey(name: '_sequence') Element? sequenceElement,
      List<Identifier>? traceNumber,
      CodeableConcept? revenue,
      CodeableConcept? category,
      CodeableConcept? productOrService,
      CodeableConcept? productOrServiceEnd,
      List<CodeableConcept>? modifier,
      List<CodeableConcept>? programCode,
      Money? patientPaid,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      Money? tax,
      Money? net,
      List<Reference>? udi,
      List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') List<Element>? noteNumberElement,
      ExplanationOfBenefitReviewOutcome? reviewOutcome,
      List<ExplanationOfBenefitAdjudication>? adjudication});

  @override
  $ElementCopyWith<$Res>? get sequenceElement;
  @override
  $CodeableConceptCopyWith<$Res>? get revenue;
  @override
  $CodeableConceptCopyWith<$Res>? get category;
  @override
  $CodeableConceptCopyWith<$Res>? get productOrService;
  @override
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd;
  @override
  $MoneyCopyWith<$Res>? get patientPaid;
  @override
  $QuantityCopyWith<$Res>? get quantity;
  @override
  $MoneyCopyWith<$Res>? get unitPrice;
  @override
  $ElementCopyWith<$Res>? get factorElement;
  @override
  $MoneyCopyWith<$Res>? get tax;
  @override
  $MoneyCopyWith<$Res>? get net;
  @override
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome;
}

/// @nodoc
class __$$ExplanationOfBenefitSubDetailImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitSubDetailCopyWithImpl<$Res,
        _$ExplanationOfBenefitSubDetailImpl>
    implements _$$ExplanationOfBenefitSubDetailImplCopyWith<$Res> {
  __$$ExplanationOfBenefitSubDetailImplCopyWithImpl(
      _$ExplanationOfBenefitSubDetailImpl _value,
      $Res Function(_$ExplanationOfBenefitSubDetailImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? sequence = freezed,
    Object? sequenceElement = freezed,
    Object? traceNumber = freezed,
    Object? revenue = freezed,
    Object? category = freezed,
    Object? productOrService = freezed,
    Object? productOrServiceEnd = freezed,
    Object? modifier = freezed,
    Object? programCode = freezed,
    Object? patientPaid = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? tax = freezed,
    Object? net = freezed,
    Object? udi = freezed,
    Object? noteNumber = freezed,
    Object? noteNumberElement = freezed,
    Object? reviewOutcome = freezed,
    Object? adjudication = freezed,
  }) {
    return _then(_$ExplanationOfBenefitSubDetailImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      sequenceElement: freezed == sequenceElement
          ? _value.sequenceElement
          : sequenceElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      traceNumber: freezed == traceNumber
          ? _value._traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      revenue: freezed == revenue
          ? _value.revenue
          : revenue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrService: freezed == productOrService
          ? _value.productOrService
          : productOrService // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrServiceEnd: freezed == productOrServiceEnd
          ? _value.productOrServiceEnd
          : productOrServiceEnd // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      modifier: freezed == modifier
          ? _value._modifier
          : modifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      programCode: freezed == programCode
          ? _value._programCode
          : programCode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      tax: freezed == tax
          ? _value.tax
          : tax // ignore: cast_nullable_to_non_nullable
              as Money?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      udi: freezed == udi
          ? _value._udi
          : udi // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      noteNumber: freezed == noteNumber
          ? _value._noteNumber
          : noteNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      noteNumberElement: freezed == noteNumberElement
          ? _value._noteNumberElement
          : noteNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reviewOutcome: freezed == reviewOutcome
          ? _value.reviewOutcome
          : reviewOutcome // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitReviewOutcome?,
      adjudication: freezed == adjudication
          ? _value._adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitSubDetailImpl
    extends _ExplanationOfBenefitSubDetail {
  const _$ExplanationOfBenefitSubDetailImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.sequence,
      @JsonKey(name: '_sequence') this.sequenceElement,
      final List<Identifier>? traceNumber,
      this.revenue,
      this.category,
      this.productOrService,
      this.productOrServiceEnd,
      final List<CodeableConcept>? modifier,
      final List<CodeableConcept>? programCode,
      this.patientPaid,
      this.quantity,
      this.unitPrice,
      this.factor,
      @JsonKey(name: '_factor') this.factorElement,
      this.tax,
      this.net,
      final List<Reference>? udi,
      final List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') final List<Element>? noteNumberElement,
      this.reviewOutcome,
      final List<ExplanationOfBenefitAdjudication>? adjudication})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _traceNumber = traceNumber,
        _modifier = modifier,
        _programCode = programCode,
        _udi = udi,
        _noteNumber = noteNumber,
        _noteNumberElement = noteNumberElement,
        _adjudication = adjudication,
        super._();

  factory _$ExplanationOfBenefitSubDetailImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitSubDetailImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sequence] A claim detail line. Either a simple (a product or service)
  ///  or a 'group' of sub-details which are simple items.
  @override
  final FhirPositiveInt? sequence;

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @override
  @JsonKey(name: '_sequence')
  final Element? sequenceElement;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  final List<Identifier>? _traceNumber;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  @override
  List<Identifier>? get traceNumber {
    final value = _traceNumber;
    if (value == null) return null;
    if (_traceNumber is EqualUnmodifiableListView) return _traceNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  @override
  final CodeableConcept? revenue;

  /// [category] Code to identify the general type of benefits under which
  ///  products and services are provided.
  @override
  final CodeableConcept? category;

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  @override
  final CodeableConcept? productOrService;

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  @override
  final CodeableConcept? productOrServiceEnd;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  final List<CodeableConcept>? _modifier;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  @override
  List<CodeableConcept>? get modifier {
    final value = _modifier;
    if (value == null) return null;
    if (_modifier is EqualUnmodifiableListView) return _modifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [programCode] Identifies the program under which this may be recovered.
  final List<CodeableConcept>? _programCode;

  /// [programCode] Identifies the program under which this may be recovered.
  @override
  List<CodeableConcept>? get programCode {
    final value = _programCode;
    if (value == null) return null;
    if (_programCode is EqualUnmodifiableListView) return _programCode;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  @override
  final Money? patientPaid;

  /// [quantity] The number of repetitions of a service or product.
  @override
  final Quantity? quantity;

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  @override
  final Money? unitPrice;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  @override
  final FhirDecimal? factor;

  /// [factorElement] ("_factor") Extensions for factor
  @override
  @JsonKey(name: '_factor')
  final Element? factorElement;

  /// [tax] The total of taxes applicable for this product or service.
  @override
  final Money? tax;

  /// [net] The total amount claimed for the line item.detail.subDetail. Net
  ///  = unit price * quantity * factor.
  @override
  final Money? net;

  /// [udi] Unique Device Identifiers associated with this line item.
  final List<Reference>? _udi;

  /// [udi] Unique Device Identifiers associated with this line item.
  @override
  List<Reference>? get udi {
    final value = _udi;
    if (value == null) return null;
    if (_udi is EqualUnmodifiableListView) return _udi;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  final List<FhirPositiveInt>? _noteNumber;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  @override
  List<FhirPositiveInt>? get noteNumber {
    final value = _noteNumber;
    if (value == null) return null;
    if (_noteNumber is EqualUnmodifiableListView) return _noteNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  final List<Element>? _noteNumberElement;

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @override
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement {
    final value = _noteNumberElement;
    if (value == null) return null;
    if (_noteNumberElement is EqualUnmodifiableListView)
      return _noteNumberElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  @override
  final ExplanationOfBenefitReviewOutcome? reviewOutcome;

  /// [adjudication] The adjudication results.
  final List<ExplanationOfBenefitAdjudication>? _adjudication;

  /// [adjudication] The adjudication results.
  @override
  List<ExplanationOfBenefitAdjudication>? get adjudication {
    final value = _adjudication;
    if (value == null) return null;
    if (_adjudication is EqualUnmodifiableListView) return _adjudication;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExplanationOfBenefitSubDetail(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, sequence: $sequence, sequenceElement: $sequenceElement, traceNumber: $traceNumber, revenue: $revenue, category: $category, productOrService: $productOrService, productOrServiceEnd: $productOrServiceEnd, modifier: $modifier, programCode: $programCode, patientPaid: $patientPaid, quantity: $quantity, unitPrice: $unitPrice, factor: $factor, factorElement: $factorElement, tax: $tax, net: $net, udi: $udi, noteNumber: $noteNumber, noteNumberElement: $noteNumberElement, reviewOutcome: $reviewOutcome, adjudication: $adjudication)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitSubDetailImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.sequence, sequence) ||
                other.sequence == sequence) &&
            (identical(other.sequenceElement, sequenceElement) ||
                other.sequenceElement == sequenceElement) &&
            const DeepCollectionEquality()
                .equals(other._traceNumber, _traceNumber) &&
            (identical(other.revenue, revenue) || other.revenue == revenue) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.productOrService, productOrService) ||
                other.productOrService == productOrService) &&
            (identical(other.productOrServiceEnd, productOrServiceEnd) ||
                other.productOrServiceEnd == productOrServiceEnd) &&
            const DeepCollectionEquality().equals(other._modifier, _modifier) &&
            const DeepCollectionEquality()
                .equals(other._programCode, _programCode) &&
            (identical(other.patientPaid, patientPaid) ||
                other.patientPaid == patientPaid) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.unitPrice, unitPrice) ||
                other.unitPrice == unitPrice) &&
            (identical(other.factor, factor) || other.factor == factor) &&
            (identical(other.factorElement, factorElement) ||
                other.factorElement == factorElement) &&
            (identical(other.tax, tax) || other.tax == tax) &&
            (identical(other.net, net) || other.net == net) &&
            const DeepCollectionEquality().equals(other._udi, _udi) &&
            const DeepCollectionEquality()
                .equals(other._noteNumber, _noteNumber) &&
            const DeepCollectionEquality()
                .equals(other._noteNumberElement, _noteNumberElement) &&
            (identical(other.reviewOutcome, reviewOutcome) ||
                other.reviewOutcome == reviewOutcome) &&
            const DeepCollectionEquality()
                .equals(other._adjudication, _adjudication));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        sequence,
        sequenceElement,
        const DeepCollectionEquality().hash(_traceNumber),
        revenue,
        category,
        productOrService,
        productOrServiceEnd,
        const DeepCollectionEquality().hash(_modifier),
        const DeepCollectionEquality().hash(_programCode),
        patientPaid,
        quantity,
        unitPrice,
        factor,
        factorElement,
        tax,
        net,
        const DeepCollectionEquality().hash(_udi),
        const DeepCollectionEquality().hash(_noteNumber),
        const DeepCollectionEquality().hash(_noteNumberElement),
        reviewOutcome,
        const DeepCollectionEquality().hash(_adjudication)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitSubDetailImplCopyWith<
          _$ExplanationOfBenefitSubDetailImpl>
      get copyWith => __$$ExplanationOfBenefitSubDetailImplCopyWithImpl<
          _$ExplanationOfBenefitSubDetailImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitSubDetailImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitSubDetail
    extends ExplanationOfBenefitSubDetail {
  const factory _ExplanationOfBenefitSubDetail(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final FhirPositiveInt? sequence,
          @JsonKey(name: '_sequence') final Element? sequenceElement,
          final List<Identifier>? traceNumber,
          final CodeableConcept? revenue,
          final CodeableConcept? category,
          final CodeableConcept? productOrService,
          final CodeableConcept? productOrServiceEnd,
          final List<CodeableConcept>? modifier,
          final List<CodeableConcept>? programCode,
          final Money? patientPaid,
          final Quantity? quantity,
          final Money? unitPrice,
          final FhirDecimal? factor,
          @JsonKey(name: '_factor') final Element? factorElement,
          final Money? tax,
          final Money? net,
          final List<Reference>? udi,
          final List<FhirPositiveInt>? noteNumber,
          @JsonKey(name: '_noteNumber') final List<Element>? noteNumberElement,
          final ExplanationOfBenefitReviewOutcome? reviewOutcome,
          final List<ExplanationOfBenefitAdjudication>? adjudication}) =
      _$ExplanationOfBenefitSubDetailImpl;
  const _ExplanationOfBenefitSubDetail._() : super._();

  factory _ExplanationOfBenefitSubDetail.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitSubDetailImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [sequence] A claim detail line. Either a simple (a product or service)
  ///  or a 'group' of sub-details which are simple items.
  FhirPositiveInt? get sequence;
  @override

  /// [sequenceElement] ("_sequence") Extensions for sequence
  @JsonKey(name: '_sequence')
  Element? get sequenceElement;
  @override

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber;
  @override

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  CodeableConcept? get revenue;
  @override

  /// [category] Code to identify the general type of benefits under which
  ///  products and services are provided.
  CodeableConcept? get category;
  @override

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  CodeableConcept? get productOrService;
  @override

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  CodeableConcept? get productOrServiceEnd;
  @override

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  List<CodeableConcept>? get modifier;
  @override

  /// [programCode] Identifies the program under which this may be recovered.
  List<CodeableConcept>? get programCode;
  @override

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid;
  @override

  /// [quantity] The number of repetitions of a service or product.
  Quantity? get quantity;
  @override

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  Money? get unitPrice;
  @override

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  FhirDecimal? get factor;
  @override

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement;
  @override

  /// [tax] The total of taxes applicable for this product or service.
  Money? get tax;
  @override

  /// [net] The total amount claimed for the line item.detail.subDetail. Net
  ///  = unit price * quantity * factor.
  Money? get net;
  @override

  /// [udi] Unique Device Identifiers associated with this line item.
  List<Reference>? get udi;
  @override

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  List<FhirPositiveInt>? get noteNumber;
  @override

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement;
  @override

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  ExplanationOfBenefitReviewOutcome? get reviewOutcome;
  @override

  /// [adjudication] The adjudication results.
  List<ExplanationOfBenefitAdjudication>? get adjudication;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitSubDetailImplCopyWith<
          _$ExplanationOfBenefitSubDetailImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitAddItem _$ExplanationOfBenefitAddItemFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitAddItem.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitAddItem {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [itemSequence] Claim items which this service line is intended to
  ///  replace.
  List<FhirPositiveInt>? get itemSequence => throw _privateConstructorUsedError;

  /// [itemSequenceElement] ("_itemSequence") Extensions for itemSequence
  @JsonKey(name: '_itemSequence')
  List<Element>? get itemSequenceElement => throw _privateConstructorUsedError;

  /// [detailSequence] The sequence number of the details within the claim
  ///  item which this line is intended to replace.
  List<FhirPositiveInt>? get detailSequence =>
      throw _privateConstructorUsedError;

  /// [detailSequenceElement] ("_detailSequence") Extensions for
  ///  detailSequence
  @JsonKey(name: '_detailSequence')
  List<Element>? get detailSequenceElement =>
      throw _privateConstructorUsedError;

  /// [subDetailSequence] The sequence number of the sub-details woithin the
  ///  details within the claim item which this line is intended to replace.
  List<FhirPositiveInt>? get subDetailSequence =>
      throw _privateConstructorUsedError;

  /// [subDetailSequenceElement] ("_subDetailSequence") Extensions for
  ///  subDetailSequence
  @JsonKey(name: '_subDetailSequence')
  List<Element>? get subDetailSequenceElement =>
      throw _privateConstructorUsedError;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber => throw _privateConstructorUsedError;

  /// [provider] The providers who are authorized for the services rendered
  ///  to the patient.
  List<Reference>? get provider => throw _privateConstructorUsedError;

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  CodeableConcept? get revenue => throw _privateConstructorUsedError;

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  CodeableConcept? get productOrService => throw _privateConstructorUsedError;

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  CodeableConcept? get productOrServiceEnd =>
      throw _privateConstructorUsedError;

  /// [request] Request or Referral for Goods or Service to be rendered.
  List<Reference>? get request => throw _privateConstructorUsedError;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  List<CodeableConcept>? get modifier => throw _privateConstructorUsedError;

  /// [programCode] Identifies the program under which this may be recovered.
  List<CodeableConcept>? get programCode => throw _privateConstructorUsedError;

  /// [servicedDate] The date or dates when the service or product was
  ///  supplied, performed or completed.
  FhirDate? get servicedDate => throw _privateConstructorUsedError;

  /// [servicedDateElement] ("_servicedDate") Extensions for servicedDate
  @JsonKey(name: '_servicedDate')
  Element? get servicedDateElement => throw _privateConstructorUsedError;

  /// [servicedPeriod] The date or dates when the service or product was
  ///  supplied, performed or completed.
  Period? get servicedPeriod => throw _privateConstructorUsedError;

  /// [locationCodeableConcept] Where the product or service was provided.
  CodeableConcept? get locationCodeableConcept =>
      throw _privateConstructorUsedError;

  /// [locationAddress] Where the product or service was provided.
  Address? get locationAddress => throw _privateConstructorUsedError;

  /// [locationReference] Where the product or service was provided.
  Reference? get locationReference => throw _privateConstructorUsedError;

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid => throw _privateConstructorUsedError;

  /// [quantity] The number of repetitions of a service or product.
  Quantity? get quantity => throw _privateConstructorUsedError;

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  Money? get unitPrice => throw _privateConstructorUsedError;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  FhirDecimal? get factor => throw _privateConstructorUsedError;

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement => throw _privateConstructorUsedError;

  /// [tax] The total of taxes applicable for this product or service.
  Money? get tax => throw _privateConstructorUsedError;

  /// [net] The total amount claimed for the group (if a grouper) or the
  ///  addItem. Net = unit price * quantity * factor.
  Money? get net => throw _privateConstructorUsedError;

  /// [bodySite] Physical location where the service is performed or applies.
  List<ExplanationOfBenefitBodySite1>? get bodySite =>
      throw _privateConstructorUsedError;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  List<FhirPositiveInt>? get noteNumber => throw _privateConstructorUsedError;

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement => throw _privateConstructorUsedError;

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  ExplanationOfBenefitReviewOutcome? get reviewOutcome =>
      throw _privateConstructorUsedError;

  /// [adjudication] The adjudication results.
  List<ExplanationOfBenefitAdjudication>? get adjudication =>
      throw _privateConstructorUsedError;

  /// [detail] The second-tier service adjudications for payor added services.
  List<ExplanationOfBenefitDetail1>? get detail =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitAddItemCopyWith<ExplanationOfBenefitAddItem>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitAddItemCopyWith<$Res> {
  factory $ExplanationOfBenefitAddItemCopyWith(
          ExplanationOfBenefitAddItem value,
          $Res Function(ExplanationOfBenefitAddItem) then) =
      _$ExplanationOfBenefitAddItemCopyWithImpl<$Res,
          ExplanationOfBenefitAddItem>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<FhirPositiveInt>? itemSequence,
      @JsonKey(name: '_itemSequence') List<Element>? itemSequenceElement,
      List<FhirPositiveInt>? detailSequence,
      @JsonKey(name: '_detailSequence') List<Element>? detailSequenceElement,
      List<FhirPositiveInt>? subDetailSequence,
      @JsonKey(name: '_subDetailSequence')
      List<Element>? subDetailSequenceElement,
      List<Identifier>? traceNumber,
      List<Reference>? provider,
      CodeableConcept? revenue,
      CodeableConcept? productOrService,
      CodeableConcept? productOrServiceEnd,
      List<Reference>? request,
      List<CodeableConcept>? modifier,
      List<CodeableConcept>? programCode,
      FhirDate? servicedDate,
      @JsonKey(name: '_servicedDate') Element? servicedDateElement,
      Period? servicedPeriod,
      CodeableConcept? locationCodeableConcept,
      Address? locationAddress,
      Reference? locationReference,
      Money? patientPaid,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      Money? tax,
      Money? net,
      List<ExplanationOfBenefitBodySite1>? bodySite,
      List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') List<Element>? noteNumberElement,
      ExplanationOfBenefitReviewOutcome? reviewOutcome,
      List<ExplanationOfBenefitAdjudication>? adjudication,
      List<ExplanationOfBenefitDetail1>? detail});

  $CodeableConceptCopyWith<$Res>? get revenue;
  $CodeableConceptCopyWith<$Res>? get productOrService;
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd;
  $ElementCopyWith<$Res>? get servicedDateElement;
  $PeriodCopyWith<$Res>? get servicedPeriod;
  $CodeableConceptCopyWith<$Res>? get locationCodeableConcept;
  $AddressCopyWith<$Res>? get locationAddress;
  $ReferenceCopyWith<$Res>? get locationReference;
  $MoneyCopyWith<$Res>? get patientPaid;
  $QuantityCopyWith<$Res>? get quantity;
  $MoneyCopyWith<$Res>? get unitPrice;
  $ElementCopyWith<$Res>? get factorElement;
  $MoneyCopyWith<$Res>? get tax;
  $MoneyCopyWith<$Res>? get net;
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome;
}

/// @nodoc
class _$ExplanationOfBenefitAddItemCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitAddItem>
    implements $ExplanationOfBenefitAddItemCopyWith<$Res> {
  _$ExplanationOfBenefitAddItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? itemSequence = freezed,
    Object? itemSequenceElement = freezed,
    Object? detailSequence = freezed,
    Object? detailSequenceElement = freezed,
    Object? subDetailSequence = freezed,
    Object? subDetailSequenceElement = freezed,
    Object? traceNumber = freezed,
    Object? provider = freezed,
    Object? revenue = freezed,
    Object? productOrService = freezed,
    Object? productOrServiceEnd = freezed,
    Object? request = freezed,
    Object? modifier = freezed,
    Object? programCode = freezed,
    Object? servicedDate = freezed,
    Object? servicedDateElement = freezed,
    Object? servicedPeriod = freezed,
    Object? locationCodeableConcept = freezed,
    Object? locationAddress = freezed,
    Object? locationReference = freezed,
    Object? patientPaid = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? tax = freezed,
    Object? net = freezed,
    Object? bodySite = freezed,
    Object? noteNumber = freezed,
    Object? noteNumberElement = freezed,
    Object? reviewOutcome = freezed,
    Object? adjudication = freezed,
    Object? detail = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      itemSequence: freezed == itemSequence
          ? _value.itemSequence
          : itemSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      itemSequenceElement: freezed == itemSequenceElement
          ? _value.itemSequenceElement
          : itemSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      detailSequence: freezed == detailSequence
          ? _value.detailSequence
          : detailSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      detailSequenceElement: freezed == detailSequenceElement
          ? _value.detailSequenceElement
          : detailSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      subDetailSequence: freezed == subDetailSequence
          ? _value.subDetailSequence
          : subDetailSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      subDetailSequenceElement: freezed == subDetailSequenceElement
          ? _value.subDetailSequenceElement
          : subDetailSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      traceNumber: freezed == traceNumber
          ? _value.traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      provider: freezed == provider
          ? _value.provider
          : provider // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      revenue: freezed == revenue
          ? _value.revenue
          : revenue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrService: freezed == productOrService
          ? _value.productOrService
          : productOrService // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrServiceEnd: freezed == productOrServiceEnd
          ? _value.productOrServiceEnd
          : productOrServiceEnd // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      request: freezed == request
          ? _value.request
          : request // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      modifier: freezed == modifier
          ? _value.modifier
          : modifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      programCode: freezed == programCode
          ? _value.programCode
          : programCode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      servicedDate: freezed == servicedDate
          ? _value.servicedDate
          : servicedDate // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      servicedDateElement: freezed == servicedDateElement
          ? _value.servicedDateElement
          : servicedDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      servicedPeriod: freezed == servicedPeriod
          ? _value.servicedPeriod
          : servicedPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      locationCodeableConcept: freezed == locationCodeableConcept
          ? _value.locationCodeableConcept
          : locationCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      locationAddress: freezed == locationAddress
          ? _value.locationAddress
          : locationAddress // ignore: cast_nullable_to_non_nullable
              as Address?,
      locationReference: freezed == locationReference
          ? _value.locationReference
          : locationReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      tax: freezed == tax
          ? _value.tax
          : tax // ignore: cast_nullable_to_non_nullable
              as Money?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      bodySite: freezed == bodySite
          ? _value.bodySite
          : bodySite // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitBodySite1>?,
      noteNumber: freezed == noteNumber
          ? _value.noteNumber
          : noteNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      noteNumberElement: freezed == noteNumberElement
          ? _value.noteNumberElement
          : noteNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reviewOutcome: freezed == reviewOutcome
          ? _value.reviewOutcome
          : reviewOutcome // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitReviewOutcome?,
      adjudication: freezed == adjudication
          ? _value.adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
      detail: freezed == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitDetail1>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get revenue {
    if (_value.revenue == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.revenue!, (value) {
      return _then(_value.copyWith(revenue: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get productOrService {
    if (_value.productOrService == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.productOrService!, (value) {
      return _then(_value.copyWith(productOrService: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd {
    if (_value.productOrServiceEnd == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.productOrServiceEnd!, (value) {
      return _then(_value.copyWith(productOrServiceEnd: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get servicedDateElement {
    if (_value.servicedDateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.servicedDateElement!, (value) {
      return _then(_value.copyWith(servicedDateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get servicedPeriod {
    if (_value.servicedPeriod == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.servicedPeriod!, (value) {
      return _then(_value.copyWith(servicedPeriod: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get locationCodeableConcept {
    if (_value.locationCodeableConcept == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.locationCodeableConcept!,
        (value) {
      return _then(_value.copyWith(locationCodeableConcept: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AddressCopyWith<$Res>? get locationAddress {
    if (_value.locationAddress == null) {
      return null;
    }

    return $AddressCopyWith<$Res>(_value.locationAddress!, (value) {
      return _then(_value.copyWith(locationAddress: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get locationReference {
    if (_value.locationReference == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.locationReference!, (value) {
      return _then(_value.copyWith(locationReference: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get patientPaid {
    if (_value.patientPaid == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.patientPaid!, (value) {
      return _then(_value.copyWith(patientPaid: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get quantity {
    if (_value.quantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.quantity!, (value) {
      return _then(_value.copyWith(quantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get unitPrice {
    if (_value.unitPrice == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.unitPrice!, (value) {
      return _then(_value.copyWith(unitPrice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get factorElement {
    if (_value.factorElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.factorElement!, (value) {
      return _then(_value.copyWith(factorElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get tax {
    if (_value.tax == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.tax!, (value) {
      return _then(_value.copyWith(tax: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get net {
    if (_value.net == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.net!, (value) {
      return _then(_value.copyWith(net: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome {
    if (_value.reviewOutcome == null) {
      return null;
    }

    return $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>(
        _value.reviewOutcome!, (value) {
      return _then(_value.copyWith(reviewOutcome: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitAddItemImplCopyWith<$Res>
    implements $ExplanationOfBenefitAddItemCopyWith<$Res> {
  factory _$$ExplanationOfBenefitAddItemImplCopyWith(
          _$ExplanationOfBenefitAddItemImpl value,
          $Res Function(_$ExplanationOfBenefitAddItemImpl) then) =
      __$$ExplanationOfBenefitAddItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<FhirPositiveInt>? itemSequence,
      @JsonKey(name: '_itemSequence') List<Element>? itemSequenceElement,
      List<FhirPositiveInt>? detailSequence,
      @JsonKey(name: '_detailSequence') List<Element>? detailSequenceElement,
      List<FhirPositiveInt>? subDetailSequence,
      @JsonKey(name: '_subDetailSequence')
      List<Element>? subDetailSequenceElement,
      List<Identifier>? traceNumber,
      List<Reference>? provider,
      CodeableConcept? revenue,
      CodeableConcept? productOrService,
      CodeableConcept? productOrServiceEnd,
      List<Reference>? request,
      List<CodeableConcept>? modifier,
      List<CodeableConcept>? programCode,
      FhirDate? servicedDate,
      @JsonKey(name: '_servicedDate') Element? servicedDateElement,
      Period? servicedPeriod,
      CodeableConcept? locationCodeableConcept,
      Address? locationAddress,
      Reference? locationReference,
      Money? patientPaid,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      Money? tax,
      Money? net,
      List<ExplanationOfBenefitBodySite1>? bodySite,
      List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') List<Element>? noteNumberElement,
      ExplanationOfBenefitReviewOutcome? reviewOutcome,
      List<ExplanationOfBenefitAdjudication>? adjudication,
      List<ExplanationOfBenefitDetail1>? detail});

  @override
  $CodeableConceptCopyWith<$Res>? get revenue;
  @override
  $CodeableConceptCopyWith<$Res>? get productOrService;
  @override
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd;
  @override
  $ElementCopyWith<$Res>? get servicedDateElement;
  @override
  $PeriodCopyWith<$Res>? get servicedPeriod;
  @override
  $CodeableConceptCopyWith<$Res>? get locationCodeableConcept;
  @override
  $AddressCopyWith<$Res>? get locationAddress;
  @override
  $ReferenceCopyWith<$Res>? get locationReference;
  @override
  $MoneyCopyWith<$Res>? get patientPaid;
  @override
  $QuantityCopyWith<$Res>? get quantity;
  @override
  $MoneyCopyWith<$Res>? get unitPrice;
  @override
  $ElementCopyWith<$Res>? get factorElement;
  @override
  $MoneyCopyWith<$Res>? get tax;
  @override
  $MoneyCopyWith<$Res>? get net;
  @override
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome;
}

/// @nodoc
class __$$ExplanationOfBenefitAddItemImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitAddItemCopyWithImpl<$Res,
        _$ExplanationOfBenefitAddItemImpl>
    implements _$$ExplanationOfBenefitAddItemImplCopyWith<$Res> {
  __$$ExplanationOfBenefitAddItemImplCopyWithImpl(
      _$ExplanationOfBenefitAddItemImpl _value,
      $Res Function(_$ExplanationOfBenefitAddItemImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? itemSequence = freezed,
    Object? itemSequenceElement = freezed,
    Object? detailSequence = freezed,
    Object? detailSequenceElement = freezed,
    Object? subDetailSequence = freezed,
    Object? subDetailSequenceElement = freezed,
    Object? traceNumber = freezed,
    Object? provider = freezed,
    Object? revenue = freezed,
    Object? productOrService = freezed,
    Object? productOrServiceEnd = freezed,
    Object? request = freezed,
    Object? modifier = freezed,
    Object? programCode = freezed,
    Object? servicedDate = freezed,
    Object? servicedDateElement = freezed,
    Object? servicedPeriod = freezed,
    Object? locationCodeableConcept = freezed,
    Object? locationAddress = freezed,
    Object? locationReference = freezed,
    Object? patientPaid = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? tax = freezed,
    Object? net = freezed,
    Object? bodySite = freezed,
    Object? noteNumber = freezed,
    Object? noteNumberElement = freezed,
    Object? reviewOutcome = freezed,
    Object? adjudication = freezed,
    Object? detail = freezed,
  }) {
    return _then(_$ExplanationOfBenefitAddItemImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      itemSequence: freezed == itemSequence
          ? _value._itemSequence
          : itemSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      itemSequenceElement: freezed == itemSequenceElement
          ? _value._itemSequenceElement
          : itemSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      detailSequence: freezed == detailSequence
          ? _value._detailSequence
          : detailSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      detailSequenceElement: freezed == detailSequenceElement
          ? _value._detailSequenceElement
          : detailSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      subDetailSequence: freezed == subDetailSequence
          ? _value._subDetailSequence
          : subDetailSequence // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      subDetailSequenceElement: freezed == subDetailSequenceElement
          ? _value._subDetailSequenceElement
          : subDetailSequenceElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      traceNumber: freezed == traceNumber
          ? _value._traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      provider: freezed == provider
          ? _value._provider
          : provider // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      revenue: freezed == revenue
          ? _value.revenue
          : revenue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrService: freezed == productOrService
          ? _value.productOrService
          : productOrService // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrServiceEnd: freezed == productOrServiceEnd
          ? _value.productOrServiceEnd
          : productOrServiceEnd // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      request: freezed == request
          ? _value._request
          : request // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      modifier: freezed == modifier
          ? _value._modifier
          : modifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      programCode: freezed == programCode
          ? _value._programCode
          : programCode // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      servicedDate: freezed == servicedDate
          ? _value.servicedDate
          : servicedDate // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      servicedDateElement: freezed == servicedDateElement
          ? _value.servicedDateElement
          : servicedDateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      servicedPeriod: freezed == servicedPeriod
          ? _value.servicedPeriod
          : servicedPeriod // ignore: cast_nullable_to_non_nullable
              as Period?,
      locationCodeableConcept: freezed == locationCodeableConcept
          ? _value.locationCodeableConcept
          : locationCodeableConcept // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      locationAddress: freezed == locationAddress
          ? _value.locationAddress
          : locationAddress // ignore: cast_nullable_to_non_nullable
              as Address?,
      locationReference: freezed == locationReference
          ? _value.locationReference
          : locationReference // ignore: cast_nullable_to_non_nullable
              as Reference?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      tax: freezed == tax
          ? _value.tax
          : tax // ignore: cast_nullable_to_non_nullable
              as Money?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      bodySite: freezed == bodySite
          ? _value._bodySite
          : bodySite // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitBodySite1>?,
      noteNumber: freezed == noteNumber
          ? _value._noteNumber
          : noteNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      noteNumberElement: freezed == noteNumberElement
          ? _value._noteNumberElement
          : noteNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reviewOutcome: freezed == reviewOutcome
          ? _value.reviewOutcome
          : reviewOutcome // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitReviewOutcome?,
      adjudication: freezed == adjudication
          ? _value._adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
      detail: freezed == detail
          ? _value._detail
          : detail // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitDetail1>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitAddItemImpl extends _ExplanationOfBenefitAddItem {
  const _$ExplanationOfBenefitAddItemImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<FhirPositiveInt>? itemSequence,
      @JsonKey(name: '_itemSequence') final List<Element>? itemSequenceElement,
      final List<FhirPositiveInt>? detailSequence,
      @JsonKey(name: '_detailSequence')
      final List<Element>? detailSequenceElement,
      final List<FhirPositiveInt>? subDetailSequence,
      @JsonKey(name: '_subDetailSequence')
      final List<Element>? subDetailSequenceElement,
      final List<Identifier>? traceNumber,
      final List<Reference>? provider,
      this.revenue,
      this.productOrService,
      this.productOrServiceEnd,
      final List<Reference>? request,
      final List<CodeableConcept>? modifier,
      final List<CodeableConcept>? programCode,
      this.servicedDate,
      @JsonKey(name: '_servicedDate') this.servicedDateElement,
      this.servicedPeriod,
      this.locationCodeableConcept,
      this.locationAddress,
      this.locationReference,
      this.patientPaid,
      this.quantity,
      this.unitPrice,
      this.factor,
      @JsonKey(name: '_factor') this.factorElement,
      this.tax,
      this.net,
      final List<ExplanationOfBenefitBodySite1>? bodySite,
      final List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') final List<Element>? noteNumberElement,
      this.reviewOutcome,
      final List<ExplanationOfBenefitAdjudication>? adjudication,
      final List<ExplanationOfBenefitDetail1>? detail})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _itemSequence = itemSequence,
        _itemSequenceElement = itemSequenceElement,
        _detailSequence = detailSequence,
        _detailSequenceElement = detailSequenceElement,
        _subDetailSequence = subDetailSequence,
        _subDetailSequenceElement = subDetailSequenceElement,
        _traceNumber = traceNumber,
        _provider = provider,
        _request = request,
        _modifier = modifier,
        _programCode = programCode,
        _bodySite = bodySite,
        _noteNumber = noteNumber,
        _noteNumberElement = noteNumberElement,
        _adjudication = adjudication,
        _detail = detail,
        super._();

  factory _$ExplanationOfBenefitAddItemImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitAddItemImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [itemSequence] Claim items which this service line is intended to
  ///  replace.
  final List<FhirPositiveInt>? _itemSequence;

  /// [itemSequence] Claim items which this service line is intended to
  ///  replace.
  @override
  List<FhirPositiveInt>? get itemSequence {
    final value = _itemSequence;
    if (value == null) return null;
    if (_itemSequence is EqualUnmodifiableListView) return _itemSequence;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [itemSequenceElement] ("_itemSequence") Extensions for itemSequence
  final List<Element>? _itemSequenceElement;

  /// [itemSequenceElement] ("_itemSequence") Extensions for itemSequence
  @override
  @JsonKey(name: '_itemSequence')
  List<Element>? get itemSequenceElement {
    final value = _itemSequenceElement;
    if (value == null) return null;
    if (_itemSequenceElement is EqualUnmodifiableListView)
      return _itemSequenceElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [detailSequence] The sequence number of the details within the claim
  ///  item which this line is intended to replace.
  final List<FhirPositiveInt>? _detailSequence;

  /// [detailSequence] The sequence number of the details within the claim
  ///  item which this line is intended to replace.
  @override
  List<FhirPositiveInt>? get detailSequence {
    final value = _detailSequence;
    if (value == null) return null;
    if (_detailSequence is EqualUnmodifiableListView) return _detailSequence;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [detailSequenceElement] ("_detailSequence") Extensions for
  ///  detailSequence
  final List<Element>? _detailSequenceElement;

  /// [detailSequenceElement] ("_detailSequence") Extensions for
  ///  detailSequence
  @override
  @JsonKey(name: '_detailSequence')
  List<Element>? get detailSequenceElement {
    final value = _detailSequenceElement;
    if (value == null) return null;
    if (_detailSequenceElement is EqualUnmodifiableListView)
      return _detailSequenceElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [subDetailSequence] The sequence number of the sub-details woithin the
  ///  details within the claim item which this line is intended to replace.
  final List<FhirPositiveInt>? _subDetailSequence;

  /// [subDetailSequence] The sequence number of the sub-details woithin the
  ///  details within the claim item which this line is intended to replace.
  @override
  List<FhirPositiveInt>? get subDetailSequence {
    final value = _subDetailSequence;
    if (value == null) return null;
    if (_subDetailSequence is EqualUnmodifiableListView)
      return _subDetailSequence;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [subDetailSequenceElement] ("_subDetailSequence") Extensions for
  ///  subDetailSequence
  final List<Element>? _subDetailSequenceElement;

  /// [subDetailSequenceElement] ("_subDetailSequence") Extensions for
  ///  subDetailSequence
  @override
  @JsonKey(name: '_subDetailSequence')
  List<Element>? get subDetailSequenceElement {
    final value = _subDetailSequenceElement;
    if (value == null) return null;
    if (_subDetailSequenceElement is EqualUnmodifiableListView)
      return _subDetailSequenceElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  final List<Identifier>? _traceNumber;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  @override
  List<Identifier>? get traceNumber {
    final value = _traceNumber;
    if (value == null) return null;
    if (_traceNumber is EqualUnmodifiableListView) return _traceNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [provider] The providers who are authorized for the services rendered
  ///  to the patient.
  final List<Reference>? _provider;

  /// [provider] The providers who are authorized for the services rendered
  ///  to the patient.
  @override
  List<Reference>? get provider {
    final value = _provider;
    if (value == null) return null;
    if (_provider is EqualUnmodifiableListView) return _provider;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  @override
  final CodeableConcept? revenue;

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  @override
  final CodeableConcept? productOrService;

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  @override
  final CodeableConcept? productOrServiceEnd;

  /// [request] Request or Referral for Goods or Service to be rendered.
  final List<Reference>? _request;

  /// [request] Request or Referral for Goods or Service to be rendered.
  @override
  List<Reference>? get request {
    final value = _request;
    if (value == null) return null;
    if (_request is EqualUnmodifiableListView) return _request;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  final List<CodeableConcept>? _modifier;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  @override
  List<CodeableConcept>? get modifier {
    final value = _modifier;
    if (value == null) return null;
    if (_modifier is EqualUnmodifiableListView) return _modifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [programCode] Identifies the program under which this may be recovered.
  final List<CodeableConcept>? _programCode;

  /// [programCode] Identifies the program under which this may be recovered.
  @override
  List<CodeableConcept>? get programCode {
    final value = _programCode;
    if (value == null) return null;
    if (_programCode is EqualUnmodifiableListView) return _programCode;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [servicedDate] The date or dates when the service or product was
  ///  supplied, performed or completed.
  @override
  final FhirDate? servicedDate;

  /// [servicedDateElement] ("_servicedDate") Extensions for servicedDate
  @override
  @JsonKey(name: '_servicedDate')
  final Element? servicedDateElement;

  /// [servicedPeriod] The date or dates when the service or product was
  ///  supplied, performed or completed.
  @override
  final Period? servicedPeriod;

  /// [locationCodeableConcept] Where the product or service was provided.
  @override
  final CodeableConcept? locationCodeableConcept;

  /// [locationAddress] Where the product or service was provided.
  @override
  final Address? locationAddress;

  /// [locationReference] Where the product or service was provided.
  @override
  final Reference? locationReference;

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  @override
  final Money? patientPaid;

  /// [quantity] The number of repetitions of a service or product.
  @override
  final Quantity? quantity;

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  @override
  final Money? unitPrice;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  @override
  final FhirDecimal? factor;

  /// [factorElement] ("_factor") Extensions for factor
  @override
  @JsonKey(name: '_factor')
  final Element? factorElement;

  /// [tax] The total of taxes applicable for this product or service.
  @override
  final Money? tax;

  /// [net] The total amount claimed for the group (if a grouper) or the
  ///  addItem. Net = unit price * quantity * factor.
  @override
  final Money? net;

  /// [bodySite] Physical location where the service is performed or applies.
  final List<ExplanationOfBenefitBodySite1>? _bodySite;

  /// [bodySite] Physical location where the service is performed or applies.
  @override
  List<ExplanationOfBenefitBodySite1>? get bodySite {
    final value = _bodySite;
    if (value == null) return null;
    if (_bodySite is EqualUnmodifiableListView) return _bodySite;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  final List<FhirPositiveInt>? _noteNumber;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  @override
  List<FhirPositiveInt>? get noteNumber {
    final value = _noteNumber;
    if (value == null) return null;
    if (_noteNumber is EqualUnmodifiableListView) return _noteNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  final List<Element>? _noteNumberElement;

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @override
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement {
    final value = _noteNumberElement;
    if (value == null) return null;
    if (_noteNumberElement is EqualUnmodifiableListView)
      return _noteNumberElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  @override
  final ExplanationOfBenefitReviewOutcome? reviewOutcome;

  /// [adjudication] The adjudication results.
  final List<ExplanationOfBenefitAdjudication>? _adjudication;

  /// [adjudication] The adjudication results.
  @override
  List<ExplanationOfBenefitAdjudication>? get adjudication {
    final value = _adjudication;
    if (value == null) return null;
    if (_adjudication is EqualUnmodifiableListView) return _adjudication;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [detail] The second-tier service adjudications for payor added services.
  final List<ExplanationOfBenefitDetail1>? _detail;

  /// [detail] The second-tier service adjudications for payor added services.
  @override
  List<ExplanationOfBenefitDetail1>? get detail {
    final value = _detail;
    if (value == null) return null;
    if (_detail is EqualUnmodifiableListView) return _detail;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExplanationOfBenefitAddItem(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, itemSequence: $itemSequence, itemSequenceElement: $itemSequenceElement, detailSequence: $detailSequence, detailSequenceElement: $detailSequenceElement, subDetailSequence: $subDetailSequence, subDetailSequenceElement: $subDetailSequenceElement, traceNumber: $traceNumber, provider: $provider, revenue: $revenue, productOrService: $productOrService, productOrServiceEnd: $productOrServiceEnd, request: $request, modifier: $modifier, programCode: $programCode, servicedDate: $servicedDate, servicedDateElement: $servicedDateElement, servicedPeriod: $servicedPeriod, locationCodeableConcept: $locationCodeableConcept, locationAddress: $locationAddress, locationReference: $locationReference, patientPaid: $patientPaid, quantity: $quantity, unitPrice: $unitPrice, factor: $factor, factorElement: $factorElement, tax: $tax, net: $net, bodySite: $bodySite, noteNumber: $noteNumber, noteNumberElement: $noteNumberElement, reviewOutcome: $reviewOutcome, adjudication: $adjudication, detail: $detail)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitAddItemImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._itemSequence, _itemSequence) &&
            const DeepCollectionEquality()
                .equals(other._itemSequenceElement, _itemSequenceElement) &&
            const DeepCollectionEquality()
                .equals(other._detailSequence, _detailSequence) &&
            const DeepCollectionEquality()
                .equals(other._detailSequenceElement, _detailSequenceElement) &&
            const DeepCollectionEquality()
                .equals(other._subDetailSequence, _subDetailSequence) &&
            const DeepCollectionEquality().equals(
                other._subDetailSequenceElement, _subDetailSequenceElement) &&
            const DeepCollectionEquality()
                .equals(other._traceNumber, _traceNumber) &&
            const DeepCollectionEquality().equals(other._provider, _provider) &&
            (identical(other.revenue, revenue) || other.revenue == revenue) &&
            (identical(other.productOrService, productOrService) ||
                other.productOrService == productOrService) &&
            (identical(other.productOrServiceEnd, productOrServiceEnd) ||
                other.productOrServiceEnd == productOrServiceEnd) &&
            const DeepCollectionEquality().equals(other._request, _request) &&
            const DeepCollectionEquality().equals(other._modifier, _modifier) &&
            const DeepCollectionEquality()
                .equals(other._programCode, _programCode) &&
            (identical(other.servicedDate, servicedDate) ||
                other.servicedDate == servicedDate) &&
            (identical(other.servicedDateElement, servicedDateElement) ||
                other.servicedDateElement == servicedDateElement) &&
            (identical(other.servicedPeriod, servicedPeriod) ||
                other.servicedPeriod == servicedPeriod) &&
            (identical(
                    other.locationCodeableConcept, locationCodeableConcept) ||
                other.locationCodeableConcept == locationCodeableConcept) &&
            (identical(other.locationAddress, locationAddress) ||
                other.locationAddress == locationAddress) &&
            (identical(other.locationReference, locationReference) ||
                other.locationReference == locationReference) &&
            (identical(other.patientPaid, patientPaid) ||
                other.patientPaid == patientPaid) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.unitPrice, unitPrice) ||
                other.unitPrice == unitPrice) &&
            (identical(other.factor, factor) || other.factor == factor) &&
            (identical(other.factorElement, factorElement) ||
                other.factorElement == factorElement) &&
            (identical(other.tax, tax) || other.tax == tax) &&
            (identical(other.net, net) || other.net == net) &&
            const DeepCollectionEquality().equals(other._bodySite, _bodySite) &&
            const DeepCollectionEquality()
                .equals(other._noteNumber, _noteNumber) &&
            const DeepCollectionEquality()
                .equals(other._noteNumberElement, _noteNumberElement) &&
            (identical(other.reviewOutcome, reviewOutcome) ||
                other.reviewOutcome == reviewOutcome) &&
            const DeepCollectionEquality()
                .equals(other._adjudication, _adjudication) &&
            const DeepCollectionEquality().equals(other._detail, _detail));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_itemSequence),
        const DeepCollectionEquality().hash(_itemSequenceElement),
        const DeepCollectionEquality().hash(_detailSequence),
        const DeepCollectionEquality().hash(_detailSequenceElement),
        const DeepCollectionEquality().hash(_subDetailSequence),
        const DeepCollectionEquality().hash(_subDetailSequenceElement),
        const DeepCollectionEquality().hash(_traceNumber),
        const DeepCollectionEquality().hash(_provider),
        revenue,
        productOrService,
        productOrServiceEnd,
        const DeepCollectionEquality().hash(_request),
        const DeepCollectionEquality().hash(_modifier),
        const DeepCollectionEquality().hash(_programCode),
        servicedDate,
        servicedDateElement,
        servicedPeriod,
        locationCodeableConcept,
        locationAddress,
        locationReference,
        patientPaid,
        quantity,
        unitPrice,
        factor,
        factorElement,
        tax,
        net,
        const DeepCollectionEquality().hash(_bodySite),
        const DeepCollectionEquality().hash(_noteNumber),
        const DeepCollectionEquality().hash(_noteNumberElement),
        reviewOutcome,
        const DeepCollectionEquality().hash(_adjudication),
        const DeepCollectionEquality().hash(_detail)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitAddItemImplCopyWith<_$ExplanationOfBenefitAddItemImpl>
      get copyWith => __$$ExplanationOfBenefitAddItemImplCopyWithImpl<
          _$ExplanationOfBenefitAddItemImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitAddItemImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitAddItem
    extends ExplanationOfBenefitAddItem {
  const factory _ExplanationOfBenefitAddItem(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<FhirPositiveInt>? itemSequence,
      @JsonKey(name: '_itemSequence') final List<Element>? itemSequenceElement,
      final List<FhirPositiveInt>? detailSequence,
      @JsonKey(name: '_detailSequence')
      final List<Element>? detailSequenceElement,
      final List<FhirPositiveInt>? subDetailSequence,
      @JsonKey(name: '_subDetailSequence')
      final List<Element>? subDetailSequenceElement,
      final List<Identifier>? traceNumber,
      final List<Reference>? provider,
      final CodeableConcept? revenue,
      final CodeableConcept? productOrService,
      final CodeableConcept? productOrServiceEnd,
      final List<Reference>? request,
      final List<CodeableConcept>? modifier,
      final List<CodeableConcept>? programCode,
      final FhirDate? servicedDate,
      @JsonKey(name: '_servicedDate') final Element? servicedDateElement,
      final Period? servicedPeriod,
      final CodeableConcept? locationCodeableConcept,
      final Address? locationAddress,
      final Reference? locationReference,
      final Money? patientPaid,
      final Quantity? quantity,
      final Money? unitPrice,
      final FhirDecimal? factor,
      @JsonKey(name: '_factor') final Element? factorElement,
      final Money? tax,
      final Money? net,
      final List<ExplanationOfBenefitBodySite1>? bodySite,
      final List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') final List<Element>? noteNumberElement,
      final ExplanationOfBenefitReviewOutcome? reviewOutcome,
      final List<ExplanationOfBenefitAdjudication>? adjudication,
      final List<ExplanationOfBenefitDetail1>?
          detail}) = _$ExplanationOfBenefitAddItemImpl;
  const _ExplanationOfBenefitAddItem._() : super._();

  factory _ExplanationOfBenefitAddItem.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitAddItemImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [itemSequence] Claim items which this service line is intended to
  ///  replace.
  List<FhirPositiveInt>? get itemSequence;
  @override

  /// [itemSequenceElement] ("_itemSequence") Extensions for itemSequence
  @JsonKey(name: '_itemSequence')
  List<Element>? get itemSequenceElement;
  @override

  /// [detailSequence] The sequence number of the details within the claim
  ///  item which this line is intended to replace.
  List<FhirPositiveInt>? get detailSequence;
  @override

  /// [detailSequenceElement] ("_detailSequence") Extensions for
  ///  detailSequence
  @JsonKey(name: '_detailSequence')
  List<Element>? get detailSequenceElement;
  @override

  /// [subDetailSequence] The sequence number of the sub-details woithin the
  ///  details within the claim item which this line is intended to replace.
  List<FhirPositiveInt>? get subDetailSequence;
  @override

  /// [subDetailSequenceElement] ("_subDetailSequence") Extensions for
  ///  subDetailSequence
  @JsonKey(name: '_subDetailSequence')
  List<Element>? get subDetailSequenceElement;
  @override

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber;
  @override

  /// [provider] The providers who are authorized for the services rendered
  ///  to the patient.
  List<Reference>? get provider;
  @override

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  CodeableConcept? get revenue;
  @override

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  CodeableConcept? get productOrService;
  @override

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  CodeableConcept? get productOrServiceEnd;
  @override

  /// [request] Request or Referral for Goods or Service to be rendered.
  List<Reference>? get request;
  @override

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  List<CodeableConcept>? get modifier;
  @override

  /// [programCode] Identifies the program under which this may be recovered.
  List<CodeableConcept>? get programCode;
  @override

  /// [servicedDate] The date or dates when the service or product was
  ///  supplied, performed or completed.
  FhirDate? get servicedDate;
  @override

  /// [servicedDateElement] ("_servicedDate") Extensions for servicedDate
  @JsonKey(name: '_servicedDate')
  Element? get servicedDateElement;
  @override

  /// [servicedPeriod] The date or dates when the service or product was
  ///  supplied, performed or completed.
  Period? get servicedPeriod;
  @override

  /// [locationCodeableConcept] Where the product or service was provided.
  CodeableConcept? get locationCodeableConcept;
  @override

  /// [locationAddress] Where the product or service was provided.
  Address? get locationAddress;
  @override

  /// [locationReference] Where the product or service was provided.
  Reference? get locationReference;
  @override

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid;
  @override

  /// [quantity] The number of repetitions of a service or product.
  Quantity? get quantity;
  @override

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  Money? get unitPrice;
  @override

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  FhirDecimal? get factor;
  @override

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement;
  @override

  /// [tax] The total of taxes applicable for this product or service.
  Money? get tax;
  @override

  /// [net] The total amount claimed for the group (if a grouper) or the
  ///  addItem. Net = unit price * quantity * factor.
  Money? get net;
  @override

  /// [bodySite] Physical location where the service is performed or applies.
  List<ExplanationOfBenefitBodySite1>? get bodySite;
  @override

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  List<FhirPositiveInt>? get noteNumber;
  @override

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement;
  @override

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  ExplanationOfBenefitReviewOutcome? get reviewOutcome;
  @override

  /// [adjudication] The adjudication results.
  List<ExplanationOfBenefitAdjudication>? get adjudication;
  @override

  /// [detail] The second-tier service adjudications for payor added services.
  List<ExplanationOfBenefitDetail1>? get detail;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitAddItemImplCopyWith<_$ExplanationOfBenefitAddItemImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitBodySite1 _$ExplanationOfBenefitBodySite1FromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitBodySite1.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitBodySite1 {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [site] Physical service site on the patient (limb, tooth, etc.).
  List<CodeableReference> get site => throw _privateConstructorUsedError;

  /// [subSite] A region or surface of the bodySite, e.g. limb region or
  ///  tooth surface(s).
  List<CodeableConcept>? get subSite => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitBodySite1CopyWith<ExplanationOfBenefitBodySite1>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitBodySite1CopyWith<$Res> {
  factory $ExplanationOfBenefitBodySite1CopyWith(
          ExplanationOfBenefitBodySite1 value,
          $Res Function(ExplanationOfBenefitBodySite1) then) =
      _$ExplanationOfBenefitBodySite1CopyWithImpl<$Res,
          ExplanationOfBenefitBodySite1>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<CodeableReference> site,
      List<CodeableConcept>? subSite});
}

/// @nodoc
class _$ExplanationOfBenefitBodySite1CopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitBodySite1>
    implements $ExplanationOfBenefitBodySite1CopyWith<$Res> {
  _$ExplanationOfBenefitBodySite1CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? site = null,
    Object? subSite = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      site: null == site
          ? _value.site
          : site // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>,
      subSite: freezed == subSite
          ? _value.subSite
          : subSite // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitBodySite1ImplCopyWith<$Res>
    implements $ExplanationOfBenefitBodySite1CopyWith<$Res> {
  factory _$$ExplanationOfBenefitBodySite1ImplCopyWith(
          _$ExplanationOfBenefitBodySite1Impl value,
          $Res Function(_$ExplanationOfBenefitBodySite1Impl) then) =
      __$$ExplanationOfBenefitBodySite1ImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<CodeableReference> site,
      List<CodeableConcept>? subSite});
}

/// @nodoc
class __$$ExplanationOfBenefitBodySite1ImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitBodySite1CopyWithImpl<$Res,
        _$ExplanationOfBenefitBodySite1Impl>
    implements _$$ExplanationOfBenefitBodySite1ImplCopyWith<$Res> {
  __$$ExplanationOfBenefitBodySite1ImplCopyWithImpl(
      _$ExplanationOfBenefitBodySite1Impl _value,
      $Res Function(_$ExplanationOfBenefitBodySite1Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? site = null,
    Object? subSite = freezed,
  }) {
    return _then(_$ExplanationOfBenefitBodySite1Impl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      site: null == site
          ? _value._site
          : site // ignore: cast_nullable_to_non_nullable
              as List<CodeableReference>,
      subSite: freezed == subSite
          ? _value._subSite
          : subSite // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitBodySite1Impl
    extends _ExplanationOfBenefitBodySite1 {
  const _$ExplanationOfBenefitBodySite1Impl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final List<CodeableReference> site,
      final List<CodeableConcept>? subSite})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _site = site,
        _subSite = subSite,
        super._();

  factory _$ExplanationOfBenefitBodySite1Impl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitBodySite1ImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [site] Physical service site on the patient (limb, tooth, etc.).
  final List<CodeableReference> _site;

  /// [site] Physical service site on the patient (limb, tooth, etc.).
  @override
  List<CodeableReference> get site {
    if (_site is EqualUnmodifiableListView) return _site;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_site);
  }

  /// [subSite] A region or surface of the bodySite, e.g. limb region or
  ///  tooth surface(s).
  final List<CodeableConcept>? _subSite;

  /// [subSite] A region or surface of the bodySite, e.g. limb region or
  ///  tooth surface(s).
  @override
  List<CodeableConcept>? get subSite {
    final value = _subSite;
    if (value == null) return null;
    if (_subSite is EqualUnmodifiableListView) return _subSite;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExplanationOfBenefitBodySite1(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, site: $site, subSite: $subSite)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitBodySite1Impl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality().equals(other._site, _site) &&
            const DeepCollectionEquality().equals(other._subSite, _subSite));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_site),
      const DeepCollectionEquality().hash(_subSite));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitBodySite1ImplCopyWith<
          _$ExplanationOfBenefitBodySite1Impl>
      get copyWith => __$$ExplanationOfBenefitBodySite1ImplCopyWithImpl<
          _$ExplanationOfBenefitBodySite1Impl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitBodySite1ImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitBodySite1
    extends ExplanationOfBenefitBodySite1 {
  const factory _ExplanationOfBenefitBodySite1(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final List<CodeableReference> site,
          final List<CodeableConcept>? subSite}) =
      _$ExplanationOfBenefitBodySite1Impl;
  const _ExplanationOfBenefitBodySite1._() : super._();

  factory _ExplanationOfBenefitBodySite1.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitBodySite1Impl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [site] Physical service site on the patient (limb, tooth, etc.).
  List<CodeableReference> get site;
  @override

  /// [subSite] A region or surface of the bodySite, e.g. limb region or
  ///  tooth surface(s).
  List<CodeableConcept>? get subSite;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitBodySite1ImplCopyWith<
          _$ExplanationOfBenefitBodySite1Impl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitDetail1 _$ExplanationOfBenefitDetail1FromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitDetail1.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitDetail1 {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber => throw _privateConstructorUsedError;

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  CodeableConcept? get revenue => throw _privateConstructorUsedError;

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  CodeableConcept? get productOrService => throw _privateConstructorUsedError;

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  CodeableConcept? get productOrServiceEnd =>
      throw _privateConstructorUsedError;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  List<CodeableConcept>? get modifier => throw _privateConstructorUsedError;

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid => throw _privateConstructorUsedError;

  /// [quantity] The number of repetitions of a service or product.
  Quantity? get quantity => throw _privateConstructorUsedError;

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  Money? get unitPrice => throw _privateConstructorUsedError;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  FhirDecimal? get factor => throw _privateConstructorUsedError;

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement => throw _privateConstructorUsedError;

  /// [tax] The total of taxes applicable for this product or service.
  Money? get tax => throw _privateConstructorUsedError;

  /// [net] The total amount claimed for the group (if a grouper) or the
  ///  addItem.detail. Net = unit price * quantity * factor.
  Money? get net => throw _privateConstructorUsedError;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  List<FhirPositiveInt>? get noteNumber => throw _privateConstructorUsedError;

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement => throw _privateConstructorUsedError;

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  ExplanationOfBenefitReviewOutcome? get reviewOutcome =>
      throw _privateConstructorUsedError;

  /// [adjudication] The adjudication results.
  List<ExplanationOfBenefitAdjudication>? get adjudication =>
      throw _privateConstructorUsedError;

  /// [subDetail] The third-tier service adjudications for payor added
  ///  services.
  List<ExplanationOfBenefitSubDetail1>? get subDetail =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitDetail1CopyWith<ExplanationOfBenefitDetail1>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitDetail1CopyWith<$Res> {
  factory $ExplanationOfBenefitDetail1CopyWith(
          ExplanationOfBenefitDetail1 value,
          $Res Function(ExplanationOfBenefitDetail1) then) =
      _$ExplanationOfBenefitDetail1CopyWithImpl<$Res,
          ExplanationOfBenefitDetail1>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? traceNumber,
      CodeableConcept? revenue,
      CodeableConcept? productOrService,
      CodeableConcept? productOrServiceEnd,
      List<CodeableConcept>? modifier,
      Money? patientPaid,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      Money? tax,
      Money? net,
      List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') List<Element>? noteNumberElement,
      ExplanationOfBenefitReviewOutcome? reviewOutcome,
      List<ExplanationOfBenefitAdjudication>? adjudication,
      List<ExplanationOfBenefitSubDetail1>? subDetail});

  $CodeableConceptCopyWith<$Res>? get revenue;
  $CodeableConceptCopyWith<$Res>? get productOrService;
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd;
  $MoneyCopyWith<$Res>? get patientPaid;
  $QuantityCopyWith<$Res>? get quantity;
  $MoneyCopyWith<$Res>? get unitPrice;
  $ElementCopyWith<$Res>? get factorElement;
  $MoneyCopyWith<$Res>? get tax;
  $MoneyCopyWith<$Res>? get net;
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome;
}

/// @nodoc
class _$ExplanationOfBenefitDetail1CopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitDetail1>
    implements $ExplanationOfBenefitDetail1CopyWith<$Res> {
  _$ExplanationOfBenefitDetail1CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? traceNumber = freezed,
    Object? revenue = freezed,
    Object? productOrService = freezed,
    Object? productOrServiceEnd = freezed,
    Object? modifier = freezed,
    Object? patientPaid = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? tax = freezed,
    Object? net = freezed,
    Object? noteNumber = freezed,
    Object? noteNumberElement = freezed,
    Object? reviewOutcome = freezed,
    Object? adjudication = freezed,
    Object? subDetail = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      traceNumber: freezed == traceNumber
          ? _value.traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      revenue: freezed == revenue
          ? _value.revenue
          : revenue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrService: freezed == productOrService
          ? _value.productOrService
          : productOrService // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrServiceEnd: freezed == productOrServiceEnd
          ? _value.productOrServiceEnd
          : productOrServiceEnd // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      modifier: freezed == modifier
          ? _value.modifier
          : modifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      tax: freezed == tax
          ? _value.tax
          : tax // ignore: cast_nullable_to_non_nullable
              as Money?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      noteNumber: freezed == noteNumber
          ? _value.noteNumber
          : noteNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      noteNumberElement: freezed == noteNumberElement
          ? _value.noteNumberElement
          : noteNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reviewOutcome: freezed == reviewOutcome
          ? _value.reviewOutcome
          : reviewOutcome // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitReviewOutcome?,
      adjudication: freezed == adjudication
          ? _value.adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
      subDetail: freezed == subDetail
          ? _value.subDetail
          : subDetail // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitSubDetail1>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get revenue {
    if (_value.revenue == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.revenue!, (value) {
      return _then(_value.copyWith(revenue: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get productOrService {
    if (_value.productOrService == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.productOrService!, (value) {
      return _then(_value.copyWith(productOrService: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd {
    if (_value.productOrServiceEnd == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.productOrServiceEnd!, (value) {
      return _then(_value.copyWith(productOrServiceEnd: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get patientPaid {
    if (_value.patientPaid == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.patientPaid!, (value) {
      return _then(_value.copyWith(patientPaid: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get quantity {
    if (_value.quantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.quantity!, (value) {
      return _then(_value.copyWith(quantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get unitPrice {
    if (_value.unitPrice == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.unitPrice!, (value) {
      return _then(_value.copyWith(unitPrice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get factorElement {
    if (_value.factorElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.factorElement!, (value) {
      return _then(_value.copyWith(factorElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get tax {
    if (_value.tax == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.tax!, (value) {
      return _then(_value.copyWith(tax: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get net {
    if (_value.net == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.net!, (value) {
      return _then(_value.copyWith(net: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome {
    if (_value.reviewOutcome == null) {
      return null;
    }

    return $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>(
        _value.reviewOutcome!, (value) {
      return _then(_value.copyWith(reviewOutcome: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitDetail1ImplCopyWith<$Res>
    implements $ExplanationOfBenefitDetail1CopyWith<$Res> {
  factory _$$ExplanationOfBenefitDetail1ImplCopyWith(
          _$ExplanationOfBenefitDetail1Impl value,
          $Res Function(_$ExplanationOfBenefitDetail1Impl) then) =
      __$$ExplanationOfBenefitDetail1ImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? traceNumber,
      CodeableConcept? revenue,
      CodeableConcept? productOrService,
      CodeableConcept? productOrServiceEnd,
      List<CodeableConcept>? modifier,
      Money? patientPaid,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      Money? tax,
      Money? net,
      List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') List<Element>? noteNumberElement,
      ExplanationOfBenefitReviewOutcome? reviewOutcome,
      List<ExplanationOfBenefitAdjudication>? adjudication,
      List<ExplanationOfBenefitSubDetail1>? subDetail});

  @override
  $CodeableConceptCopyWith<$Res>? get revenue;
  @override
  $CodeableConceptCopyWith<$Res>? get productOrService;
  @override
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd;
  @override
  $MoneyCopyWith<$Res>? get patientPaid;
  @override
  $QuantityCopyWith<$Res>? get quantity;
  @override
  $MoneyCopyWith<$Res>? get unitPrice;
  @override
  $ElementCopyWith<$Res>? get factorElement;
  @override
  $MoneyCopyWith<$Res>? get tax;
  @override
  $MoneyCopyWith<$Res>? get net;
  @override
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome;
}

/// @nodoc
class __$$ExplanationOfBenefitDetail1ImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitDetail1CopyWithImpl<$Res,
        _$ExplanationOfBenefitDetail1Impl>
    implements _$$ExplanationOfBenefitDetail1ImplCopyWith<$Res> {
  __$$ExplanationOfBenefitDetail1ImplCopyWithImpl(
      _$ExplanationOfBenefitDetail1Impl _value,
      $Res Function(_$ExplanationOfBenefitDetail1Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? traceNumber = freezed,
    Object? revenue = freezed,
    Object? productOrService = freezed,
    Object? productOrServiceEnd = freezed,
    Object? modifier = freezed,
    Object? patientPaid = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? tax = freezed,
    Object? net = freezed,
    Object? noteNumber = freezed,
    Object? noteNumberElement = freezed,
    Object? reviewOutcome = freezed,
    Object? adjudication = freezed,
    Object? subDetail = freezed,
  }) {
    return _then(_$ExplanationOfBenefitDetail1Impl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      traceNumber: freezed == traceNumber
          ? _value._traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      revenue: freezed == revenue
          ? _value.revenue
          : revenue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrService: freezed == productOrService
          ? _value.productOrService
          : productOrService // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrServiceEnd: freezed == productOrServiceEnd
          ? _value.productOrServiceEnd
          : productOrServiceEnd // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      modifier: freezed == modifier
          ? _value._modifier
          : modifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      tax: freezed == tax
          ? _value.tax
          : tax // ignore: cast_nullable_to_non_nullable
              as Money?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      noteNumber: freezed == noteNumber
          ? _value._noteNumber
          : noteNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      noteNumberElement: freezed == noteNumberElement
          ? _value._noteNumberElement
          : noteNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reviewOutcome: freezed == reviewOutcome
          ? _value.reviewOutcome
          : reviewOutcome // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitReviewOutcome?,
      adjudication: freezed == adjudication
          ? _value._adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
      subDetail: freezed == subDetail
          ? _value._subDetail
          : subDetail // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitSubDetail1>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitDetail1Impl extends _ExplanationOfBenefitDetail1 {
  const _$ExplanationOfBenefitDetail1Impl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? traceNumber,
      this.revenue,
      this.productOrService,
      this.productOrServiceEnd,
      final List<CodeableConcept>? modifier,
      this.patientPaid,
      this.quantity,
      this.unitPrice,
      this.factor,
      @JsonKey(name: '_factor') this.factorElement,
      this.tax,
      this.net,
      final List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') final List<Element>? noteNumberElement,
      this.reviewOutcome,
      final List<ExplanationOfBenefitAdjudication>? adjudication,
      final List<ExplanationOfBenefitSubDetail1>? subDetail})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _traceNumber = traceNumber,
        _modifier = modifier,
        _noteNumber = noteNumber,
        _noteNumberElement = noteNumberElement,
        _adjudication = adjudication,
        _subDetail = subDetail,
        super._();

  factory _$ExplanationOfBenefitDetail1Impl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitDetail1ImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  final List<Identifier>? _traceNumber;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  @override
  List<Identifier>? get traceNumber {
    final value = _traceNumber;
    if (value == null) return null;
    if (_traceNumber is EqualUnmodifiableListView) return _traceNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  @override
  final CodeableConcept? revenue;

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  @override
  final CodeableConcept? productOrService;

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  @override
  final CodeableConcept? productOrServiceEnd;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  final List<CodeableConcept>? _modifier;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  @override
  List<CodeableConcept>? get modifier {
    final value = _modifier;
    if (value == null) return null;
    if (_modifier is EqualUnmodifiableListView) return _modifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  @override
  final Money? patientPaid;

  /// [quantity] The number of repetitions of a service or product.
  @override
  final Quantity? quantity;

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  @override
  final Money? unitPrice;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  @override
  final FhirDecimal? factor;

  /// [factorElement] ("_factor") Extensions for factor
  @override
  @JsonKey(name: '_factor')
  final Element? factorElement;

  /// [tax] The total of taxes applicable for this product or service.
  @override
  final Money? tax;

  /// [net] The total amount claimed for the group (if a grouper) or the
  ///  addItem.detail. Net = unit price * quantity * factor.
  @override
  final Money? net;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  final List<FhirPositiveInt>? _noteNumber;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  @override
  List<FhirPositiveInt>? get noteNumber {
    final value = _noteNumber;
    if (value == null) return null;
    if (_noteNumber is EqualUnmodifiableListView) return _noteNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  final List<Element>? _noteNumberElement;

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @override
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement {
    final value = _noteNumberElement;
    if (value == null) return null;
    if (_noteNumberElement is EqualUnmodifiableListView)
      return _noteNumberElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  @override
  final ExplanationOfBenefitReviewOutcome? reviewOutcome;

  /// [adjudication] The adjudication results.
  final List<ExplanationOfBenefitAdjudication>? _adjudication;

  /// [adjudication] The adjudication results.
  @override
  List<ExplanationOfBenefitAdjudication>? get adjudication {
    final value = _adjudication;
    if (value == null) return null;
    if (_adjudication is EqualUnmodifiableListView) return _adjudication;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [subDetail] The third-tier service adjudications for payor added
  ///  services.
  final List<ExplanationOfBenefitSubDetail1>? _subDetail;

  /// [subDetail] The third-tier service adjudications for payor added
  ///  services.
  @override
  List<ExplanationOfBenefitSubDetail1>? get subDetail {
    final value = _subDetail;
    if (value == null) return null;
    if (_subDetail is EqualUnmodifiableListView) return _subDetail;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExplanationOfBenefitDetail1(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, traceNumber: $traceNumber, revenue: $revenue, productOrService: $productOrService, productOrServiceEnd: $productOrServiceEnd, modifier: $modifier, patientPaid: $patientPaid, quantity: $quantity, unitPrice: $unitPrice, factor: $factor, factorElement: $factorElement, tax: $tax, net: $net, noteNumber: $noteNumber, noteNumberElement: $noteNumberElement, reviewOutcome: $reviewOutcome, adjudication: $adjudication, subDetail: $subDetail)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitDetail1Impl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._traceNumber, _traceNumber) &&
            (identical(other.revenue, revenue) || other.revenue == revenue) &&
            (identical(other.productOrService, productOrService) ||
                other.productOrService == productOrService) &&
            (identical(other.productOrServiceEnd, productOrServiceEnd) ||
                other.productOrServiceEnd == productOrServiceEnd) &&
            const DeepCollectionEquality().equals(other._modifier, _modifier) &&
            (identical(other.patientPaid, patientPaid) ||
                other.patientPaid == patientPaid) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.unitPrice, unitPrice) ||
                other.unitPrice == unitPrice) &&
            (identical(other.factor, factor) || other.factor == factor) &&
            (identical(other.factorElement, factorElement) ||
                other.factorElement == factorElement) &&
            (identical(other.tax, tax) || other.tax == tax) &&
            (identical(other.net, net) || other.net == net) &&
            const DeepCollectionEquality()
                .equals(other._noteNumber, _noteNumber) &&
            const DeepCollectionEquality()
                .equals(other._noteNumberElement, _noteNumberElement) &&
            (identical(other.reviewOutcome, reviewOutcome) ||
                other.reviewOutcome == reviewOutcome) &&
            const DeepCollectionEquality()
                .equals(other._adjudication, _adjudication) &&
            const DeepCollectionEquality()
                .equals(other._subDetail, _subDetail));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_traceNumber),
        revenue,
        productOrService,
        productOrServiceEnd,
        const DeepCollectionEquality().hash(_modifier),
        patientPaid,
        quantity,
        unitPrice,
        factor,
        factorElement,
        tax,
        net,
        const DeepCollectionEquality().hash(_noteNumber),
        const DeepCollectionEquality().hash(_noteNumberElement),
        reviewOutcome,
        const DeepCollectionEquality().hash(_adjudication),
        const DeepCollectionEquality().hash(_subDetail)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitDetail1ImplCopyWith<_$ExplanationOfBenefitDetail1Impl>
      get copyWith => __$$ExplanationOfBenefitDetail1ImplCopyWithImpl<
          _$ExplanationOfBenefitDetail1Impl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitDetail1ImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitDetail1
    extends ExplanationOfBenefitDetail1 {
  const factory _ExplanationOfBenefitDetail1(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Identifier>? traceNumber,
          final CodeableConcept? revenue,
          final CodeableConcept? productOrService,
          final CodeableConcept? productOrServiceEnd,
          final List<CodeableConcept>? modifier,
          final Money? patientPaid,
          final Quantity? quantity,
          final Money? unitPrice,
          final FhirDecimal? factor,
          @JsonKey(name: '_factor') final Element? factorElement,
          final Money? tax,
          final Money? net,
          final List<FhirPositiveInt>? noteNumber,
          @JsonKey(name: '_noteNumber') final List<Element>? noteNumberElement,
          final ExplanationOfBenefitReviewOutcome? reviewOutcome,
          final List<ExplanationOfBenefitAdjudication>? adjudication,
          final List<ExplanationOfBenefitSubDetail1>? subDetail}) =
      _$ExplanationOfBenefitDetail1Impl;
  const _ExplanationOfBenefitDetail1._() : super._();

  factory _ExplanationOfBenefitDetail1.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitDetail1Impl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber;
  @override

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  CodeableConcept? get revenue;
  @override

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  CodeableConcept? get productOrService;
  @override

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  CodeableConcept? get productOrServiceEnd;
  @override

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  List<CodeableConcept>? get modifier;
  @override

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid;
  @override

  /// [quantity] The number of repetitions of a service or product.
  Quantity? get quantity;
  @override

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  Money? get unitPrice;
  @override

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  FhirDecimal? get factor;
  @override

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement;
  @override

  /// [tax] The total of taxes applicable for this product or service.
  Money? get tax;
  @override

  /// [net] The total amount claimed for the group (if a grouper) or the
  ///  addItem.detail. Net = unit price * quantity * factor.
  Money? get net;
  @override

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  List<FhirPositiveInt>? get noteNumber;
  @override

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement;
  @override

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  ExplanationOfBenefitReviewOutcome? get reviewOutcome;
  @override

  /// [adjudication] The adjudication results.
  List<ExplanationOfBenefitAdjudication>? get adjudication;
  @override

  /// [subDetail] The third-tier service adjudications for payor added
  ///  services.
  List<ExplanationOfBenefitSubDetail1>? get subDetail;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitDetail1ImplCopyWith<_$ExplanationOfBenefitDetail1Impl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitSubDetail1 _$ExplanationOfBenefitSubDetail1FromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitSubDetail1.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitSubDetail1 {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber => throw _privateConstructorUsedError;

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  CodeableConcept? get revenue => throw _privateConstructorUsedError;

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  CodeableConcept? get productOrService => throw _privateConstructorUsedError;

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  CodeableConcept? get productOrServiceEnd =>
      throw _privateConstructorUsedError;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  List<CodeableConcept>? get modifier => throw _privateConstructorUsedError;

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid => throw _privateConstructorUsedError;

  /// [quantity] The number of repetitions of a service or product.
  Quantity? get quantity => throw _privateConstructorUsedError;

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  Money? get unitPrice => throw _privateConstructorUsedError;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  FhirDecimal? get factor => throw _privateConstructorUsedError;

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement => throw _privateConstructorUsedError;

  /// [tax] The total of taxes applicable for this product or service.
  Money? get tax => throw _privateConstructorUsedError;

  /// [net] The total amount claimed for the addItem.detail.subDetail. Net =
  ///  unit price * quantity * factor.
  Money? get net => throw _privateConstructorUsedError;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  List<FhirPositiveInt>? get noteNumber => throw _privateConstructorUsedError;

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement => throw _privateConstructorUsedError;

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  ExplanationOfBenefitReviewOutcome? get reviewOutcome =>
      throw _privateConstructorUsedError;

  /// [adjudication] The adjudication results.
  List<ExplanationOfBenefitAdjudication>? get adjudication =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitSubDetail1CopyWith<ExplanationOfBenefitSubDetail1>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitSubDetail1CopyWith<$Res> {
  factory $ExplanationOfBenefitSubDetail1CopyWith(
          ExplanationOfBenefitSubDetail1 value,
          $Res Function(ExplanationOfBenefitSubDetail1) then) =
      _$ExplanationOfBenefitSubDetail1CopyWithImpl<$Res,
          ExplanationOfBenefitSubDetail1>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? traceNumber,
      CodeableConcept? revenue,
      CodeableConcept? productOrService,
      CodeableConcept? productOrServiceEnd,
      List<CodeableConcept>? modifier,
      Money? patientPaid,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      Money? tax,
      Money? net,
      List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') List<Element>? noteNumberElement,
      ExplanationOfBenefitReviewOutcome? reviewOutcome,
      List<ExplanationOfBenefitAdjudication>? adjudication});

  $CodeableConceptCopyWith<$Res>? get revenue;
  $CodeableConceptCopyWith<$Res>? get productOrService;
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd;
  $MoneyCopyWith<$Res>? get patientPaid;
  $QuantityCopyWith<$Res>? get quantity;
  $MoneyCopyWith<$Res>? get unitPrice;
  $ElementCopyWith<$Res>? get factorElement;
  $MoneyCopyWith<$Res>? get tax;
  $MoneyCopyWith<$Res>? get net;
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome;
}

/// @nodoc
class _$ExplanationOfBenefitSubDetail1CopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitSubDetail1>
    implements $ExplanationOfBenefitSubDetail1CopyWith<$Res> {
  _$ExplanationOfBenefitSubDetail1CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? traceNumber = freezed,
    Object? revenue = freezed,
    Object? productOrService = freezed,
    Object? productOrServiceEnd = freezed,
    Object? modifier = freezed,
    Object? patientPaid = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? tax = freezed,
    Object? net = freezed,
    Object? noteNumber = freezed,
    Object? noteNumberElement = freezed,
    Object? reviewOutcome = freezed,
    Object? adjudication = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      traceNumber: freezed == traceNumber
          ? _value.traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      revenue: freezed == revenue
          ? _value.revenue
          : revenue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrService: freezed == productOrService
          ? _value.productOrService
          : productOrService // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrServiceEnd: freezed == productOrServiceEnd
          ? _value.productOrServiceEnd
          : productOrServiceEnd // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      modifier: freezed == modifier
          ? _value.modifier
          : modifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      tax: freezed == tax
          ? _value.tax
          : tax // ignore: cast_nullable_to_non_nullable
              as Money?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      noteNumber: freezed == noteNumber
          ? _value.noteNumber
          : noteNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      noteNumberElement: freezed == noteNumberElement
          ? _value.noteNumberElement
          : noteNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reviewOutcome: freezed == reviewOutcome
          ? _value.reviewOutcome
          : reviewOutcome // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitReviewOutcome?,
      adjudication: freezed == adjudication
          ? _value.adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get revenue {
    if (_value.revenue == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.revenue!, (value) {
      return _then(_value.copyWith(revenue: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get productOrService {
    if (_value.productOrService == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.productOrService!, (value) {
      return _then(_value.copyWith(productOrService: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd {
    if (_value.productOrServiceEnd == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.productOrServiceEnd!, (value) {
      return _then(_value.copyWith(productOrServiceEnd: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get patientPaid {
    if (_value.patientPaid == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.patientPaid!, (value) {
      return _then(_value.copyWith(patientPaid: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get quantity {
    if (_value.quantity == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.quantity!, (value) {
      return _then(_value.copyWith(quantity: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get unitPrice {
    if (_value.unitPrice == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.unitPrice!, (value) {
      return _then(_value.copyWith(unitPrice: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get factorElement {
    if (_value.factorElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.factorElement!, (value) {
      return _then(_value.copyWith(factorElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get tax {
    if (_value.tax == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.tax!, (value) {
      return _then(_value.copyWith(tax: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get net {
    if (_value.net == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.net!, (value) {
      return _then(_value.copyWith(net: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome {
    if (_value.reviewOutcome == null) {
      return null;
    }

    return $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>(
        _value.reviewOutcome!, (value) {
      return _then(_value.copyWith(reviewOutcome: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitSubDetail1ImplCopyWith<$Res>
    implements $ExplanationOfBenefitSubDetail1CopyWith<$Res> {
  factory _$$ExplanationOfBenefitSubDetail1ImplCopyWith(
          _$ExplanationOfBenefitSubDetail1Impl value,
          $Res Function(_$ExplanationOfBenefitSubDetail1Impl) then) =
      __$$ExplanationOfBenefitSubDetail1ImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? traceNumber,
      CodeableConcept? revenue,
      CodeableConcept? productOrService,
      CodeableConcept? productOrServiceEnd,
      List<CodeableConcept>? modifier,
      Money? patientPaid,
      Quantity? quantity,
      Money? unitPrice,
      FhirDecimal? factor,
      @JsonKey(name: '_factor') Element? factorElement,
      Money? tax,
      Money? net,
      List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') List<Element>? noteNumberElement,
      ExplanationOfBenefitReviewOutcome? reviewOutcome,
      List<ExplanationOfBenefitAdjudication>? adjudication});

  @override
  $CodeableConceptCopyWith<$Res>? get revenue;
  @override
  $CodeableConceptCopyWith<$Res>? get productOrService;
  @override
  $CodeableConceptCopyWith<$Res>? get productOrServiceEnd;
  @override
  $MoneyCopyWith<$Res>? get patientPaid;
  @override
  $QuantityCopyWith<$Res>? get quantity;
  @override
  $MoneyCopyWith<$Res>? get unitPrice;
  @override
  $ElementCopyWith<$Res>? get factorElement;
  @override
  $MoneyCopyWith<$Res>? get tax;
  @override
  $MoneyCopyWith<$Res>? get net;
  @override
  $ExplanationOfBenefitReviewOutcomeCopyWith<$Res>? get reviewOutcome;
}

/// @nodoc
class __$$ExplanationOfBenefitSubDetail1ImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitSubDetail1CopyWithImpl<$Res,
        _$ExplanationOfBenefitSubDetail1Impl>
    implements _$$ExplanationOfBenefitSubDetail1ImplCopyWith<$Res> {
  __$$ExplanationOfBenefitSubDetail1ImplCopyWithImpl(
      _$ExplanationOfBenefitSubDetail1Impl _value,
      $Res Function(_$ExplanationOfBenefitSubDetail1Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? traceNumber = freezed,
    Object? revenue = freezed,
    Object? productOrService = freezed,
    Object? productOrServiceEnd = freezed,
    Object? modifier = freezed,
    Object? patientPaid = freezed,
    Object? quantity = freezed,
    Object? unitPrice = freezed,
    Object? factor = freezed,
    Object? factorElement = freezed,
    Object? tax = freezed,
    Object? net = freezed,
    Object? noteNumber = freezed,
    Object? noteNumberElement = freezed,
    Object? reviewOutcome = freezed,
    Object? adjudication = freezed,
  }) {
    return _then(_$ExplanationOfBenefitSubDetail1Impl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      traceNumber: freezed == traceNumber
          ? _value._traceNumber
          : traceNumber // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      revenue: freezed == revenue
          ? _value.revenue
          : revenue // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrService: freezed == productOrService
          ? _value.productOrService
          : productOrService // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      productOrServiceEnd: freezed == productOrServiceEnd
          ? _value.productOrServiceEnd
          : productOrServiceEnd // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      modifier: freezed == modifier
          ? _value._modifier
          : modifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      patientPaid: freezed == patientPaid
          ? _value.patientPaid
          : patientPaid // ignore: cast_nullable_to_non_nullable
              as Money?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      unitPrice: freezed == unitPrice
          ? _value.unitPrice
          : unitPrice // ignore: cast_nullable_to_non_nullable
              as Money?,
      factor: freezed == factor
          ? _value.factor
          : factor // ignore: cast_nullable_to_non_nullable
              as FhirDecimal?,
      factorElement: freezed == factorElement
          ? _value.factorElement
          : factorElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      tax: freezed == tax
          ? _value.tax
          : tax // ignore: cast_nullable_to_non_nullable
              as Money?,
      net: freezed == net
          ? _value.net
          : net // ignore: cast_nullable_to_non_nullable
              as Money?,
      noteNumber: freezed == noteNumber
          ? _value._noteNumber
          : noteNumber // ignore: cast_nullable_to_non_nullable
              as List<FhirPositiveInt>?,
      noteNumberElement: freezed == noteNumberElement
          ? _value._noteNumberElement
          : noteNumberElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      reviewOutcome: freezed == reviewOutcome
          ? _value.reviewOutcome
          : reviewOutcome // ignore: cast_nullable_to_non_nullable
              as ExplanationOfBenefitReviewOutcome?,
      adjudication: freezed == adjudication
          ? _value._adjudication
          : adjudication // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitAdjudication>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitSubDetail1Impl
    extends _ExplanationOfBenefitSubDetail1 {
  const _$ExplanationOfBenefitSubDetail1Impl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? traceNumber,
      this.revenue,
      this.productOrService,
      this.productOrServiceEnd,
      final List<CodeableConcept>? modifier,
      this.patientPaid,
      this.quantity,
      this.unitPrice,
      this.factor,
      @JsonKey(name: '_factor') this.factorElement,
      this.tax,
      this.net,
      final List<FhirPositiveInt>? noteNumber,
      @JsonKey(name: '_noteNumber') final List<Element>? noteNumberElement,
      this.reviewOutcome,
      final List<ExplanationOfBenefitAdjudication>? adjudication})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _traceNumber = traceNumber,
        _modifier = modifier,
        _noteNumber = noteNumber,
        _noteNumberElement = noteNumberElement,
        _adjudication = adjudication,
        super._();

  factory _$ExplanationOfBenefitSubDetail1Impl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitSubDetail1ImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  final List<Identifier>? _traceNumber;

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  @override
  List<Identifier>? get traceNumber {
    final value = _traceNumber;
    if (value == null) return null;
    if (_traceNumber is EqualUnmodifiableListView) return _traceNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  @override
  final CodeableConcept? revenue;

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  @override
  final CodeableConcept? productOrService;

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  @override
  final CodeableConcept? productOrServiceEnd;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  final List<CodeableConcept>? _modifier;

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  @override
  List<CodeableConcept>? get modifier {
    final value = _modifier;
    if (value == null) return null;
    if (_modifier is EqualUnmodifiableListView) return _modifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  @override
  final Money? patientPaid;

  /// [quantity] The number of repetitions of a service or product.
  @override
  final Quantity? quantity;

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  @override
  final Money? unitPrice;

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  @override
  final FhirDecimal? factor;

  /// [factorElement] ("_factor") Extensions for factor
  @override
  @JsonKey(name: '_factor')
  final Element? factorElement;

  /// [tax] The total of taxes applicable for this product or service.
  @override
  final Money? tax;

  /// [net] The total amount claimed for the addItem.detail.subDetail. Net =
  ///  unit price * quantity * factor.
  @override
  final Money? net;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  final List<FhirPositiveInt>? _noteNumber;

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  @override
  List<FhirPositiveInt>? get noteNumber {
    final value = _noteNumber;
    if (value == null) return null;
    if (_noteNumber is EqualUnmodifiableListView) return _noteNumber;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  final List<Element>? _noteNumberElement;

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @override
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement {
    final value = _noteNumberElement;
    if (value == null) return null;
    if (_noteNumberElement is EqualUnmodifiableListView)
      return _noteNumberElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  @override
  final ExplanationOfBenefitReviewOutcome? reviewOutcome;

  /// [adjudication] The adjudication results.
  final List<ExplanationOfBenefitAdjudication>? _adjudication;

  /// [adjudication] The adjudication results.
  @override
  List<ExplanationOfBenefitAdjudication>? get adjudication {
    final value = _adjudication;
    if (value == null) return null;
    if (_adjudication is EqualUnmodifiableListView) return _adjudication;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExplanationOfBenefitSubDetail1(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, traceNumber: $traceNumber, revenue: $revenue, productOrService: $productOrService, productOrServiceEnd: $productOrServiceEnd, modifier: $modifier, patientPaid: $patientPaid, quantity: $quantity, unitPrice: $unitPrice, factor: $factor, factorElement: $factorElement, tax: $tax, net: $net, noteNumber: $noteNumber, noteNumberElement: $noteNumberElement, reviewOutcome: $reviewOutcome, adjudication: $adjudication)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitSubDetail1Impl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._traceNumber, _traceNumber) &&
            (identical(other.revenue, revenue) || other.revenue == revenue) &&
            (identical(other.productOrService, productOrService) ||
                other.productOrService == productOrService) &&
            (identical(other.productOrServiceEnd, productOrServiceEnd) ||
                other.productOrServiceEnd == productOrServiceEnd) &&
            const DeepCollectionEquality().equals(other._modifier, _modifier) &&
            (identical(other.patientPaid, patientPaid) ||
                other.patientPaid == patientPaid) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.unitPrice, unitPrice) ||
                other.unitPrice == unitPrice) &&
            (identical(other.factor, factor) || other.factor == factor) &&
            (identical(other.factorElement, factorElement) ||
                other.factorElement == factorElement) &&
            (identical(other.tax, tax) || other.tax == tax) &&
            (identical(other.net, net) || other.net == net) &&
            const DeepCollectionEquality()
                .equals(other._noteNumber, _noteNumber) &&
            const DeepCollectionEquality()
                .equals(other._noteNumberElement, _noteNumberElement) &&
            (identical(other.reviewOutcome, reviewOutcome) ||
                other.reviewOutcome == reviewOutcome) &&
            const DeepCollectionEquality()
                .equals(other._adjudication, _adjudication));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_traceNumber),
        revenue,
        productOrService,
        productOrServiceEnd,
        const DeepCollectionEquality().hash(_modifier),
        patientPaid,
        quantity,
        unitPrice,
        factor,
        factorElement,
        tax,
        net,
        const DeepCollectionEquality().hash(_noteNumber),
        const DeepCollectionEquality().hash(_noteNumberElement),
        reviewOutcome,
        const DeepCollectionEquality().hash(_adjudication)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitSubDetail1ImplCopyWith<
          _$ExplanationOfBenefitSubDetail1Impl>
      get copyWith => __$$ExplanationOfBenefitSubDetail1ImplCopyWithImpl<
          _$ExplanationOfBenefitSubDetail1Impl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitSubDetail1ImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitSubDetail1
    extends ExplanationOfBenefitSubDetail1 {
  const factory _ExplanationOfBenefitSubDetail1(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Identifier>? traceNumber,
          final CodeableConcept? revenue,
          final CodeableConcept? productOrService,
          final CodeableConcept? productOrServiceEnd,
          final List<CodeableConcept>? modifier,
          final Money? patientPaid,
          final Quantity? quantity,
          final Money? unitPrice,
          final FhirDecimal? factor,
          @JsonKey(name: '_factor') final Element? factorElement,
          final Money? tax,
          final Money? net,
          final List<FhirPositiveInt>? noteNumber,
          @JsonKey(name: '_noteNumber') final List<Element>? noteNumberElement,
          final ExplanationOfBenefitReviewOutcome? reviewOutcome,
          final List<ExplanationOfBenefitAdjudication>? adjudication}) =
      _$ExplanationOfBenefitSubDetail1Impl;
  const _ExplanationOfBenefitSubDetail1._() : super._();

  factory _ExplanationOfBenefitSubDetail1.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitSubDetail1Impl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [traceNumber] Trace number for tracking purposes. May be defined at the
  ///  jurisdiction level or between trading partners.
  List<Identifier>? get traceNumber;
  @override

  /// [revenue] The type of revenue or cost center providing the product
  ///  and/or service.
  CodeableConcept? get revenue;
  @override

  /// [productOrService] When the value is a group code then this item
  ///  collects a set of related item details, otherwise this contains the
  ///  product, service, drug or other billing code for the item. This
  ///  element may be the start of a range of .productOrService codes used in
  ///  conjunction with .productOrServiceEnd or it may be a solo element
  ///  where .productOrServiceEnd is not used.
  CodeableConcept? get productOrService;
  @override

  /// [productOrServiceEnd] This contains the end of a range of product,
  ///  service, drug or other billing codes for the item. This element is not
  ///  used when the .productOrService is a group code. This value may only
  ///  be present when a .productOfService code has been provided to convey
  ///  the start of the range. Typically this value may be used only with
  ///  preauthorizations and not with claims.
  CodeableConcept? get productOrServiceEnd;
  @override

  /// [modifier] Item typification or modifiers codes to convey additional
  ///  context for the product or service.
  List<CodeableConcept>? get modifier;
  @override

  /// [patientPaid] The amount paid by the patient, in total at the claim
  ///  claim level or specifically for the item and detail level, to the
  ///  provider for goods and services.
  Money? get patientPaid;
  @override

  /// [quantity] The number of repetitions of a service or product.
  Quantity? get quantity;
  @override

  /// [unitPrice] If the item is not a group then this is the fee for the
  ///  product or service, otherwise this is the total of the fees for the
  ///  details of the group.
  Money? get unitPrice;
  @override

  /// [factor] A real number that represents a multiplier used in determining
  ///  the overall value of services delivered and/or goods received. The
  ///  concept of a Factor allows for a discount or surcharge multiplier to
  ///  be applied to a monetary amount.
  FhirDecimal? get factor;
  @override

  /// [factorElement] ("_factor") Extensions for factor
  @JsonKey(name: '_factor')
  Element? get factorElement;
  @override

  /// [tax] The total of taxes applicable for this product or service.
  Money? get tax;
  @override

  /// [net] The total amount claimed for the addItem.detail.subDetail. Net =
  ///  unit price * quantity * factor.
  Money? get net;
  @override

  /// [noteNumber] The numbers associated with notes below which apply to the
  ///  adjudication of this item.
  List<FhirPositiveInt>? get noteNumber;
  @override

  /// [noteNumberElement] ("_noteNumber") Extensions for noteNumber
  @JsonKey(name: '_noteNumber')
  List<Element>? get noteNumberElement;
  @override

  /// [reviewOutcome] The high-level results of the adjudication if
  ///  adjudication has been performed.
  ExplanationOfBenefitReviewOutcome? get reviewOutcome;
  @override

  /// [adjudication] The adjudication results.
  List<ExplanationOfBenefitAdjudication>? get adjudication;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitSubDetail1ImplCopyWith<
          _$ExplanationOfBenefitSubDetail1Impl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitTotal _$ExplanationOfBenefitTotalFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitTotal.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitTotal {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [category] A code to indicate the information type of this adjudication
  ///  record. Information types may include: the value submitted, maximum
  ///  values or percentages allowed or payable under the plan, amounts that
  ///  the patient is responsible for in aggregate or pertaining to this
  ///  item, amounts paid by other coverages, and the benefit payable for
  ///  this item.
  CodeableConcept get category => throw _privateConstructorUsedError;

  /// [amount] Monetary total amount associated with the category.
  Money get amount => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitTotalCopyWith<ExplanationOfBenefitTotal> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitTotalCopyWith<$Res> {
  factory $ExplanationOfBenefitTotalCopyWith(ExplanationOfBenefitTotal value,
          $Res Function(ExplanationOfBenefitTotal) then) =
      _$ExplanationOfBenefitTotalCopyWithImpl<$Res, ExplanationOfBenefitTotal>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept category,
      Money amount});

  $CodeableConceptCopyWith<$Res> get category;
  $MoneyCopyWith<$Res> get amount;
}

/// @nodoc
class _$ExplanationOfBenefitTotalCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitTotal>
    implements $ExplanationOfBenefitTotalCopyWith<$Res> {
  _$ExplanationOfBenefitTotalCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? category = null,
    Object? amount = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Money,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get category {
    return $CodeableConceptCopyWith<$Res>(_value.category, (value) {
      return _then(_value.copyWith(category: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res> get amount {
    return $MoneyCopyWith<$Res>(_value.amount, (value) {
      return _then(_value.copyWith(amount: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitTotalImplCopyWith<$Res>
    implements $ExplanationOfBenefitTotalCopyWith<$Res> {
  factory _$$ExplanationOfBenefitTotalImplCopyWith(
          _$ExplanationOfBenefitTotalImpl value,
          $Res Function(_$ExplanationOfBenefitTotalImpl) then) =
      __$$ExplanationOfBenefitTotalImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept category,
      Money amount});

  @override
  $CodeableConceptCopyWith<$Res> get category;
  @override
  $MoneyCopyWith<$Res> get amount;
}

/// @nodoc
class __$$ExplanationOfBenefitTotalImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitTotalCopyWithImpl<$Res,
        _$ExplanationOfBenefitTotalImpl>
    implements _$$ExplanationOfBenefitTotalImplCopyWith<$Res> {
  __$$ExplanationOfBenefitTotalImplCopyWithImpl(
      _$ExplanationOfBenefitTotalImpl _value,
      $Res Function(_$ExplanationOfBenefitTotalImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? category = null,
    Object? amount = null,
  }) {
    return _then(_$ExplanationOfBenefitTotalImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Money,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitTotalImpl extends _ExplanationOfBenefitTotal {
  const _$ExplanationOfBenefitTotalImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.category,
      required this.amount})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ExplanationOfBenefitTotalImpl.fromJson(Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitTotalImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [category] A code to indicate the information type of this adjudication
  ///  record. Information types may include: the value submitted, maximum
  ///  values or percentages allowed or payable under the plan, amounts that
  ///  the patient is responsible for in aggregate or pertaining to this
  ///  item, amounts paid by other coverages, and the benefit payable for
  ///  this item.
  @override
  final CodeableConcept category;

  /// [amount] Monetary total amount associated with the category.
  @override
  final Money amount;

  @override
  String toString() {
    return 'ExplanationOfBenefitTotal(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, category: $category, amount: $amount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitTotalImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      category,
      amount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitTotalImplCopyWith<_$ExplanationOfBenefitTotalImpl>
      get copyWith => __$$ExplanationOfBenefitTotalImplCopyWithImpl<
          _$ExplanationOfBenefitTotalImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitTotalImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitTotal extends ExplanationOfBenefitTotal {
  const factory _ExplanationOfBenefitTotal(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableConcept category,
      required final Money amount}) = _$ExplanationOfBenefitTotalImpl;
  const _ExplanationOfBenefitTotal._() : super._();

  factory _ExplanationOfBenefitTotal.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitTotalImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [category] A code to indicate the information type of this adjudication
  ///  record. Information types may include: the value submitted, maximum
  ///  values or percentages allowed or payable under the plan, amounts that
  ///  the patient is responsible for in aggregate or pertaining to this
  ///  item, amounts paid by other coverages, and the benefit payable for
  ///  this item.
  CodeableConcept get category;
  @override

  /// [amount] Monetary total amount associated with the category.
  Money get amount;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitTotalImplCopyWith<_$ExplanationOfBenefitTotalImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitPayment _$ExplanationOfBenefitPaymentFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitPayment.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitPayment {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Whether this represents partial or complete payment of the
  ///  benefits payable.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [adjustment] Total amount of all adjustments to this payment included
  ///  in this transaction which are not related to this claim's adjudication.
  Money? get adjustment => throw _privateConstructorUsedError;

  /// [adjustmentReason] Reason for the payment adjustment.
  CodeableConcept? get adjustmentReason => throw _privateConstructorUsedError;

  /// [date] Estimated date the payment will be issued or the actual issue
  ///  date of payment.
  FhirDate? get date => throw _privateConstructorUsedError;

  /// [dateElement] ("_date") Extensions for date
  @JsonKey(name: '_date')
  Element? get dateElement => throw _privateConstructorUsedError;

  /// [amount] Benefits payable less any payment adjustment.
  Money? get amount => throw _privateConstructorUsedError;

  /// [identifier] Issuer's unique identifier for the payment instrument.
  Identifier? get identifier => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitPaymentCopyWith<ExplanationOfBenefitPayment>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitPaymentCopyWith<$Res> {
  factory $ExplanationOfBenefitPaymentCopyWith(
          ExplanationOfBenefitPayment value,
          $Res Function(ExplanationOfBenefitPayment) then) =
      _$ExplanationOfBenefitPaymentCopyWithImpl<$Res,
          ExplanationOfBenefitPayment>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      Money? adjustment,
      CodeableConcept? adjustmentReason,
      FhirDate? date,
      @JsonKey(name: '_date') Element? dateElement,
      Money? amount,
      Identifier? identifier});

  $CodeableConceptCopyWith<$Res>? get type;
  $MoneyCopyWith<$Res>? get adjustment;
  $CodeableConceptCopyWith<$Res>? get adjustmentReason;
  $ElementCopyWith<$Res>? get dateElement;
  $MoneyCopyWith<$Res>? get amount;
  $IdentifierCopyWith<$Res>? get identifier;
}

/// @nodoc
class _$ExplanationOfBenefitPaymentCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitPayment>
    implements $ExplanationOfBenefitPaymentCopyWith<$Res> {
  _$ExplanationOfBenefitPaymentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? adjustment = freezed,
    Object? adjustmentReason = freezed,
    Object? date = freezed,
    Object? dateElement = freezed,
    Object? amount = freezed,
    Object? identifier = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      adjustment: freezed == adjustment
          ? _value.adjustment
          : adjustment // ignore: cast_nullable_to_non_nullable
              as Money?,
      adjustmentReason: freezed == adjustmentReason
          ? _value.adjustmentReason
          : adjustmentReason // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      dateElement: freezed == dateElement
          ? _value.dateElement
          : dateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Money?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get adjustment {
    if (_value.adjustment == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.adjustment!, (value) {
      return _then(_value.copyWith(adjustment: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get adjustmentReason {
    if (_value.adjustmentReason == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.adjustmentReason!, (value) {
      return _then(_value.copyWith(adjustmentReason: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get dateElement {
    if (_value.dateElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.dateElement!, (value) {
      return _then(_value.copyWith(dateElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get amount {
    if (_value.amount == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.amount!, (value) {
      return _then(_value.copyWith(amount: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $IdentifierCopyWith<$Res>? get identifier {
    if (_value.identifier == null) {
      return null;
    }

    return $IdentifierCopyWith<$Res>(_value.identifier!, (value) {
      return _then(_value.copyWith(identifier: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitPaymentImplCopyWith<$Res>
    implements $ExplanationOfBenefitPaymentCopyWith<$Res> {
  factory _$$ExplanationOfBenefitPaymentImplCopyWith(
          _$ExplanationOfBenefitPaymentImpl value,
          $Res Function(_$ExplanationOfBenefitPaymentImpl) then) =
      __$$ExplanationOfBenefitPaymentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      Money? adjustment,
      CodeableConcept? adjustmentReason,
      FhirDate? date,
      @JsonKey(name: '_date') Element? dateElement,
      Money? amount,
      Identifier? identifier});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $MoneyCopyWith<$Res>? get adjustment;
  @override
  $CodeableConceptCopyWith<$Res>? get adjustmentReason;
  @override
  $ElementCopyWith<$Res>? get dateElement;
  @override
  $MoneyCopyWith<$Res>? get amount;
  @override
  $IdentifierCopyWith<$Res>? get identifier;
}

/// @nodoc
class __$$ExplanationOfBenefitPaymentImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitPaymentCopyWithImpl<$Res,
        _$ExplanationOfBenefitPaymentImpl>
    implements _$$ExplanationOfBenefitPaymentImplCopyWith<$Res> {
  __$$ExplanationOfBenefitPaymentImplCopyWithImpl(
      _$ExplanationOfBenefitPaymentImpl _value,
      $Res Function(_$ExplanationOfBenefitPaymentImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? adjustment = freezed,
    Object? adjustmentReason = freezed,
    Object? date = freezed,
    Object? dateElement = freezed,
    Object? amount = freezed,
    Object? identifier = freezed,
  }) {
    return _then(_$ExplanationOfBenefitPaymentImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      adjustment: freezed == adjustment
          ? _value.adjustment
          : adjustment // ignore: cast_nullable_to_non_nullable
              as Money?,
      adjustmentReason: freezed == adjustmentReason
          ? _value.adjustmentReason
          : adjustmentReason // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as FhirDate?,
      dateElement: freezed == dateElement
          ? _value.dateElement
          : dateElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as Money?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as Identifier?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitPaymentImpl extends _ExplanationOfBenefitPayment {
  const _$ExplanationOfBenefitPaymentImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      this.adjustment,
      this.adjustmentReason,
      this.date,
      @JsonKey(name: '_date') this.dateElement,
      this.amount,
      this.identifier})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ExplanationOfBenefitPaymentImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitPaymentImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Whether this represents partial or complete payment of the
  ///  benefits payable.
  @override
  final CodeableConcept? type;

  /// [adjustment] Total amount of all adjustments to this payment included
  ///  in this transaction which are not related to this claim's adjudication.
  @override
  final Money? adjustment;

  /// [adjustmentReason] Reason for the payment adjustment.
  @override
  final CodeableConcept? adjustmentReason;

  /// [date] Estimated date the payment will be issued or the actual issue
  ///  date of payment.
  @override
  final FhirDate? date;

  /// [dateElement] ("_date") Extensions for date
  @override
  @JsonKey(name: '_date')
  final Element? dateElement;

  /// [amount] Benefits payable less any payment adjustment.
  @override
  final Money? amount;

  /// [identifier] Issuer's unique identifier for the payment instrument.
  @override
  final Identifier? identifier;

  @override
  String toString() {
    return 'ExplanationOfBenefitPayment(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, adjustment: $adjustment, adjustmentReason: $adjustmentReason, date: $date, dateElement: $dateElement, amount: $amount, identifier: $identifier)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitPaymentImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.adjustment, adjustment) ||
                other.adjustment == adjustment) &&
            (identical(other.adjustmentReason, adjustmentReason) ||
                other.adjustmentReason == adjustmentReason) &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.dateElement, dateElement) ||
                other.dateElement == dateElement) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.identifier, identifier) ||
                other.identifier == identifier));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      adjustment,
      adjustmentReason,
      date,
      dateElement,
      amount,
      identifier);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitPaymentImplCopyWith<_$ExplanationOfBenefitPaymentImpl>
      get copyWith => __$$ExplanationOfBenefitPaymentImplCopyWithImpl<
          _$ExplanationOfBenefitPaymentImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitPaymentImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitPayment
    extends ExplanationOfBenefitPayment {
  const factory _ExplanationOfBenefitPayment(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final CodeableConcept? type,
      final Money? adjustment,
      final CodeableConcept? adjustmentReason,
      final FhirDate? date,
      @JsonKey(name: '_date') final Element? dateElement,
      final Money? amount,
      final Identifier? identifier}) = _$ExplanationOfBenefitPaymentImpl;
  const _ExplanationOfBenefitPayment._() : super._();

  factory _ExplanationOfBenefitPayment.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitPaymentImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Whether this represents partial or complete payment of the
  ///  benefits payable.
  CodeableConcept? get type;
  @override

  /// [adjustment] Total amount of all adjustments to this payment included
  ///  in this transaction which are not related to this claim's adjudication.
  Money? get adjustment;
  @override

  /// [adjustmentReason] Reason for the payment adjustment.
  CodeableConcept? get adjustmentReason;
  @override

  /// [date] Estimated date the payment will be issued or the actual issue
  ///  date of payment.
  FhirDate? get date;
  @override

  /// [dateElement] ("_date") Extensions for date
  @JsonKey(name: '_date')
  Element? get dateElement;
  @override

  /// [amount] Benefits payable less any payment adjustment.
  Money? get amount;
  @override

  /// [identifier] Issuer's unique identifier for the payment instrument.
  Identifier? get identifier;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitPaymentImplCopyWith<_$ExplanationOfBenefitPaymentImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitProcessNote _$ExplanationOfBenefitProcessNoteFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitProcessNote.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitProcessNote {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [number] A number to uniquely identify a note entry.
  FhirPositiveInt? get number => throw _privateConstructorUsedError;

  /// [numberElement] ("_number") Extensions for number
  @JsonKey(name: '_number')
  Element? get numberElement => throw _privateConstructorUsedError;

  /// [type] The business purpose of the note text.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [text] The explanation or description associated with the processing.
  String? get text => throw _privateConstructorUsedError;

  /// [textElement] ("_text") Extensions for text
  @JsonKey(name: '_text')
  Element? get textElement => throw _privateConstructorUsedError;

  /// [language] A code to define the language used in the text of the note.
  CodeableConcept? get language => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitProcessNoteCopyWith<ExplanationOfBenefitProcessNote>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitProcessNoteCopyWith<$Res> {
  factory $ExplanationOfBenefitProcessNoteCopyWith(
          ExplanationOfBenefitProcessNote value,
          $Res Function(ExplanationOfBenefitProcessNote) then) =
      _$ExplanationOfBenefitProcessNoteCopyWithImpl<$Res,
          ExplanationOfBenefitProcessNote>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? number,
      @JsonKey(name: '_number') Element? numberElement,
      CodeableConcept? type,
      String? text,
      @JsonKey(name: '_text') Element? textElement,
      CodeableConcept? language});

  $ElementCopyWith<$Res>? get numberElement;
  $CodeableConceptCopyWith<$Res>? get type;
  $ElementCopyWith<$Res>? get textElement;
  $CodeableConceptCopyWith<$Res>? get language;
}

/// @nodoc
class _$ExplanationOfBenefitProcessNoteCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitProcessNote>
    implements $ExplanationOfBenefitProcessNoteCopyWith<$Res> {
  _$ExplanationOfBenefitProcessNoteCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? number = freezed,
    Object? numberElement = freezed,
    Object? type = freezed,
    Object? text = freezed,
    Object? textElement = freezed,
    Object? language = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      numberElement: freezed == numberElement
          ? _value.numberElement
          : numberElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      textElement: freezed == textElement
          ? _value.textElement
          : textElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get numberElement {
    if (_value.numberElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.numberElement!, (value) {
      return _then(_value.copyWith(numberElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get textElement {
    if (_value.textElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.textElement!, (value) {
      return _then(_value.copyWith(textElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get language {
    if (_value.language == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.language!, (value) {
      return _then(_value.copyWith(language: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitProcessNoteImplCopyWith<$Res>
    implements $ExplanationOfBenefitProcessNoteCopyWith<$Res> {
  factory _$$ExplanationOfBenefitProcessNoteImplCopyWith(
          _$ExplanationOfBenefitProcessNoteImpl value,
          $Res Function(_$ExplanationOfBenefitProcessNoteImpl) then) =
      __$$ExplanationOfBenefitProcessNoteImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      FhirPositiveInt? number,
      @JsonKey(name: '_number') Element? numberElement,
      CodeableConcept? type,
      String? text,
      @JsonKey(name: '_text') Element? textElement,
      CodeableConcept? language});

  @override
  $ElementCopyWith<$Res>? get numberElement;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ElementCopyWith<$Res>? get textElement;
  @override
  $CodeableConceptCopyWith<$Res>? get language;
}

/// @nodoc
class __$$ExplanationOfBenefitProcessNoteImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitProcessNoteCopyWithImpl<$Res,
        _$ExplanationOfBenefitProcessNoteImpl>
    implements _$$ExplanationOfBenefitProcessNoteImplCopyWith<$Res> {
  __$$ExplanationOfBenefitProcessNoteImplCopyWithImpl(
      _$ExplanationOfBenefitProcessNoteImpl _value,
      $Res Function(_$ExplanationOfBenefitProcessNoteImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? number = freezed,
    Object? numberElement = freezed,
    Object? type = freezed,
    Object? text = freezed,
    Object? textElement = freezed,
    Object? language = freezed,
  }) {
    return _then(_$ExplanationOfBenefitProcessNoteImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      number: freezed == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      numberElement: freezed == numberElement
          ? _value.numberElement
          : numberElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      textElement: freezed == textElement
          ? _value.textElement
          : textElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitProcessNoteImpl
    extends _ExplanationOfBenefitProcessNote {
  const _$ExplanationOfBenefitProcessNoteImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.number,
      @JsonKey(name: '_number') this.numberElement,
      this.type,
      this.text,
      @JsonKey(name: '_text') this.textElement,
      this.language})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ExplanationOfBenefitProcessNoteImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitProcessNoteImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [number] A number to uniquely identify a note entry.
  @override
  final FhirPositiveInt? number;

  /// [numberElement] ("_number") Extensions for number
  @override
  @JsonKey(name: '_number')
  final Element? numberElement;

  /// [type] The business purpose of the note text.
  @override
  final CodeableConcept? type;

  /// [text] The explanation or description associated with the processing.
  @override
  final String? text;

  /// [textElement] ("_text") Extensions for text
  @override
  @JsonKey(name: '_text')
  final Element? textElement;

  /// [language] A code to define the language used in the text of the note.
  @override
  final CodeableConcept? language;

  @override
  String toString() {
    return 'ExplanationOfBenefitProcessNote(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, number: $number, numberElement: $numberElement, type: $type, text: $text, textElement: $textElement, language: $language)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitProcessNoteImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.numberElement, numberElement) ||
                other.numberElement == numberElement) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.textElement, textElement) ||
                other.textElement == textElement) &&
            (identical(other.language, language) ||
                other.language == language));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      number,
      numberElement,
      type,
      text,
      textElement,
      language);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitProcessNoteImplCopyWith<
          _$ExplanationOfBenefitProcessNoteImpl>
      get copyWith => __$$ExplanationOfBenefitProcessNoteImplCopyWithImpl<
          _$ExplanationOfBenefitProcessNoteImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitProcessNoteImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitProcessNote
    extends ExplanationOfBenefitProcessNote {
  const factory _ExplanationOfBenefitProcessNote(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final FhirPositiveInt? number,
      @JsonKey(name: '_number') final Element? numberElement,
      final CodeableConcept? type,
      final String? text,
      @JsonKey(name: '_text') final Element? textElement,
      final CodeableConcept? language}) = _$ExplanationOfBenefitProcessNoteImpl;
  const _ExplanationOfBenefitProcessNote._() : super._();

  factory _ExplanationOfBenefitProcessNote.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitProcessNoteImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [number] A number to uniquely identify a note entry.
  FhirPositiveInt? get number;
  @override

  /// [numberElement] ("_number") Extensions for number
  @JsonKey(name: '_number')
  Element? get numberElement;
  @override

  /// [type] The business purpose of the note text.
  CodeableConcept? get type;
  @override

  /// [text] The explanation or description associated with the processing.
  String? get text;
  @override

  /// [textElement] ("_text") Extensions for text
  @JsonKey(name: '_text')
  Element? get textElement;
  @override

  /// [language] A code to define the language used in the text of the note.
  CodeableConcept? get language;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitProcessNoteImplCopyWith<
          _$ExplanationOfBenefitProcessNoteImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitBenefitBalance _$ExplanationOfBenefitBenefitBalanceFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitBenefitBalance.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitBenefitBalance {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [category] Code to identify the general type of benefits under which
  ///  products and services are provided.
  CodeableConcept get category => throw _privateConstructorUsedError;

  /// [excluded] True if the indicated class of service is excluded from the
  ///  plan, missing or False indicates the product or service is included in
  ///  the coverage.
  FhirBoolean? get excluded => throw _privateConstructorUsedError;

  /// [excludedElement] ("_excluded") Extensions for excluded
  @JsonKey(name: '_excluded')
  Element? get excludedElement => throw _privateConstructorUsedError;

  /// [name] A short name or tag for the benefit.
  String? get name => throw _privateConstructorUsedError;

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// [description] A richer description of the benefit or services covered.
  String? get description => throw _privateConstructorUsedError;

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement => throw _privateConstructorUsedError;

  /// [network] Is a flag to indicate whether the benefits refer to
  ///  in-network providers or out-of-network providers.
  CodeableConcept? get network => throw _privateConstructorUsedError;

  /// [unit] Indicates if the benefits apply to an individual or to the
  ///  family.
  CodeableConcept? get unit => throw _privateConstructorUsedError;

  /// [term] The term or period of the values such as 'maximum lifetime
  ///  benefit' or 'maximum annual visits'.
  CodeableConcept? get term => throw _privateConstructorUsedError;

  /// [financial] Benefits Used to date.
  List<ExplanationOfBenefitFinancial>? get financial =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitBenefitBalanceCopyWith<
          ExplanationOfBenefitBenefitBalance>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitBenefitBalanceCopyWith<$Res> {
  factory $ExplanationOfBenefitBenefitBalanceCopyWith(
          ExplanationOfBenefitBenefitBalance value,
          $Res Function(ExplanationOfBenefitBenefitBalance) then) =
      _$ExplanationOfBenefitBenefitBalanceCopyWithImpl<$Res,
          ExplanationOfBenefitBenefitBalance>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept category,
      FhirBoolean? excluded,
      @JsonKey(name: '_excluded') Element? excludedElement,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      String? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      CodeableConcept? network,
      CodeableConcept? unit,
      CodeableConcept? term,
      List<ExplanationOfBenefitFinancial>? financial});

  $CodeableConceptCopyWith<$Res> get category;
  $ElementCopyWith<$Res>? get excludedElement;
  $ElementCopyWith<$Res>? get nameElement;
  $ElementCopyWith<$Res>? get descriptionElement;
  $CodeableConceptCopyWith<$Res>? get network;
  $CodeableConceptCopyWith<$Res>? get unit;
  $CodeableConceptCopyWith<$Res>? get term;
}

/// @nodoc
class _$ExplanationOfBenefitBenefitBalanceCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitBenefitBalance>
    implements $ExplanationOfBenefitBenefitBalanceCopyWith<$Res> {
  _$ExplanationOfBenefitBenefitBalanceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? category = null,
    Object? excluded = freezed,
    Object? excludedElement = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? network = freezed,
    Object? unit = freezed,
    Object? term = freezed,
    Object? financial = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      excluded: freezed == excluded
          ? _value.excluded
          : excluded // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      excludedElement: freezed == excludedElement
          ? _value.excludedElement
          : excludedElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      network: freezed == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      term: freezed == term
          ? _value.term
          : term // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      financial: freezed == financial
          ? _value.financial
          : financial // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitFinancial>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get category {
    return $CodeableConceptCopyWith<$Res>(_value.category, (value) {
      return _then(_value.copyWith(category: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get excludedElement {
    if (_value.excludedElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.excludedElement!, (value) {
      return _then(_value.copyWith(excludedElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get descriptionElement {
    if (_value.descriptionElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.descriptionElement!, (value) {
      return _then(_value.copyWith(descriptionElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get network {
    if (_value.network == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.network!, (value) {
      return _then(_value.copyWith(network: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get unit {
    if (_value.unit == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.unit!, (value) {
      return _then(_value.copyWith(unit: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get term {
    if (_value.term == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.term!, (value) {
      return _then(_value.copyWith(term: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitBenefitBalanceImplCopyWith<$Res>
    implements $ExplanationOfBenefitBenefitBalanceCopyWith<$Res> {
  factory _$$ExplanationOfBenefitBenefitBalanceImplCopyWith(
          _$ExplanationOfBenefitBenefitBalanceImpl value,
          $Res Function(_$ExplanationOfBenefitBenefitBalanceImpl) then) =
      __$$ExplanationOfBenefitBenefitBalanceImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept category,
      FhirBoolean? excluded,
      @JsonKey(name: '_excluded') Element? excludedElement,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      String? description,
      @JsonKey(name: '_description') Element? descriptionElement,
      CodeableConcept? network,
      CodeableConcept? unit,
      CodeableConcept? term,
      List<ExplanationOfBenefitFinancial>? financial});

  @override
  $CodeableConceptCopyWith<$Res> get category;
  @override
  $ElementCopyWith<$Res>? get excludedElement;
  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $ElementCopyWith<$Res>? get descriptionElement;
  @override
  $CodeableConceptCopyWith<$Res>? get network;
  @override
  $CodeableConceptCopyWith<$Res>? get unit;
  @override
  $CodeableConceptCopyWith<$Res>? get term;
}

/// @nodoc
class __$$ExplanationOfBenefitBenefitBalanceImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitBenefitBalanceCopyWithImpl<$Res,
        _$ExplanationOfBenefitBenefitBalanceImpl>
    implements _$$ExplanationOfBenefitBenefitBalanceImplCopyWith<$Res> {
  __$$ExplanationOfBenefitBenefitBalanceImplCopyWithImpl(
      _$ExplanationOfBenefitBenefitBalanceImpl _value,
      $Res Function(_$ExplanationOfBenefitBenefitBalanceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? category = null,
    Object? excluded = freezed,
    Object? excludedElement = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? description = freezed,
    Object? descriptionElement = freezed,
    Object? network = freezed,
    Object? unit = freezed,
    Object? term = freezed,
    Object? financial = freezed,
  }) {
    return _then(_$ExplanationOfBenefitBenefitBalanceImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      excluded: freezed == excluded
          ? _value.excluded
          : excluded // ignore: cast_nullable_to_non_nullable
              as FhirBoolean?,
      excludedElement: freezed == excludedElement
          ? _value.excludedElement
          : excludedElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      descriptionElement: freezed == descriptionElement
          ? _value.descriptionElement
          : descriptionElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      network: freezed == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      term: freezed == term
          ? _value.term
          : term // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      financial: freezed == financial
          ? _value._financial
          : financial // ignore: cast_nullable_to_non_nullable
              as List<ExplanationOfBenefitFinancial>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitBenefitBalanceImpl
    extends _ExplanationOfBenefitBenefitBalance {
  const _$ExplanationOfBenefitBenefitBalanceImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.category,
      this.excluded,
      @JsonKey(name: '_excluded') this.excludedElement,
      this.name,
      @JsonKey(name: '_name') this.nameElement,
      this.description,
      @JsonKey(name: '_description') this.descriptionElement,
      this.network,
      this.unit,
      this.term,
      final List<ExplanationOfBenefitFinancial>? financial})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _financial = financial,
        super._();

  factory _$ExplanationOfBenefitBenefitBalanceImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitBenefitBalanceImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [category] Code to identify the general type of benefits under which
  ///  products and services are provided.
  @override
  final CodeableConcept category;

  /// [excluded] True if the indicated class of service is excluded from the
  ///  plan, missing or False indicates the product or service is included in
  ///  the coverage.
  @override
  final FhirBoolean? excluded;

  /// [excludedElement] ("_excluded") Extensions for excluded
  @override
  @JsonKey(name: '_excluded')
  final Element? excludedElement;

  /// [name] A short name or tag for the benefit.
  @override
  final String? name;

  /// [nameElement] ("_name") Extensions for name
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// [description] A richer description of the benefit or services covered.
  @override
  final String? description;

  /// [descriptionElement] ("_description") Extensions for description
  @override
  @JsonKey(name: '_description')
  final Element? descriptionElement;

  /// [network] Is a flag to indicate whether the benefits refer to
  ///  in-network providers or out-of-network providers.
  @override
  final CodeableConcept? network;

  /// [unit] Indicates if the benefits apply to an individual or to the
  ///  family.
  @override
  final CodeableConcept? unit;

  /// [term] The term or period of the values such as 'maximum lifetime
  ///  benefit' or 'maximum annual visits'.
  @override
  final CodeableConcept? term;

  /// [financial] Benefits Used to date.
  final List<ExplanationOfBenefitFinancial>? _financial;

  /// [financial] Benefits Used to date.
  @override
  List<ExplanationOfBenefitFinancial>? get financial {
    final value = _financial;
    if (value == null) return null;
    if (_financial is EqualUnmodifiableListView) return _financial;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExplanationOfBenefitBenefitBalance(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, category: $category, excluded: $excluded, excludedElement: $excludedElement, name: $name, nameElement: $nameElement, description: $description, descriptionElement: $descriptionElement, network: $network, unit: $unit, term: $term, financial: $financial)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitBenefitBalanceImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.excluded, excluded) ||
                other.excluded == excluded) &&
            (identical(other.excludedElement, excludedElement) ||
                other.excludedElement == excludedElement) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.descriptionElement, descriptionElement) ||
                other.descriptionElement == descriptionElement) &&
            (identical(other.network, network) || other.network == network) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            (identical(other.term, term) || other.term == term) &&
            const DeepCollectionEquality()
                .equals(other._financial, _financial));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      category,
      excluded,
      excludedElement,
      name,
      nameElement,
      description,
      descriptionElement,
      network,
      unit,
      term,
      const DeepCollectionEquality().hash(_financial));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitBenefitBalanceImplCopyWith<
          _$ExplanationOfBenefitBenefitBalanceImpl>
      get copyWith => __$$ExplanationOfBenefitBenefitBalanceImplCopyWithImpl<
          _$ExplanationOfBenefitBenefitBalanceImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitBenefitBalanceImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitBenefitBalance
    extends ExplanationOfBenefitBenefitBalance {
  const factory _ExplanationOfBenefitBenefitBalance(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept category,
          final FhirBoolean? excluded,
          @JsonKey(name: '_excluded') final Element? excludedElement,
          final String? name,
          @JsonKey(name: '_name') final Element? nameElement,
          final String? description,
          @JsonKey(name: '_description') final Element? descriptionElement,
          final CodeableConcept? network,
          final CodeableConcept? unit,
          final CodeableConcept? term,
          final List<ExplanationOfBenefitFinancial>? financial}) =
      _$ExplanationOfBenefitBenefitBalanceImpl;
  const _ExplanationOfBenefitBenefitBalance._() : super._();

  factory _ExplanationOfBenefitBenefitBalance.fromJson(
          Map<String, dynamic> json) =
      _$ExplanationOfBenefitBenefitBalanceImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [category] Code to identify the general type of benefits under which
  ///  products and services are provided.
  CodeableConcept get category;
  @override

  /// [excluded] True if the indicated class of service is excluded from the
  ///  plan, missing or False indicates the product or service is included in
  ///  the coverage.
  FhirBoolean? get excluded;
  @override

  /// [excludedElement] ("_excluded") Extensions for excluded
  @JsonKey(name: '_excluded')
  Element? get excludedElement;
  @override

  /// [name] A short name or tag for the benefit.
  String? get name;
  @override

  /// [nameElement] ("_name") Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// [description] A richer description of the benefit or services covered.
  String? get description;
  @override

  /// [descriptionElement] ("_description") Extensions for description
  @JsonKey(name: '_description')
  Element? get descriptionElement;
  @override

  /// [network] Is a flag to indicate whether the benefits refer to
  ///  in-network providers or out-of-network providers.
  CodeableConcept? get network;
  @override

  /// [unit] Indicates if the benefits apply to an individual or to the
  ///  family.
  CodeableConcept? get unit;
  @override

  /// [term] The term or period of the values such as 'maximum lifetime
  ///  benefit' or 'maximum annual visits'.
  CodeableConcept? get term;
  @override

  /// [financial] Benefits Used to date.
  List<ExplanationOfBenefitFinancial>? get financial;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitBenefitBalanceImplCopyWith<
          _$ExplanationOfBenefitBenefitBalanceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ExplanationOfBenefitFinancial _$ExplanationOfBenefitFinancialFromJson(
    Map<String, dynamic> json) {
  return _ExplanationOfBenefitFinancial.fromJson(json);
}

/// @nodoc
mixin _$ExplanationOfBenefitFinancial {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Classification of benefit being provided.
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [allowedUnsignedInt] The quantity of the benefit which is permitted
  ///  under the coverage.
  FhirUnsignedInt? get allowedUnsignedInt => throw _privateConstructorUsedError;

  /// [allowedUnsignedIntElement] ("_allowedUnsignedInt") Extensions for
  ///  allowedUnsignedInt
  @JsonKey(name: '_allowedUnsignedInt')
  Element? get allowedUnsignedIntElement => throw _privateConstructorUsedError;

  /// [allowedString] The quantity of the benefit which is permitted under
  ///  the coverage.
  String? get allowedString => throw _privateConstructorUsedError;

  /// [allowedStringElement] ("_allowedString") Extensions for allowedString
  @JsonKey(name: '_allowedString')
  Element? get allowedStringElement => throw _privateConstructorUsedError;

  /// [allowedMoney] The quantity of the benefit which is permitted under the
  ///  coverage.
  Money? get allowedMoney => throw _privateConstructorUsedError;

  /// [usedUnsignedInt] The quantity of the benefit which have been consumed
  ///  to date.
  FhirUnsignedInt? get usedUnsignedInt => throw _privateConstructorUsedError;

  /// [usedUnsignedIntElement] ("_usedUnsignedInt") Extensions for
  ///  usedUnsignedInt
  @JsonKey(name: '_usedUnsignedInt')
  Element? get usedUnsignedIntElement => throw _privateConstructorUsedError;

  /// [usedMoney] The quantity of the benefit which have been consumed to
  ///  date.
  Money? get usedMoney => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExplanationOfBenefitFinancialCopyWith<ExplanationOfBenefitFinancial>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplanationOfBenefitFinancialCopyWith<$Res> {
  factory $ExplanationOfBenefitFinancialCopyWith(
          ExplanationOfBenefitFinancial value,
          $Res Function(ExplanationOfBenefitFinancial) then) =
      _$ExplanationOfBenefitFinancialCopyWithImpl<$Res,
          ExplanationOfBenefitFinancial>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      FhirUnsignedInt? allowedUnsignedInt,
      @JsonKey(name: '_allowedUnsignedInt') Element? allowedUnsignedIntElement,
      String? allowedString,
      @JsonKey(name: '_allowedString') Element? allowedStringElement,
      Money? allowedMoney,
      FhirUnsignedInt? usedUnsignedInt,
      @JsonKey(name: '_usedUnsignedInt') Element? usedUnsignedIntElement,
      Money? usedMoney});

  $CodeableConceptCopyWith<$Res> get type;
  $ElementCopyWith<$Res>? get allowedUnsignedIntElement;
  $ElementCopyWith<$Res>? get allowedStringElement;
  $MoneyCopyWith<$Res>? get allowedMoney;
  $ElementCopyWith<$Res>? get usedUnsignedIntElement;
  $MoneyCopyWith<$Res>? get usedMoney;
}

/// @nodoc
class _$ExplanationOfBenefitFinancialCopyWithImpl<$Res,
        $Val extends ExplanationOfBenefitFinancial>
    implements $ExplanationOfBenefitFinancialCopyWith<$Res> {
  _$ExplanationOfBenefitFinancialCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? allowedUnsignedInt = freezed,
    Object? allowedUnsignedIntElement = freezed,
    Object? allowedString = freezed,
    Object? allowedStringElement = freezed,
    Object? allowedMoney = freezed,
    Object? usedUnsignedInt = freezed,
    Object? usedUnsignedIntElement = freezed,
    Object? usedMoney = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      allowedUnsignedInt: freezed == allowedUnsignedInt
          ? _value.allowedUnsignedInt
          : allowedUnsignedInt // ignore: cast_nullable_to_non_nullable
              as FhirUnsignedInt?,
      allowedUnsignedIntElement: freezed == allowedUnsignedIntElement
          ? _value.allowedUnsignedIntElement
          : allowedUnsignedIntElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      allowedString: freezed == allowedString
          ? _value.allowedString
          : allowedString // ignore: cast_nullable_to_non_nullable
              as String?,
      allowedStringElement: freezed == allowedStringElement
          ? _value.allowedStringElement
          : allowedStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      allowedMoney: freezed == allowedMoney
          ? _value.allowedMoney
          : allowedMoney // ignore: cast_nullable_to_non_nullable
              as Money?,
      usedUnsignedInt: freezed == usedUnsignedInt
          ? _value.usedUnsignedInt
          : usedUnsignedInt // ignore: cast_nullable_to_non_nullable
              as FhirUnsignedInt?,
      usedUnsignedIntElement: freezed == usedUnsignedIntElement
          ? _value.usedUnsignedIntElement
          : usedUnsignedIntElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      usedMoney: freezed == usedMoney
          ? _value.usedMoney
          : usedMoney // ignore: cast_nullable_to_non_nullable
              as Money?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get allowedUnsignedIntElement {
    if (_value.allowedUnsignedIntElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.allowedUnsignedIntElement!, (value) {
      return _then(_value.copyWith(allowedUnsignedIntElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get allowedStringElement {
    if (_value.allowedStringElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.allowedStringElement!, (value) {
      return _then(_value.copyWith(allowedStringElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get allowedMoney {
    if (_value.allowedMoney == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.allowedMoney!, (value) {
      return _then(_value.copyWith(allowedMoney: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get usedUnsignedIntElement {
    if (_value.usedUnsignedIntElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.usedUnsignedIntElement!, (value) {
      return _then(_value.copyWith(usedUnsignedIntElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get usedMoney {
    if (_value.usedMoney == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.usedMoney!, (value) {
      return _then(_value.copyWith(usedMoney: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ExplanationOfBenefitFinancialImplCopyWith<$Res>
    implements $ExplanationOfBenefitFinancialCopyWith<$Res> {
  factory _$$ExplanationOfBenefitFinancialImplCopyWith(
          _$ExplanationOfBenefitFinancialImpl value,
          $Res Function(_$ExplanationOfBenefitFinancialImpl) then) =
      __$$ExplanationOfBenefitFinancialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      FhirUnsignedInt? allowedUnsignedInt,
      @JsonKey(name: '_allowedUnsignedInt') Element? allowedUnsignedIntElement,
      String? allowedString,
      @JsonKey(name: '_allowedString') Element? allowedStringElement,
      Money? allowedMoney,
      FhirUnsignedInt? usedUnsignedInt,
      @JsonKey(name: '_usedUnsignedInt') Element? usedUnsignedIntElement,
      Money? usedMoney});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $ElementCopyWith<$Res>? get allowedUnsignedIntElement;
  @override
  $ElementCopyWith<$Res>? get allowedStringElement;
  @override
  $MoneyCopyWith<$Res>? get allowedMoney;
  @override
  $ElementCopyWith<$Res>? get usedUnsignedIntElement;
  @override
  $MoneyCopyWith<$Res>? get usedMoney;
}

/// @nodoc
class __$$ExplanationOfBenefitFinancialImplCopyWithImpl<$Res>
    extends _$ExplanationOfBenefitFinancialCopyWithImpl<$Res,
        _$ExplanationOfBenefitFinancialImpl>
    implements _$$ExplanationOfBenefitFinancialImplCopyWith<$Res> {
  __$$ExplanationOfBenefitFinancialImplCopyWithImpl(
      _$ExplanationOfBenefitFinancialImpl _value,
      $Res Function(_$ExplanationOfBenefitFinancialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? allowedUnsignedInt = freezed,
    Object? allowedUnsignedIntElement = freezed,
    Object? allowedString = freezed,
    Object? allowedStringElement = freezed,
    Object? allowedMoney = freezed,
    Object? usedUnsignedInt = freezed,
    Object? usedUnsignedIntElement = freezed,
    Object? usedMoney = freezed,
  }) {
    return _then(_$ExplanationOfBenefitFinancialImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      allowedUnsignedInt: freezed == allowedUnsignedInt
          ? _value.allowedUnsignedInt
          : allowedUnsignedInt // ignore: cast_nullable_to_non_nullable
              as FhirUnsignedInt?,
      allowedUnsignedIntElement: freezed == allowedUnsignedIntElement
          ? _value.allowedUnsignedIntElement
          : allowedUnsignedIntElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      allowedString: freezed == allowedString
          ? _value.allowedString
          : allowedString // ignore: cast_nullable_to_non_nullable
              as String?,
      allowedStringElement: freezed == allowedStringElement
          ? _value.allowedStringElement
          : allowedStringElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      allowedMoney: freezed == allowedMoney
          ? _value.allowedMoney
          : allowedMoney // ignore: cast_nullable_to_non_nullable
              as Money?,
      usedUnsignedInt: freezed == usedUnsignedInt
          ? _value.usedUnsignedInt
          : usedUnsignedInt // ignore: cast_nullable_to_non_nullable
              as FhirUnsignedInt?,
      usedUnsignedIntElement: freezed == usedUnsignedIntElement
          ? _value.usedUnsignedIntElement
          : usedUnsignedIntElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      usedMoney: freezed == usedMoney
          ? _value.usedMoney
          : usedMoney // ignore: cast_nullable_to_non_nullable
              as Money?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ExplanationOfBenefitFinancialImpl
    extends _ExplanationOfBenefitFinancial {
  const _$ExplanationOfBenefitFinancialImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.allowedUnsignedInt,
      @JsonKey(name: '_allowedUnsignedInt') this.allowedUnsignedIntElement,
      this.allowedString,
      @JsonKey(name: '_allowedString') this.allowedStringElement,
      this.allowedMoney,
      this.usedUnsignedInt,
      @JsonKey(name: '_usedUnsignedInt') this.usedUnsignedIntElement,
      this.usedMoney})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$ExplanationOfBenefitFinancialImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ExplanationOfBenefitFinancialImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Classification of benefit being provided.
  @override
  final CodeableConcept type;

  /// [allowedUnsignedInt] The quantity of the benefit which is permitted
  ///  under the coverage.
  @override
  final FhirUnsignedInt? allowedUnsignedInt;

  /// [allowedUnsignedIntElement] ("_allowedUnsignedInt") Extensions for
  ///  allowedUnsignedInt
  @override
  @JsonKey(name: '_allowedUnsignedInt')
  final Element? allowedUnsignedIntElement;

  /// [allowedString] The quantity of the benefit which is permitted under
  ///  the coverage.
  @override
  final String? allowedString;

  /// [allowedStringElement] ("_allowedString") Extensions for allowedString
  @override
  @JsonKey(name: '_allowedString')
  final Element? allowedStringElement;

  /// [allowedMoney] The quantity of the benefit which is permitted under the
  ///  coverage.
  @override
  final Money? allowedMoney;

  /// [usedUnsignedInt] The quantity of the benefit which have been consumed
  ///  to date.
  @override
  final FhirUnsignedInt? usedUnsignedInt;

  /// [usedUnsignedIntElement] ("_usedUnsignedInt") Extensions for
  ///  usedUnsignedInt
  @override
  @JsonKey(name: '_usedUnsignedInt')
  final Element? usedUnsignedIntElement;

  /// [usedMoney] The quantity of the benefit which have been consumed to
  ///  date.
  @override
  final Money? usedMoney;

  @override
  String toString() {
    return 'ExplanationOfBenefitFinancial(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, allowedUnsignedInt: $allowedUnsignedInt, allowedUnsignedIntElement: $allowedUnsignedIntElement, allowedString: $allowedString, allowedStringElement: $allowedStringElement, allowedMoney: $allowedMoney, usedUnsignedInt: $usedUnsignedInt, usedUnsignedIntElement: $usedUnsignedIntElement, usedMoney: $usedMoney)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplanationOfBenefitFinancialImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.allowedUnsignedInt, allowedUnsignedInt) ||
                other.allowedUnsignedInt == allowedUnsignedInt) &&
            (identical(other.allowedUnsignedIntElement,
                    allowedUnsignedIntElement) ||
                other.allowedUnsignedIntElement == allowedUnsignedIntElement) &&
            (identical(other.allowedString, allowedString) ||
                other.allowedString == allowedString) &&
            (identical(other.allowedStringElement, allowedStringElement) ||
                other.allowedStringElement == allowedStringElement) &&
            (identical(other.allowedMoney, allowedMoney) ||
                other.allowedMoney == allowedMoney) &&
            (identical(other.usedUnsignedInt, usedUnsignedInt) ||
                other.usedUnsignedInt == usedUnsignedInt) &&
            (identical(other.usedUnsignedIntElement, usedUnsignedIntElement) ||
                other.usedUnsignedIntElement == usedUnsignedIntElement) &&
            (identical(other.usedMoney, usedMoney) ||
                other.usedMoney == usedMoney));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      allowedUnsignedInt,
      allowedUnsignedIntElement,
      allowedString,
      allowedStringElement,
      allowedMoney,
      usedUnsignedInt,
      usedUnsignedIntElement,
      usedMoney);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplanationOfBenefitFinancialImplCopyWith<
          _$ExplanationOfBenefitFinancialImpl>
      get copyWith => __$$ExplanationOfBenefitFinancialImplCopyWithImpl<
          _$ExplanationOfBenefitFinancialImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ExplanationOfBenefitFinancialImplToJson(
      this,
    );
  }
}

abstract class _ExplanationOfBenefitFinancial
    extends ExplanationOfBenefitFinancial {
  const factory _ExplanationOfBenefitFinancial(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableConcept type,
      final FhirUnsignedInt? allowedUnsignedInt,
      @JsonKey(name: '_allowedUnsignedInt')
      final Element? allowedUnsignedIntElement,
      final String? allowedString,
      @JsonKey(name: '_allowedString') final Element? allowedStringElement,
      final Money? allowedMoney,
      final FhirUnsignedInt? usedUnsignedInt,
      @JsonKey(name: '_usedUnsignedInt') final Element? usedUnsignedIntElement,
      final Money? usedMoney}) = _$ExplanationOfBenefitFinancialImpl;
  const _ExplanationOfBenefitFinancial._() : super._();

  factory _ExplanationOfBenefitFinancial.fromJson(Map<String, dynamic> json) =
      _$ExplanationOfBenefitFinancialImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Classification of benefit being provided.
  CodeableConcept get type;
  @override

  /// [allowedUnsignedInt] The quantity of the benefit which is permitted
  ///  under the coverage.
  FhirUnsignedInt? get allowedUnsignedInt;
  @override

  /// [allowedUnsignedIntElement] ("_allowedUnsignedInt") Extensions for
  ///  allowedUnsignedInt
  @JsonKey(name: '_allowedUnsignedInt')
  Element? get allowedUnsignedIntElement;
  @override

  /// [allowedString] The quantity of the benefit which is permitted under
  ///  the coverage.
  String? get allowedString;
  @override

  /// [allowedStringElement] ("_allowedString") Extensions for allowedString
  @JsonKey(name: '_allowedString')
  Element? get allowedStringElement;
  @override

  /// [allowedMoney] The quantity of the benefit which is permitted under the
  ///  coverage.
  Money? get allowedMoney;
  @override

  /// [usedUnsignedInt] The quantity of the benefit which have been consumed
  ///  to date.
  FhirUnsignedInt? get usedUnsignedInt;
  @override

  /// [usedUnsignedIntElement] ("_usedUnsignedInt") Extensions for
  ///  usedUnsignedInt
  @JsonKey(name: '_usedUnsignedInt')
  Element? get usedUnsignedIntElement;
  @override

  /// [usedMoney] The quantity of the benefit which have been consumed to
  ///  date.
  Money? get usedMoney;
  @override
  @JsonKey(ignore: true)
  _$$ExplanationOfBenefitFinancialImplCopyWith<
          _$ExplanationOfBenefitFinancialImpl>
      get copyWith => throw _privateConstructorUsedError;
}

InsurancePlan _$InsurancePlanFromJson(Map<String, dynamic> json) {
  return _InsurancePlan.fromJson(json);
}

/// @nodoc
mixin _$InsurancePlan {
  /// [resourceType] This is a InsurancePlan resource
  @JsonKey(unknownEnumValue: R6ResourceType.InsurancePlan)
  R6ResourceType get resourceType => throw _privateConstructorUsedError;

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  FhirMeta? get meta => throw _privateConstructorUsedError;

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// [language] The base language in which the resource is written.
  FhirCode? get language => throw _privateConstructorUsedError;

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  Narrative? get text => throw _privateConstructorUsedError;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [identifier] Identifiers, such as the plan ID and/or group ID
  ///  associated with the insurance plan.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// [type] Type of plan. For example, "Platinum" or "High Deductable".
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [product] The product that this plan is available under.
  Reference? get product => throw _privateConstructorUsedError;

  /// [coverageArea] The geographic region in which a health insurance plan's
  ///  benefits apply.
  List<Reference>? get coverageArea => throw _privateConstructorUsedError;

  /// [network] Reference to the network that providing the type of coverage.
  List<Reference>? get network => throw _privateConstructorUsedError;

  /// [generalCost] Overall costs associated with the plan.
  List<InsurancePlanGeneralCost>? get generalCost =>
      throw _privateConstructorUsedError;

  /// [specificCost] Costs associated with the coverage provided by the
  ///  product-plan.
  List<InsurancePlanSpecificCost>? get specificCost =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InsurancePlanCopyWith<InsurancePlan> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InsurancePlanCopyWith<$Res> {
  factory $InsurancePlanCopyWith(
          InsurancePlan value, $Res Function(InsurancePlan) then) =
      _$InsurancePlanCopyWithImpl<$Res, InsurancePlan>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.InsurancePlan)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      CodeableConcept? type,
      Reference? product,
      List<Reference>? coverageArea,
      List<Reference>? network,
      List<InsurancePlanGeneralCost>? generalCost,
      List<InsurancePlanSpecificCost>? specificCost});

  $FhirMetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $CodeableConceptCopyWith<$Res>? get type;
  $ReferenceCopyWith<$Res>? get product;
}

/// @nodoc
class _$InsurancePlanCopyWithImpl<$Res, $Val extends InsurancePlan>
    implements $InsurancePlanCopyWith<$Res> {
  _$InsurancePlanCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? product = freezed,
    Object? coverageArea = freezed,
    Object? network = freezed,
    Object? generalCost = freezed,
    Object? specificCost = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      product: freezed == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as Reference?,
      coverageArea: freezed == coverageArea
          ? _value.coverageArea
          : coverageArea // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      network: freezed == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      generalCost: freezed == generalCost
          ? _value.generalCost
          : generalCost // ignore: cast_nullable_to_non_nullable
              as List<InsurancePlanGeneralCost>?,
      specificCost: freezed == specificCost
          ? _value.specificCost
          : specificCost // ignore: cast_nullable_to_non_nullable
              as List<InsurancePlanSpecificCost>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FhirMetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $FhirMetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get product {
    if (_value.product == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.product!, (value) {
      return _then(_value.copyWith(product: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$InsurancePlanImplCopyWith<$Res>
    implements $InsurancePlanCopyWith<$Res> {
  factory _$$InsurancePlanImplCopyWith(
          _$InsurancePlanImpl value, $Res Function(_$InsurancePlanImpl) then) =
      __$$InsurancePlanImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.InsurancePlan)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      CodeableConcept? type,
      Reference? product,
      List<Reference>? coverageArea,
      List<Reference>? network,
      List<InsurancePlanGeneralCost>? generalCost,
      List<InsurancePlanSpecificCost>? specificCost});

  @override
  $FhirMetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ReferenceCopyWith<$Res>? get product;
}

/// @nodoc
class __$$InsurancePlanImplCopyWithImpl<$Res>
    extends _$InsurancePlanCopyWithImpl<$Res, _$InsurancePlanImpl>
    implements _$$InsurancePlanImplCopyWith<$Res> {
  __$$InsurancePlanImplCopyWithImpl(
      _$InsurancePlanImpl _value, $Res Function(_$InsurancePlanImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? type = freezed,
    Object? product = freezed,
    Object? coverageArea = freezed,
    Object? network = freezed,
    Object? generalCost = freezed,
    Object? specificCost = freezed,
  }) {
    return _then(_$InsurancePlanImpl(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      product: freezed == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as Reference?,
      coverageArea: freezed == coverageArea
          ? _value._coverageArea
          : coverageArea // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      network: freezed == network
          ? _value._network
          : network // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      generalCost: freezed == generalCost
          ? _value._generalCost
          : generalCost // ignore: cast_nullable_to_non_nullable
              as List<InsurancePlanGeneralCost>?,
      specificCost: freezed == specificCost
          ? _value._specificCost
          : specificCost // ignore: cast_nullable_to_non_nullable
              as List<InsurancePlanSpecificCost>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$InsurancePlanImpl extends _InsurancePlan {
  const _$InsurancePlanImpl(
      {@JsonKey(unknownEnumValue: R6ResourceType.InsurancePlan)
      this.resourceType = R6ResourceType.InsurancePlan,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.type,
      this.product,
      final List<Reference>? coverageArea,
      final List<Reference>? network,
      final List<InsurancePlanGeneralCost>? generalCost,
      final List<InsurancePlanSpecificCost>? specificCost})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _coverageArea = coverageArea,
        _network = network,
        _generalCost = generalCost,
        _specificCost = specificCost,
        super._();

  factory _$InsurancePlanImpl.fromJson(Map<String, dynamic> json) =>
      _$$InsurancePlanImplFromJson(json);

  /// [resourceType] This is a InsurancePlan resource
  @override
  @JsonKey(unknownEnumValue: R6ResourceType.InsurancePlan)
  final R6ResourceType resourceType;

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  @override
  final FhirMeta? meta;

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  @override
  final FhirUri? implicitRules;

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// [language] The base language in which the resource is written.
  @override
  final FhirCode? language;

  /// [languageElement] ("_language") Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  @override
  final Narrative? text;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  final List<Resource>? _contained;

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [identifier] Identifiers, such as the plan ID and/or group ID
  ///  associated with the insurance plan.
  final List<Identifier>? _identifier;

  /// [identifier] Identifiers, such as the plan ID and/or group ID
  ///  associated with the insurance plan.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Type of plan. For example, "Platinum" or "High Deductable".
  @override
  final CodeableConcept? type;

  /// [product] The product that this plan is available under.
  @override
  final Reference? product;

  /// [coverageArea] The geographic region in which a health insurance plan's
  ///  benefits apply.
  final List<Reference>? _coverageArea;

  /// [coverageArea] The geographic region in which a health insurance plan's
  ///  benefits apply.
  @override
  List<Reference>? get coverageArea {
    final value = _coverageArea;
    if (value == null) return null;
    if (_coverageArea is EqualUnmodifiableListView) return _coverageArea;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [network] Reference to the network that providing the type of coverage.
  final List<Reference>? _network;

  /// [network] Reference to the network that providing the type of coverage.
  @override
  List<Reference>? get network {
    final value = _network;
    if (value == null) return null;
    if (_network is EqualUnmodifiableListView) return _network;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [generalCost] Overall costs associated with the plan.
  final List<InsurancePlanGeneralCost>? _generalCost;

  /// [generalCost] Overall costs associated with the plan.
  @override
  List<InsurancePlanGeneralCost>? get generalCost {
    final value = _generalCost;
    if (value == null) return null;
    if (_generalCost is EqualUnmodifiableListView) return _generalCost;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [specificCost] Costs associated with the coverage provided by the
  ///  product-plan.
  final List<InsurancePlanSpecificCost>? _specificCost;

  /// [specificCost] Costs associated with the coverage provided by the
  ///  product-plan.
  @override
  List<InsurancePlanSpecificCost>? get specificCost {
    final value = _specificCost;
    if (value == null) return null;
    if (_specificCost is EqualUnmodifiableListView) return _specificCost;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'InsurancePlan(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, type: $type, product: $product, coverageArea: $coverageArea, network: $network, generalCost: $generalCost, specificCost: $specificCost)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsurancePlanImpl &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.product, product) || other.product == product) &&
            const DeepCollectionEquality()
                .equals(other._coverageArea, _coverageArea) &&
            const DeepCollectionEquality().equals(other._network, _network) &&
            const DeepCollectionEquality()
                .equals(other._generalCost, _generalCost) &&
            const DeepCollectionEquality()
                .equals(other._specificCost, _specificCost));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      resourceType,
      id,
      meta,
      implicitRules,
      implicitRulesElement,
      language,
      languageElement,
      text,
      const DeepCollectionEquality().hash(_contained),
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      const DeepCollectionEquality().hash(_identifier),
      type,
      product,
      const DeepCollectionEquality().hash(_coverageArea),
      const DeepCollectionEquality().hash(_network),
      const DeepCollectionEquality().hash(_generalCost),
      const DeepCollectionEquality().hash(_specificCost));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InsurancePlanImplCopyWith<_$InsurancePlanImpl> get copyWith =>
      __$$InsurancePlanImplCopyWithImpl<_$InsurancePlanImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InsurancePlanImplToJson(
      this,
    );
  }
}

abstract class _InsurancePlan extends InsurancePlan {
  const factory _InsurancePlan(
          {@JsonKey(unknownEnumValue: R6ResourceType.InsurancePlan)
          final R6ResourceType resourceType,
          final FhirId? id,
          final FhirMeta? meta,
          final FhirUri? implicitRules,
          @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
          final FhirCode? language,
          @JsonKey(name: '_language') final Element? languageElement,
          final Narrative? text,
          final List<Resource>? contained,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final List<Identifier>? identifier,
          final CodeableConcept? type,
          final Reference? product,
          final List<Reference>? coverageArea,
          final List<Reference>? network,
          final List<InsurancePlanGeneralCost>? generalCost,
          final List<InsurancePlanSpecificCost>? specificCost}) =
      _$InsurancePlanImpl;
  const _InsurancePlan._() : super._();

  factory _InsurancePlan.fromJson(Map<String, dynamic> json) =
      _$InsurancePlanImpl.fromJson;

  @override

  /// [resourceType] This is a InsurancePlan resource
  @JsonKey(unknownEnumValue: R6ResourceType.InsurancePlan)
  R6ResourceType get resourceType;
  @override

  /// [id] The logical id of the resource, as used in the URL for the
  ///  resource. Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// [meta] The metadata about the resource. This is content that is
  ///  maintained by the infrastructure. Changes to the content might not
  ///  always be associated with version changes to the resource.
  FhirMeta? get meta;
  @override

  /// [implicitRules] A reference to a set of rules that were followed when
  ///  the resource was constructed, and which must be understood when
  ///  processing the content. Often, this is a reference to an
  ///  implementation guide that defines the special rules along with other
  ///  profiles etc.
  FhirUri? get implicitRules;
  @override

  /// [implicitRulesElement] ("_implicitRules") Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// [language] The base language in which the resource is written.
  FhirCode? get language;
  @override

  /// [languageElement] ("_language") Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// [text] A human-readable narrative that contains a summary of the
  ///  resource and can be used to represent the content of the resource to a
  ///  human. The narrative need not encode all the structured data, but is
  ///  required to contain sufficient detail to make it "clinically safe" for
  ///  a human to just read the narrative. Resource definitions may define
  ///  what content should be represented in the narrative to ensure clinical
  ///  safety.
  Narrative? get text;
  @override

  /// [contained] These resources do not have an independent existence apart
  ///  from the resource that contains them - they cannot be identified
  ///  independently, nor can they have their own independent transaction
  ///  scope. This is allowed to be a Parameters resource if and only if it
  ///  is referenced by a resource that provides context/meaning.
  List<Resource>? get contained;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the resource.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the resource and that
  ///  modifies the understanding of the element that contains it and/or the
  ///  understanding of the containing element's descendants. Usually
  ///  modifier elements provide negation or qualification. To make the use
  ///  of extensions safe and managable, there is a strict set of governance
  ///  applied to the definition and use of extensions. Though any
  ///  implementer is allowed to define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension. Applications processing a resource are required to check
  ///  for modifier extensions.Modifier extensions SHALL NOT change the
  ///  meaning of any elements on Resource or DomainResource (including
  ///  cannot change the meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [identifier] Identifiers, such as the plan ID and/or group ID
  ///  associated with the insurance plan.
  List<Identifier>? get identifier;
  @override

  /// [type] Type of plan. For example, "Platinum" or "High Deductable".
  CodeableConcept? get type;
  @override

  /// [product] The product that this plan is available under.
  Reference? get product;
  @override

  /// [coverageArea] The geographic region in which a health insurance plan's
  ///  benefits apply.
  List<Reference>? get coverageArea;
  @override

  /// [network] Reference to the network that providing the type of coverage.
  List<Reference>? get network;
  @override

  /// [generalCost] Overall costs associated with the plan.
  List<InsurancePlanGeneralCost>? get generalCost;
  @override

  /// [specificCost] Costs associated with the coverage provided by the
  ///  product-plan.
  List<InsurancePlanSpecificCost>? get specificCost;
  @override
  @JsonKey(ignore: true)
  _$$InsurancePlanImplCopyWith<_$InsurancePlanImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

InsurancePlanGeneralCost _$InsurancePlanGeneralCostFromJson(
    Map<String, dynamic> json) {
  return _InsurancePlanGeneralCost.fromJson(json);
}

/// @nodoc
mixin _$InsurancePlanGeneralCost {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Type of cost.
  CodeableConcept? get type => throw _privateConstructorUsedError;

  /// [groupSize] Number of participants enrolled in the plan.
  FhirPositiveInt? get groupSize => throw _privateConstructorUsedError;

  /// [groupSizeElement] ("_groupSize") Extensions for groupSize
  @JsonKey(name: '_groupSize')
  Element? get groupSizeElement => throw _privateConstructorUsedError;

  /// [cost] Value of the cost.
  Money? get cost => throw _privateConstructorUsedError;

  /// [comment] Additional information about the general costs associated
  ///  with this plan.
  String? get comment => throw _privateConstructorUsedError;

  /// [commentElement] ("_comment") Extensions for comment
  @JsonKey(name: '_comment')
  Element? get commentElement => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InsurancePlanGeneralCostCopyWith<InsurancePlanGeneralCost> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InsurancePlanGeneralCostCopyWith<$Res> {
  factory $InsurancePlanGeneralCostCopyWith(InsurancePlanGeneralCost value,
          $Res Function(InsurancePlanGeneralCost) then) =
      _$InsurancePlanGeneralCostCopyWithImpl<$Res, InsurancePlanGeneralCost>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      FhirPositiveInt? groupSize,
      @JsonKey(name: '_groupSize') Element? groupSizeElement,
      Money? cost,
      String? comment,
      @JsonKey(name: '_comment') Element? commentElement});

  $CodeableConceptCopyWith<$Res>? get type;
  $ElementCopyWith<$Res>? get groupSizeElement;
  $MoneyCopyWith<$Res>? get cost;
  $ElementCopyWith<$Res>? get commentElement;
}

/// @nodoc
class _$InsurancePlanGeneralCostCopyWithImpl<$Res,
        $Val extends InsurancePlanGeneralCost>
    implements $InsurancePlanGeneralCostCopyWith<$Res> {
  _$InsurancePlanGeneralCostCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? groupSize = freezed,
    Object? groupSizeElement = freezed,
    Object? cost = freezed,
    Object? comment = freezed,
    Object? commentElement = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      groupSize: freezed == groupSize
          ? _value.groupSize
          : groupSize // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      groupSizeElement: freezed == groupSizeElement
          ? _value.groupSizeElement
          : groupSizeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      cost: freezed == cost
          ? _value.cost
          : cost // ignore: cast_nullable_to_non_nullable
              as Money?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
      commentElement: freezed == commentElement
          ? _value.commentElement
          : commentElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get type {
    if (_value.type == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.type!, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get groupSizeElement {
    if (_value.groupSizeElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.groupSizeElement!, (value) {
      return _then(_value.copyWith(groupSizeElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MoneyCopyWith<$Res>? get cost {
    if (_value.cost == null) {
      return null;
    }

    return $MoneyCopyWith<$Res>(_value.cost!, (value) {
      return _then(_value.copyWith(cost: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get commentElement {
    if (_value.commentElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.commentElement!, (value) {
      return _then(_value.copyWith(commentElement: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$InsurancePlanGeneralCostImplCopyWith<$Res>
    implements $InsurancePlanGeneralCostCopyWith<$Res> {
  factory _$$InsurancePlanGeneralCostImplCopyWith(
          _$InsurancePlanGeneralCostImpl value,
          $Res Function(_$InsurancePlanGeneralCostImpl) then) =
      __$$InsurancePlanGeneralCostImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept? type,
      FhirPositiveInt? groupSize,
      @JsonKey(name: '_groupSize') Element? groupSizeElement,
      Money? cost,
      String? comment,
      @JsonKey(name: '_comment') Element? commentElement});

  @override
  $CodeableConceptCopyWith<$Res>? get type;
  @override
  $ElementCopyWith<$Res>? get groupSizeElement;
  @override
  $MoneyCopyWith<$Res>? get cost;
  @override
  $ElementCopyWith<$Res>? get commentElement;
}

/// @nodoc
class __$$InsurancePlanGeneralCostImplCopyWithImpl<$Res>
    extends _$InsurancePlanGeneralCostCopyWithImpl<$Res,
        _$InsurancePlanGeneralCostImpl>
    implements _$$InsurancePlanGeneralCostImplCopyWith<$Res> {
  __$$InsurancePlanGeneralCostImplCopyWithImpl(
      _$InsurancePlanGeneralCostImpl _value,
      $Res Function(_$InsurancePlanGeneralCostImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = freezed,
    Object? groupSize = freezed,
    Object? groupSizeElement = freezed,
    Object? cost = freezed,
    Object? comment = freezed,
    Object? commentElement = freezed,
  }) {
    return _then(_$InsurancePlanGeneralCostImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      groupSize: freezed == groupSize
          ? _value.groupSize
          : groupSize // ignore: cast_nullable_to_non_nullable
              as FhirPositiveInt?,
      groupSizeElement: freezed == groupSizeElement
          ? _value.groupSizeElement
          : groupSizeElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      cost: freezed == cost
          ? _value.cost
          : cost // ignore: cast_nullable_to_non_nullable
              as Money?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
      commentElement: freezed == commentElement
          ? _value.commentElement
          : commentElement // ignore: cast_nullable_to_non_nullable
              as Element?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$InsurancePlanGeneralCostImpl extends _InsurancePlanGeneralCost {
  const _$InsurancePlanGeneralCostImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.type,
      this.groupSize,
      @JsonKey(name: '_groupSize') this.groupSizeElement,
      this.cost,
      this.comment,
      @JsonKey(name: '_comment') this.commentElement})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$InsurancePlanGeneralCostImpl.fromJson(Map<String, dynamic> json) =>
      _$$InsurancePlanGeneralCostImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Type of cost.
  @override
  final CodeableConcept? type;

  /// [groupSize] Number of participants enrolled in the plan.
  @override
  final FhirPositiveInt? groupSize;

  /// [groupSizeElement] ("_groupSize") Extensions for groupSize
  @override
  @JsonKey(name: '_groupSize')
  final Element? groupSizeElement;

  /// [cost] Value of the cost.
  @override
  final Money? cost;

  /// [comment] Additional information about the general costs associated
  ///  with this plan.
  @override
  final String? comment;

  /// [commentElement] ("_comment") Extensions for comment
  @override
  @JsonKey(name: '_comment')
  final Element? commentElement;

  @override
  String toString() {
    return 'InsurancePlanGeneralCost(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, groupSize: $groupSize, groupSizeElement: $groupSizeElement, cost: $cost, comment: $comment, commentElement: $commentElement)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsurancePlanGeneralCostImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.groupSize, groupSize) ||
                other.groupSize == groupSize) &&
            (identical(other.groupSizeElement, groupSizeElement) ||
                other.groupSizeElement == groupSizeElement) &&
            (identical(other.cost, cost) || other.cost == cost) &&
            (identical(other.comment, comment) || other.comment == comment) &&
            (identical(other.commentElement, commentElement) ||
                other.commentElement == commentElement));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      groupSize,
      groupSizeElement,
      cost,
      comment,
      commentElement);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InsurancePlanGeneralCostImplCopyWith<_$InsurancePlanGeneralCostImpl>
      get copyWith => __$$InsurancePlanGeneralCostImplCopyWithImpl<
          _$InsurancePlanGeneralCostImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InsurancePlanGeneralCostImplToJson(
      this,
    );
  }
}

abstract class _InsurancePlanGeneralCost extends InsurancePlanGeneralCost {
  const factory _InsurancePlanGeneralCost(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          final CodeableConcept? type,
          final FhirPositiveInt? groupSize,
          @JsonKey(name: '_groupSize') final Element? groupSizeElement,
          final Money? cost,
          final String? comment,
          @JsonKey(name: '_comment') final Element? commentElement}) =
      _$InsurancePlanGeneralCostImpl;
  const _InsurancePlanGeneralCost._() : super._();

  factory _InsurancePlanGeneralCost.fromJson(Map<String, dynamic> json) =
      _$InsurancePlanGeneralCostImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Type of cost.
  CodeableConcept? get type;
  @override

  /// [groupSize] Number of participants enrolled in the plan.
  FhirPositiveInt? get groupSize;
  @override

  /// [groupSizeElement] ("_groupSize") Extensions for groupSize
  @JsonKey(name: '_groupSize')
  Element? get groupSizeElement;
  @override

  /// [cost] Value of the cost.
  Money? get cost;
  @override

  /// [comment] Additional information about the general costs associated
  ///  with this plan.
  String? get comment;
  @override

  /// [commentElement] ("_comment") Extensions for comment
  @JsonKey(name: '_comment')
  Element? get commentElement;
  @override
  @JsonKey(ignore: true)
  _$$InsurancePlanGeneralCostImplCopyWith<_$InsurancePlanGeneralCostImpl>
      get copyWith => throw _privateConstructorUsedError;
}

InsurancePlanSpecificCost _$InsurancePlanSpecificCostFromJson(
    Map<String, dynamic> json) {
  return _InsurancePlanSpecificCost.fromJson(json);
}

/// @nodoc
mixin _$InsurancePlanSpecificCost {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [category] General category of benefit (Medical; Dental; Vision; Drug;
  ///  Mental Health; Substance Abuse; Hospice, Home Health).
  CodeableConcept get category => throw _privateConstructorUsedError;

  /// [benefit] List of the specific benefits under this category of benefit.
  List<InsurancePlanBenefit>? get benefit => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InsurancePlanSpecificCostCopyWith<InsurancePlanSpecificCost> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InsurancePlanSpecificCostCopyWith<$Res> {
  factory $InsurancePlanSpecificCostCopyWith(InsurancePlanSpecificCost value,
          $Res Function(InsurancePlanSpecificCost) then) =
      _$InsurancePlanSpecificCostCopyWithImpl<$Res, InsurancePlanSpecificCost>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept category,
      List<InsurancePlanBenefit>? benefit});

  $CodeableConceptCopyWith<$Res> get category;
}

/// @nodoc
class _$InsurancePlanSpecificCostCopyWithImpl<$Res,
        $Val extends InsurancePlanSpecificCost>
    implements $InsurancePlanSpecificCostCopyWith<$Res> {
  _$InsurancePlanSpecificCostCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? category = null,
    Object? benefit = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      benefit: freezed == benefit
          ? _value.benefit
          : benefit // ignore: cast_nullable_to_non_nullable
              as List<InsurancePlanBenefit>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get category {
    return $CodeableConceptCopyWith<$Res>(_value.category, (value) {
      return _then(_value.copyWith(category: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$InsurancePlanSpecificCostImplCopyWith<$Res>
    implements $InsurancePlanSpecificCostCopyWith<$Res> {
  factory _$$InsurancePlanSpecificCostImplCopyWith(
          _$InsurancePlanSpecificCostImpl value,
          $Res Function(_$InsurancePlanSpecificCostImpl) then) =
      __$$InsurancePlanSpecificCostImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept category,
      List<InsurancePlanBenefit>? benefit});

  @override
  $CodeableConceptCopyWith<$Res> get category;
}

/// @nodoc
class __$$InsurancePlanSpecificCostImplCopyWithImpl<$Res>
    extends _$InsurancePlanSpecificCostCopyWithImpl<$Res,
        _$InsurancePlanSpecificCostImpl>
    implements _$$InsurancePlanSpecificCostImplCopyWith<$Res> {
  __$$InsurancePlanSpecificCostImplCopyWithImpl(
      _$InsurancePlanSpecificCostImpl _value,
      $Res Function(_$InsurancePlanSpecificCostImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? category = null,
    Object? benefit = freezed,
  }) {
    return _then(_$InsurancePlanSpecificCostImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      benefit: freezed == benefit
          ? _value._benefit
          : benefit // ignore: cast_nullable_to_non_nullable
              as List<InsurancePlanBenefit>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$InsurancePlanSpecificCostImpl extends _InsurancePlanSpecificCost {
  const _$InsurancePlanSpecificCostImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.category,
      final List<InsurancePlanBenefit>? benefit})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _benefit = benefit,
        super._();

  factory _$InsurancePlanSpecificCostImpl.fromJson(Map<String, dynamic> json) =>
      _$$InsurancePlanSpecificCostImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [category] General category of benefit (Medical; Dental; Vision; Drug;
  ///  Mental Health; Substance Abuse; Hospice, Home Health).
  @override
  final CodeableConcept category;

  /// [benefit] List of the specific benefits under this category of benefit.
  final List<InsurancePlanBenefit>? _benefit;

  /// [benefit] List of the specific benefits under this category of benefit.
  @override
  List<InsurancePlanBenefit>? get benefit {
    final value = _benefit;
    if (value == null) return null;
    if (_benefit is EqualUnmodifiableListView) return _benefit;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'InsurancePlanSpecificCost(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, category: $category, benefit: $benefit)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsurancePlanSpecificCostImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.category, category) ||
                other.category == category) &&
            const DeepCollectionEquality().equals(other._benefit, _benefit));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      category,
      const DeepCollectionEquality().hash(_benefit));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InsurancePlanSpecificCostImplCopyWith<_$InsurancePlanSpecificCostImpl>
      get copyWith => __$$InsurancePlanSpecificCostImplCopyWithImpl<
          _$InsurancePlanSpecificCostImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InsurancePlanSpecificCostImplToJson(
      this,
    );
  }
}

abstract class _InsurancePlanSpecificCost extends InsurancePlanSpecificCost {
  const factory _InsurancePlanSpecificCost(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept category,
          final List<InsurancePlanBenefit>? benefit}) =
      _$InsurancePlanSpecificCostImpl;
  const _InsurancePlanSpecificCost._() : super._();

  factory _InsurancePlanSpecificCost.fromJson(Map<String, dynamic> json) =
      _$InsurancePlanSpecificCostImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [category] General category of benefit (Medical; Dental; Vision; Drug;
  ///  Mental Health; Substance Abuse; Hospice, Home Health).
  CodeableConcept get category;
  @override

  /// [benefit] List of the specific benefits under this category of benefit.
  List<InsurancePlanBenefit>? get benefit;
  @override
  @JsonKey(ignore: true)
  _$$InsurancePlanSpecificCostImplCopyWith<_$InsurancePlanSpecificCostImpl>
      get copyWith => throw _privateConstructorUsedError;
}

InsurancePlanBenefit _$InsurancePlanBenefitFromJson(Map<String, dynamic> json) {
  return _InsurancePlanBenefit.fromJson(json);
}

/// @nodoc
mixin _$InsurancePlanBenefit {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Type of specific benefit (preventative; primary care office
  ///  visit; speciality office visit; hospitalization; emergency room;
  ///  urgent care).
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [cost] List of the costs associated with a specific benefit.
  List<InsurancePlanCost>? get cost => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InsurancePlanBenefitCopyWith<InsurancePlanBenefit> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InsurancePlanBenefitCopyWith<$Res> {
  factory $InsurancePlanBenefitCopyWith(InsurancePlanBenefit value,
          $Res Function(InsurancePlanBenefit) then) =
      _$InsurancePlanBenefitCopyWithImpl<$Res, InsurancePlanBenefit>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      List<InsurancePlanCost>? cost});

  $CodeableConceptCopyWith<$Res> get type;
}

/// @nodoc
class _$InsurancePlanBenefitCopyWithImpl<$Res,
        $Val extends InsurancePlanBenefit>
    implements $InsurancePlanBenefitCopyWith<$Res> {
  _$InsurancePlanBenefitCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? cost = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      cost: freezed == cost
          ? _value.cost
          : cost // ignore: cast_nullable_to_non_nullable
              as List<InsurancePlanCost>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$InsurancePlanBenefitImplCopyWith<$Res>
    implements $InsurancePlanBenefitCopyWith<$Res> {
  factory _$$InsurancePlanBenefitImplCopyWith(_$InsurancePlanBenefitImpl value,
          $Res Function(_$InsurancePlanBenefitImpl) then) =
      __$$InsurancePlanBenefitImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      List<InsurancePlanCost>? cost});

  @override
  $CodeableConceptCopyWith<$Res> get type;
}

/// @nodoc
class __$$InsurancePlanBenefitImplCopyWithImpl<$Res>
    extends _$InsurancePlanBenefitCopyWithImpl<$Res, _$InsurancePlanBenefitImpl>
    implements _$$InsurancePlanBenefitImplCopyWith<$Res> {
  __$$InsurancePlanBenefitImplCopyWithImpl(_$InsurancePlanBenefitImpl _value,
      $Res Function(_$InsurancePlanBenefitImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? cost = freezed,
  }) {
    return _then(_$InsurancePlanBenefitImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      cost: freezed == cost
          ? _value._cost
          : cost // ignore: cast_nullable_to_non_nullable
              as List<InsurancePlanCost>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$InsurancePlanBenefitImpl extends _InsurancePlanBenefit {
  const _$InsurancePlanBenefitImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      final List<InsurancePlanCost>? cost})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _cost = cost,
        super._();

  factory _$InsurancePlanBenefitImpl.fromJson(Map<String, dynamic> json) =>
      _$$InsurancePlanBenefitImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Type of specific benefit (preventative; primary care office
  ///  visit; speciality office visit; hospitalization; emergency room;
  ///  urgent care).
  @override
  final CodeableConcept type;

  /// [cost] List of the costs associated with a specific benefit.
  final List<InsurancePlanCost>? _cost;

  /// [cost] List of the costs associated with a specific benefit.
  @override
  List<InsurancePlanCost>? get cost {
    final value = _cost;
    if (value == null) return null;
    if (_cost is EqualUnmodifiableListView) return _cost;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'InsurancePlanBenefit(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, cost: $cost)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsurancePlanBenefitImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality().equals(other._cost, _cost));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      const DeepCollectionEquality().hash(_cost));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InsurancePlanBenefitImplCopyWith<_$InsurancePlanBenefitImpl>
      get copyWith =>
          __$$InsurancePlanBenefitImplCopyWithImpl<_$InsurancePlanBenefitImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InsurancePlanBenefitImplToJson(
      this,
    );
  }
}

abstract class _InsurancePlanBenefit extends InsurancePlanBenefit {
  const factory _InsurancePlanBenefit(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableConcept type,
      final List<InsurancePlanCost>? cost}) = _$InsurancePlanBenefitImpl;
  const _InsurancePlanBenefit._() : super._();

  factory _InsurancePlanBenefit.fromJson(Map<String, dynamic> json) =
      _$InsurancePlanBenefitImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Type of specific benefit (preventative; primary care office
  ///  visit; speciality office visit; hospitalization; emergency room;
  ///  urgent care).
  CodeableConcept get type;
  @override

  /// [cost] List of the costs associated with a specific benefit.
  List<InsurancePlanCost>? get cost;
  @override
  @JsonKey(ignore: true)
  _$$InsurancePlanBenefitImplCopyWith<_$InsurancePlanBenefitImpl>
      get copyWith => throw _privateConstructorUsedError;
}

InsurancePlanCost _$InsurancePlanCostFromJson(Map<String, dynamic> json) {
  return _InsurancePlanCost.fromJson(json);
}

/// @nodoc
mixin _$InsurancePlanCost {
  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id => throw _privateConstructorUsedError;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Type of cost (copay; individual cap; family cap; coinsurance;
  ///  deductible).
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [applicability] Whether the cost applies to in-network or
  ///  out-of-network providers (in-network; out-of-network; other).
  CodeableConcept? get applicability => throw _privateConstructorUsedError;

  /// [qualifier] Additional information about the cost, such as information
  ///  about funding sources (e.g. HSA, HRA, FSA, RRA).
  List<CodeableConcept>? get qualifier => throw _privateConstructorUsedError;

  /// [value] The actual cost value. (some of the costs may be represented as
  ///  percentages rather than currency, e.g. 10% coinsurance).
  Quantity? get value => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InsurancePlanCostCopyWith<InsurancePlanCost> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InsurancePlanCostCopyWith<$Res> {
  factory $InsurancePlanCostCopyWith(
          InsurancePlanCost value, $Res Function(InsurancePlanCost) then) =
      _$InsurancePlanCostCopyWithImpl<$Res, InsurancePlanCost>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? applicability,
      List<CodeableConcept>? qualifier,
      Quantity? value});

  $CodeableConceptCopyWith<$Res> get type;
  $CodeableConceptCopyWith<$Res>? get applicability;
  $QuantityCopyWith<$Res>? get value;
}

/// @nodoc
class _$InsurancePlanCostCopyWithImpl<$Res, $Val extends InsurancePlanCost>
    implements $InsurancePlanCostCopyWith<$Res> {
  _$InsurancePlanCostCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? applicability = freezed,
    Object? qualifier = freezed,
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      applicability: freezed == applicability
          ? _value.applicability
          : applicability // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      qualifier: freezed == qualifier
          ? _value.qualifier
          : qualifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Quantity?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get applicability {
    if (_value.applicability == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.applicability!, (value) {
      return _then(_value.copyWith(applicability: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get value {
    if (_value.value == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.value!, (value) {
      return _then(_value.copyWith(value: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$InsurancePlanCostImplCopyWith<$Res>
    implements $InsurancePlanCostCopyWith<$Res> {
  factory _$$InsurancePlanCostImplCopyWith(_$InsurancePlanCostImpl value,
          $Res Function(_$InsurancePlanCostImpl) then) =
      __$$InsurancePlanCostImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      CodeableConcept? applicability,
      List<CodeableConcept>? qualifier,
      Quantity? value});

  @override
  $CodeableConceptCopyWith<$Res> get type;
  @override
  $CodeableConceptCopyWith<$Res>? get applicability;
  @override
  $QuantityCopyWith<$Res>? get value;
}

/// @nodoc
class __$$InsurancePlanCostImplCopyWithImpl<$Res>
    extends _$InsurancePlanCostCopyWithImpl<$Res, _$InsurancePlanCostImpl>
    implements _$$InsurancePlanCostImplCopyWith<$Res> {
  __$$InsurancePlanCostImplCopyWithImpl(_$InsurancePlanCostImpl _value,
      $Res Function(_$InsurancePlanCostImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? applicability = freezed,
    Object? qualifier = freezed,
    Object? value = freezed,
  }) {
    return _then(_$InsurancePlanCostImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      applicability: freezed == applicability
          ? _value.applicability
          : applicability // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
      qualifier: freezed == qualifier
          ? _value._qualifier
          : qualifier // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Quantity?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$InsurancePlanCostImpl extends _InsurancePlanCost {
  const _$InsurancePlanCostImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.applicability,
      final List<CodeableConcept>? qualifier,
      this.value})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _qualifier = qualifier,
        super._();

  factory _$InsurancePlanCostImpl.fromJson(Map<String, dynamic> json) =>
      _$$InsurancePlanCostImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  @override
  final String? id;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  final List<FhirExtension>? _extension_;

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Type of cost (copay; individual cap; family cap; coinsurance;
  ///  deductible).
  @override
  final CodeableConcept type;

  /// [applicability] Whether the cost applies to in-network or
  ///  out-of-network providers (in-network; out-of-network; other).
  @override
  final CodeableConcept? applicability;

  /// [qualifier] Additional information about the cost, such as information
  ///  about funding sources (e.g. HSA, HRA, FSA, RRA).
  final List<CodeableConcept>? _qualifier;

  /// [qualifier] Additional information about the cost, such as information
  ///  about funding sources (e.g. HSA, HRA, FSA, RRA).
  @override
  List<CodeableConcept>? get qualifier {
    final value = _qualifier;
    if (value == null) return null;
    if (_qualifier is EqualUnmodifiableListView) return _qualifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [value] The actual cost value. (some of the costs may be represented as
  ///  percentages rather than currency, e.g. 10% coinsurance).
  @override
  final Quantity? value;

  @override
  String toString() {
    return 'InsurancePlanCost(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, applicability: $applicability, qualifier: $qualifier, value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsurancePlanCostImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.applicability, applicability) ||
                other.applicability == applicability) &&
            const DeepCollectionEquality()
                .equals(other._qualifier, _qualifier) &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      applicability,
      const DeepCollectionEquality().hash(_qualifier),
      value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InsurancePlanCostImplCopyWith<_$InsurancePlanCostImpl> get copyWith =>
      __$$InsurancePlanCostImplCopyWithImpl<_$InsurancePlanCostImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InsurancePlanCostImplToJson(
      this,
    );
  }
}

abstract class _InsurancePlanCost extends InsurancePlanCost {
  const factory _InsurancePlanCost(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final CodeableConcept type,
      final CodeableConcept? applicability,
      final List<CodeableConcept>? qualifier,
      final Quantity? value}) = _$InsurancePlanCostImpl;
  const _InsurancePlanCost._() : super._();

  factory _InsurancePlanCost.fromJson(Map<String, dynamic> json) =
      _$InsurancePlanCostImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal
  ///  references). This may be any string value that does not contain spaces.
  String? get id;
  @override

  /// [extension_] ("extension") May be used to represent additional
  ///  information that is not part of the basic definition of the element.
  ///  To make the use of extensions safe and managable, there is a strict
  ///  set of governance applied to the definition and use of extensions.
  ///  Though any implementer can define an extension, there is a set of
  ///  requirements that SHALL be met as part of the definition of the
  ///  extension.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information
  ///  that is not part of the basic definition of the element and that
  ///  modifies the understanding of the element in which it is contained
  ///  and/or the understanding of the containing element's descendants.
  ///  Usually modifier elements provide negation or qualification. To make
  ///  the use of extensions safe and managable, there is a strict set of
  ///  governance applied to the definition and use of extensions. Though any
  ///  implementer can define an extension, there is a set of requirements
  ///  that SHALL be met as part of the definition of the extension.
  ///  Applications processing a resource are required to check for modifier
  ///  extensions.Modifier extensions SHALL NOT change the meaning of any
  ///  elements on Resource or DomainResource (including cannot change the
  ///  meaning of modifierExtension itself).
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Type of cost (copay; individual cap; family cap; coinsurance;
  ///  deductible).
  CodeableConcept get type;
  @override

  /// [applicability] Whether the cost applies to in-network or
  ///  out-of-network providers (in-network; out-of-network; other).
  CodeableConcept? get applicability;
  @override

  /// [qualifier] Additional information about the cost, such as information
  ///  about funding sources (e.g. HSA, HRA, FSA, RRA).
  List<CodeableConcept>? get qualifier;
  @override

  /// [value] The actual cost value. (some of the costs may be represented as
  ///  percentages rather than currency, e.g. 10% coinsurance).
  Quantity? get value;
  @override
  @JsonKey(ignore: true)
  _$$InsurancePlanCostImplCopyWith<_$InsurancePlanCostImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

InsuranceProduct _$InsuranceProductFromJson(Map<String, dynamic> json) {
  return _InsuranceProduct.fromJson(json);
}

/// @nodoc
mixin _$InsuranceProduct {
  /// This is a InsuranceProduct resource
  @JsonKey(unknownEnumValue: R6ResourceType.InsuranceProduct)
  R6ResourceType get resourceType => throw _privateConstructorUsedError;

  /// The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id => throw _privateConstructorUsedError;

  /// The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  FhirMeta? get meta => throw _privateConstructorUsedError;

  /// A reference to a set of rules that were followed when the
  /// resource was constructed, and which must be understood when processing
  /// the content. Often, this is a reference to an implementation guide that
  /// defines the special rules along with other profiles etc.
  FhirUri? get implicitRules => throw _privateConstructorUsedError;

  /// Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement => throw _privateConstructorUsedError;

  /// The base language in which the resource is written.
  FhirCode? get language => throw _privateConstructorUsedError;

  /// Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement => throw _privateConstructorUsedError;

  /// A human-readable narrative that contains a summary of the resource
  /// and can be used to represent the content of the resource to a human.
  Narrative? get text => throw _privateConstructorUsedError;

  /// These resources do not have an independent existence apart
  /// from the resource that contains them - they cannot be identified
  /// independently, nor can they have their own independent transaction
  /// scope.
  List<Resource>? get contained => throw _privateConstructorUsedError;

  /// May be used to represent additional information that is not part of
  /// the basic definition of the resource.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// May be used to represent additional information that is not part of
  /// the basic definition of the resource and that modifies the understanding
  /// of the element that contains it and/or the understanding of the
  /// containing element's descendants.
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// Business identifiers assigned to this health insurance product which
  /// remain constant as the resource is updated and propagates from server to server.
  List<Identifier>? get identifier => throw _privateConstructorUsedError;

  /// The current state of the health insurance product.
  FhirCode? get status => throw _privateConstructorUsedError;

  /// Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement => throw _privateConstructorUsedError;

  /// The kind of health insurance product.
  List<CodeableConcept>? get type => throw _privateConstructorUsedError;

  /// Official name of the health insurance product as designated by the owner.
  String? get name => throw _privateConstructorUsedError;

  /// Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement => throw _privateConstructorUsedError;

  /// A list of alternate names that the product is known as, or was known as
  /// in the past.
  List<String>? get alias => throw _privateConstructorUsedError;

  /// Extensions for alias
  @JsonKey(name: '_alias')
  List<Element>? get aliasElement => throw _privateConstructorUsedError;

  /// The period of time that the health insurance product is available.
  Period? get period => throw _privateConstructorUsedError;

  /// The entity that is providing the health insurance product and underwriting
  /// the risk.
  Reference? get ownedBy => throw _privateConstructorUsedError;

  /// An organization which administer other services such as underwriting,
  /// customer service and/or claims processing on behalf of the health
  /// insurance product owner.
  Reference? get administeredBy => throw _privateConstructorUsedError;

  /// The geographic region in which a health insurance product's benefits apply.
  List<Reference>? get coverageArea => throw _privateConstructorUsedError;

  /// The contact details of communication devices available relevant to the
  /// specific Insurance Product.
  List<ExtendedContactDetail>? get contact =>
      throw _privateConstructorUsedError;

  /// The technical endpoints providing access to services operated for the
  /// health insurance product.
  List<Reference>? get endpoint => throw _privateConstructorUsedError;

  /// Reference to the network included in the health insurance product.
  List<Reference>? get network => throw _privateConstructorUsedError;

  /// Details about the coverage offered by the insurance product.
  List<InsuranceProductCoverage>? get coverage =>
      throw _privateConstructorUsedError;

  /// Another product that is related to this product.
  List<InsuranceProductRelated>? get related =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InsuranceProductCopyWith<InsuranceProduct> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InsuranceProductCopyWith<$Res> {
  factory $InsuranceProductCopyWith(
          InsuranceProduct value, $Res Function(InsuranceProduct) then) =
      _$InsuranceProductCopyWithImpl<$Res, InsuranceProduct>;
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.InsuranceProduct)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      FhirCode? status,
      @JsonKey(name: '_status') Element? statusElement,
      List<CodeableConcept>? type,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      List<String>? alias,
      @JsonKey(name: '_alias') List<Element>? aliasElement,
      Period? period,
      Reference? ownedBy,
      Reference? administeredBy,
      List<Reference>? coverageArea,
      List<ExtendedContactDetail>? contact,
      List<Reference>? endpoint,
      List<Reference>? network,
      List<InsuranceProductCoverage>? coverage,
      List<InsuranceProductRelated>? related});

  $FhirMetaCopyWith<$Res>? get meta;
  $ElementCopyWith<$Res>? get implicitRulesElement;
  $ElementCopyWith<$Res>? get languageElement;
  $NarrativeCopyWith<$Res>? get text;
  $ElementCopyWith<$Res>? get statusElement;
  $ElementCopyWith<$Res>? get nameElement;
  $PeriodCopyWith<$Res>? get period;
  $ReferenceCopyWith<$Res>? get ownedBy;
  $ReferenceCopyWith<$Res>? get administeredBy;
}

/// @nodoc
class _$InsuranceProductCopyWithImpl<$Res, $Val extends InsuranceProduct>
    implements $InsuranceProductCopyWith<$Res> {
  _$InsuranceProductCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? type = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? alias = freezed,
    Object? aliasElement = freezed,
    Object? period = freezed,
    Object? ownedBy = freezed,
    Object? administeredBy = freezed,
    Object? coverageArea = freezed,
    Object? contact = freezed,
    Object? endpoint = freezed,
    Object? network = freezed,
    Object? coverage = freezed,
    Object? related = freezed,
  }) {
    return _then(_value.copyWith(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value.contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value.identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      alias: freezed == alias
          ? _value.alias
          : alias // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      aliasElement: freezed == aliasElement
          ? _value.aliasElement
          : aliasElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      period: freezed == period
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as Period?,
      ownedBy: freezed == ownedBy
          ? _value.ownedBy
          : ownedBy // ignore: cast_nullable_to_non_nullable
              as Reference?,
      administeredBy: freezed == administeredBy
          ? _value.administeredBy
          : administeredBy // ignore: cast_nullable_to_non_nullable
              as Reference?,
      coverageArea: freezed == coverageArea
          ? _value.coverageArea
          : coverageArea // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      contact: freezed == contact
          ? _value.contact
          : contact // ignore: cast_nullable_to_non_nullable
              as List<ExtendedContactDetail>?,
      endpoint: freezed == endpoint
          ? _value.endpoint
          : endpoint // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      network: freezed == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      coverage: freezed == coverage
          ? _value.coverage
          : coverage // ignore: cast_nullable_to_non_nullable
              as List<InsuranceProductCoverage>?,
      related: freezed == related
          ? _value.related
          : related // ignore: cast_nullable_to_non_nullable
              as List<InsuranceProductRelated>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $FhirMetaCopyWith<$Res>? get meta {
    if (_value.meta == null) {
      return null;
    }

    return $FhirMetaCopyWith<$Res>(_value.meta!, (value) {
      return _then(_value.copyWith(meta: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get implicitRulesElement {
    if (_value.implicitRulesElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.implicitRulesElement!, (value) {
      return _then(_value.copyWith(implicitRulesElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get languageElement {
    if (_value.languageElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.languageElement!, (value) {
      return _then(_value.copyWith(languageElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $NarrativeCopyWith<$Res>? get text {
    if (_value.text == null) {
      return null;
    }

    return $NarrativeCopyWith<$Res>(_value.text!, (value) {
      return _then(_value.copyWith(text: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get statusElement {
    if (_value.statusElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.statusElement!, (value) {
      return _then(_value.copyWith(statusElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ElementCopyWith<$Res>? get nameElement {
    if (_value.nameElement == null) {
      return null;
    }

    return $ElementCopyWith<$Res>(_value.nameElement!, (value) {
      return _then(_value.copyWith(nameElement: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get period {
    if (_value.period == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.period!, (value) {
      return _then(_value.copyWith(period: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get ownedBy {
    if (_value.ownedBy == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.ownedBy!, (value) {
      return _then(_value.copyWith(ownedBy: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res>? get administeredBy {
    if (_value.administeredBy == null) {
      return null;
    }

    return $ReferenceCopyWith<$Res>(_value.administeredBy!, (value) {
      return _then(_value.copyWith(administeredBy: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$InsuranceProductImplCopyWith<$Res>
    implements $InsuranceProductCopyWith<$Res> {
  factory _$$InsuranceProductImplCopyWith(_$InsuranceProductImpl value,
          $Res Function(_$InsuranceProductImpl) then) =
      __$$InsuranceProductImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(unknownEnumValue: R6ResourceType.InsuranceProduct)
      R6ResourceType resourceType,
      FhirId? id,
      FhirMeta? meta,
      FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') Element? implicitRulesElement,
      FhirCode? language,
      @JsonKey(name: '_language') Element? languageElement,
      Narrative? text,
      List<Resource>? contained,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      List<Identifier>? identifier,
      FhirCode? status,
      @JsonKey(name: '_status') Element? statusElement,
      List<CodeableConcept>? type,
      String? name,
      @JsonKey(name: '_name') Element? nameElement,
      List<String>? alias,
      @JsonKey(name: '_alias') List<Element>? aliasElement,
      Period? period,
      Reference? ownedBy,
      Reference? administeredBy,
      List<Reference>? coverageArea,
      List<ExtendedContactDetail>? contact,
      List<Reference>? endpoint,
      List<Reference>? network,
      List<InsuranceProductCoverage>? coverage,
      List<InsuranceProductRelated>? related});

  @override
  $FhirMetaCopyWith<$Res>? get meta;
  @override
  $ElementCopyWith<$Res>? get implicitRulesElement;
  @override
  $ElementCopyWith<$Res>? get languageElement;
  @override
  $NarrativeCopyWith<$Res>? get text;
  @override
  $ElementCopyWith<$Res>? get statusElement;
  @override
  $ElementCopyWith<$Res>? get nameElement;
  @override
  $PeriodCopyWith<$Res>? get period;
  @override
  $ReferenceCopyWith<$Res>? get ownedBy;
  @override
  $ReferenceCopyWith<$Res>? get administeredBy;
}

/// @nodoc
class __$$InsuranceProductImplCopyWithImpl<$Res>
    extends _$InsuranceProductCopyWithImpl<$Res, _$InsuranceProductImpl>
    implements _$$InsuranceProductImplCopyWith<$Res> {
  __$$InsuranceProductImplCopyWithImpl(_$InsuranceProductImpl _value,
      $Res Function(_$InsuranceProductImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? resourceType = null,
    Object? id = freezed,
    Object? meta = freezed,
    Object? implicitRules = freezed,
    Object? implicitRulesElement = freezed,
    Object? language = freezed,
    Object? languageElement = freezed,
    Object? text = freezed,
    Object? contained = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? identifier = freezed,
    Object? status = freezed,
    Object? statusElement = freezed,
    Object? type = freezed,
    Object? name = freezed,
    Object? nameElement = freezed,
    Object? alias = freezed,
    Object? aliasElement = freezed,
    Object? period = freezed,
    Object? ownedBy = freezed,
    Object? administeredBy = freezed,
    Object? coverageArea = freezed,
    Object? contact = freezed,
    Object? endpoint = freezed,
    Object? network = freezed,
    Object? coverage = freezed,
    Object? related = freezed,
  }) {
    return _then(_$InsuranceProductImpl(
      resourceType: null == resourceType
          ? _value.resourceType
          : resourceType // ignore: cast_nullable_to_non_nullable
              as R6ResourceType,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as FhirId?,
      meta: freezed == meta
          ? _value.meta
          : meta // ignore: cast_nullable_to_non_nullable
              as FhirMeta?,
      implicitRules: freezed == implicitRules
          ? _value.implicitRules
          : implicitRules // ignore: cast_nullable_to_non_nullable
              as FhirUri?,
      implicitRulesElement: freezed == implicitRulesElement
          ? _value.implicitRulesElement
          : implicitRulesElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      language: freezed == language
          ? _value.language
          : language // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      languageElement: freezed == languageElement
          ? _value.languageElement
          : languageElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as Narrative?,
      contained: freezed == contained
          ? _value._contained
          : contained // ignore: cast_nullable_to_non_nullable
              as List<Resource>?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      identifier: freezed == identifier
          ? _value._identifier
          : identifier // ignore: cast_nullable_to_non_nullable
              as List<Identifier>?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as FhirCode?,
      statusElement: freezed == statusElement
          ? _value.statusElement
          : statusElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      type: freezed == type
          ? _value._type
          : type // ignore: cast_nullable_to_non_nullable
              as List<CodeableConcept>?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      nameElement: freezed == nameElement
          ? _value.nameElement
          : nameElement // ignore: cast_nullable_to_non_nullable
              as Element?,
      alias: freezed == alias
          ? _value._alias
          : alias // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      aliasElement: freezed == aliasElement
          ? _value._aliasElement
          : aliasElement // ignore: cast_nullable_to_non_nullable
              as List<Element>?,
      period: freezed == period
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as Period?,
      ownedBy: freezed == ownedBy
          ? _value.ownedBy
          : ownedBy // ignore: cast_nullable_to_non_nullable
              as Reference?,
      administeredBy: freezed == administeredBy
          ? _value.administeredBy
          : administeredBy // ignore: cast_nullable_to_non_nullable
              as Reference?,
      coverageArea: freezed == coverageArea
          ? _value._coverageArea
          : coverageArea // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      contact: freezed == contact
          ? _value._contact
          : contact // ignore: cast_nullable_to_non_nullable
              as List<ExtendedContactDetail>?,
      endpoint: freezed == endpoint
          ? _value._endpoint
          : endpoint // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      network: freezed == network
          ? _value._network
          : network // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      coverage: freezed == coverage
          ? _value._coverage
          : coverage // ignore: cast_nullable_to_non_nullable
              as List<InsuranceProductCoverage>?,
      related: freezed == related
          ? _value._related
          : related // ignore: cast_nullable_to_non_nullable
              as List<InsuranceProductRelated>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$InsuranceProductImpl extends _InsuranceProduct {
  const _$InsuranceProductImpl(
      {@JsonKey(unknownEnumValue: R6ResourceType.InsuranceProduct)
      this.resourceType = R6ResourceType.InsuranceProduct,
      this.id,
      this.meta,
      this.implicitRules,
      @JsonKey(name: '_implicitRules') this.implicitRulesElement,
      this.language,
      @JsonKey(name: '_language') this.languageElement,
      this.text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      this.status,
      @JsonKey(name: '_status') this.statusElement,
      final List<CodeableConcept>? type,
      this.name,
      @JsonKey(name: '_name') this.nameElement,
      final List<String>? alias,
      @JsonKey(name: '_alias') final List<Element>? aliasElement,
      this.period,
      this.ownedBy,
      this.administeredBy,
      final List<Reference>? coverageArea,
      final List<ExtendedContactDetail>? contact,
      final List<Reference>? endpoint,
      final List<Reference>? network,
      final List<InsuranceProductCoverage>? coverage,
      final List<InsuranceProductRelated>? related})
      : _contained = contained,
        _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _identifier = identifier,
        _type = type,
        _alias = alias,
        _aliasElement = aliasElement,
        _coverageArea = coverageArea,
        _contact = contact,
        _endpoint = endpoint,
        _network = network,
        _coverage = coverage,
        _related = related,
        super._();

  factory _$InsuranceProductImpl.fromJson(Map<String, dynamic> json) =>
      _$$InsuranceProductImplFromJson(json);

  /// This is a InsuranceProduct resource
  @override
  @JsonKey(unknownEnumValue: R6ResourceType.InsuranceProduct)
  final R6ResourceType resourceType;

  /// The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  @override
  final FhirId? id;

  /// The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  @override
  final FhirMeta? meta;

  /// A reference to a set of rules that were followed when the
  /// resource was constructed, and which must be understood when processing
  /// the content. Often, this is a reference to an implementation guide that
  /// defines the special rules along with other profiles etc.
  @override
  final FhirUri? implicitRules;

  /// Extensions for implicitRules
  @override
  @JsonKey(name: '_implicitRules')
  final Element? implicitRulesElement;

  /// The base language in which the resource is written.
  @override
  final FhirCode? language;

  /// Extensions for language
  @override
  @JsonKey(name: '_language')
  final Element? languageElement;

  /// A human-readable narrative that contains a summary of the resource
  /// and can be used to represent the content of the resource to a human.
  @override
  final Narrative? text;

  /// These resources do not have an independent existence apart
  /// from the resource that contains them - they cannot be identified
  /// independently, nor can they have their own independent transaction
  /// scope.
  final List<Resource>? _contained;

  /// These resources do not have an independent existence apart
  /// from the resource that contains them - they cannot be identified
  /// independently, nor can they have their own independent transaction
  /// scope.
  @override
  List<Resource>? get contained {
    final value = _contained;
    if (value == null) return null;
    if (_contained is EqualUnmodifiableListView) return _contained;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// May be used to represent additional information that is not part of
  /// the basic definition of the resource.
  final List<FhirExtension>? _extension_;

  /// May be used to represent additional information that is not part of
  /// the basic definition of the resource.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// May be used to represent additional information that is not part of
  /// the basic definition of the resource and that modifies the understanding
  /// of the element that contains it and/or the understanding of the
  /// containing element's descendants.
  final List<FhirExtension>? _modifierExtension;

  /// May be used to represent additional information that is not part of
  /// the basic definition of the resource and that modifies the understanding
  /// of the element that contains it and/or the understanding of the
  /// containing element's descendants.
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Business identifiers assigned to this health insurance product which
  /// remain constant as the resource is updated and propagates from server to server.
  final List<Identifier>? _identifier;

  /// Business identifiers assigned to this health insurance product which
  /// remain constant as the resource is updated and propagates from server to server.
  @override
  List<Identifier>? get identifier {
    final value = _identifier;
    if (value == null) return null;
    if (_identifier is EqualUnmodifiableListView) return _identifier;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The current state of the health insurance product.
  @override
  final FhirCode? status;

  /// Extensions for status
  @override
  @JsonKey(name: '_status')
  final Element? statusElement;

  /// The kind of health insurance product.
  final List<CodeableConcept>? _type;

  /// The kind of health insurance product.
  @override
  List<CodeableConcept>? get type {
    final value = _type;
    if (value == null) return null;
    if (_type is EqualUnmodifiableListView) return _type;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Official name of the health insurance product as designated by the owner.
  @override
  final String? name;

  /// Extensions for name
  @override
  @JsonKey(name: '_name')
  final Element? nameElement;

  /// A list of alternate names that the product is known as, or was known as
  /// in the past.
  final List<String>? _alias;

  /// A list of alternate names that the product is known as, or was known as
  /// in the past.
  @override
  List<String>? get alias {
    final value = _alias;
    if (value == null) return null;
    if (_alias is EqualUnmodifiableListView) return _alias;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Extensions for alias
  final List<Element>? _aliasElement;

  /// Extensions for alias
  @override
  @JsonKey(name: '_alias')
  List<Element>? get aliasElement {
    final value = _aliasElement;
    if (value == null) return null;
    if (_aliasElement is EqualUnmodifiableListView) return _aliasElement;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The period of time that the health insurance product is available.
  @override
  final Period? period;

  /// The entity that is providing the health insurance product and underwriting
  /// the risk.
  @override
  final Reference? ownedBy;

  /// An organization which administer other services such as underwriting,
  /// customer service and/or claims processing on behalf of the health
  /// insurance product owner.
  @override
  final Reference? administeredBy;

  /// The geographic region in which a health insurance product's benefits apply.
  final List<Reference>? _coverageArea;

  /// The geographic region in which a health insurance product's benefits apply.
  @override
  List<Reference>? get coverageArea {
    final value = _coverageArea;
    if (value == null) return null;
    if (_coverageArea is EqualUnmodifiableListView) return _coverageArea;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The contact details of communication devices available relevant to the
  /// specific Insurance Product.
  final List<ExtendedContactDetail>? _contact;

  /// The contact details of communication devices available relevant to the
  /// specific Insurance Product.
  @override
  List<ExtendedContactDetail>? get contact {
    final value = _contact;
    if (value == null) return null;
    if (_contact is EqualUnmodifiableListView) return _contact;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The technical endpoints providing access to services operated for the
  /// health insurance product.
  final List<Reference>? _endpoint;

  /// The technical endpoints providing access to services operated for the
  /// health insurance product.
  @override
  List<Reference>? get endpoint {
    final value = _endpoint;
    if (value == null) return null;
    if (_endpoint is EqualUnmodifiableListView) return _endpoint;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Reference to the network included in the health insurance product.
  final List<Reference>? _network;

  /// Reference to the network included in the health insurance product.
  @override
  List<Reference>? get network {
    final value = _network;
    if (value == null) return null;
    if (_network is EqualUnmodifiableListView) return _network;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Details about the coverage offered by the insurance product.
  final List<InsuranceProductCoverage>? _coverage;

  /// Details about the coverage offered by the insurance product.
  @override
  List<InsuranceProductCoverage>? get coverage {
    final value = _coverage;
    if (value == null) return null;
    if (_coverage is EqualUnmodifiableListView) return _coverage;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Another product that is related to this product.
  final List<InsuranceProductRelated>? _related;

  /// Another product that is related to this product.
  @override
  List<InsuranceProductRelated>? get related {
    final value = _related;
    if (value == null) return null;
    if (_related is EqualUnmodifiableListView) return _related;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'InsuranceProduct(resourceType: $resourceType, id: $id, meta: $meta, implicitRules: $implicitRules, implicitRulesElement: $implicitRulesElement, language: $language, languageElement: $languageElement, text: $text, contained: $contained, extension_: $extension_, modifierExtension: $modifierExtension, identifier: $identifier, status: $status, statusElement: $statusElement, type: $type, name: $name, nameElement: $nameElement, alias: $alias, aliasElement: $aliasElement, period: $period, ownedBy: $ownedBy, administeredBy: $administeredBy, coverageArea: $coverageArea, contact: $contact, endpoint: $endpoint, network: $network, coverage: $coverage, related: $related)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsuranceProductImpl &&
            (identical(other.resourceType, resourceType) ||
                other.resourceType == resourceType) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.meta, meta) || other.meta == meta) &&
            (identical(other.implicitRules, implicitRules) ||
                other.implicitRules == implicitRules) &&
            (identical(other.implicitRulesElement, implicitRulesElement) ||
                other.implicitRulesElement == implicitRulesElement) &&
            (identical(other.language, language) ||
                other.language == language) &&
            (identical(other.languageElement, languageElement) ||
                other.languageElement == languageElement) &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality()
                .equals(other._contained, _contained) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            const DeepCollectionEquality()
                .equals(other._identifier, _identifier) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.statusElement, statusElement) ||
                other.statusElement == statusElement) &&
            const DeepCollectionEquality().equals(other._type, _type) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nameElement, nameElement) ||
                other.nameElement == nameElement) &&
            const DeepCollectionEquality().equals(other._alias, _alias) &&
            const DeepCollectionEquality()
                .equals(other._aliasElement, _aliasElement) &&
            (identical(other.period, period) || other.period == period) &&
            (identical(other.ownedBy, ownedBy) || other.ownedBy == ownedBy) &&
            (identical(other.administeredBy, administeredBy) ||
                other.administeredBy == administeredBy) &&
            const DeepCollectionEquality()
                .equals(other._coverageArea, _coverageArea) &&
            const DeepCollectionEquality().equals(other._contact, _contact) &&
            const DeepCollectionEquality().equals(other._endpoint, _endpoint) &&
            const DeepCollectionEquality().equals(other._network, _network) &&
            const DeepCollectionEquality().equals(other._coverage, _coverage) &&
            const DeepCollectionEquality().equals(other._related, _related));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        resourceType,
        id,
        meta,
        implicitRules,
        implicitRulesElement,
        language,
        languageElement,
        text,
        const DeepCollectionEquality().hash(_contained),
        const DeepCollectionEquality().hash(_extension_),
        const DeepCollectionEquality().hash(_modifierExtension),
        const DeepCollectionEquality().hash(_identifier),
        status,
        statusElement,
        const DeepCollectionEquality().hash(_type),
        name,
        nameElement,
        const DeepCollectionEquality().hash(_alias),
        const DeepCollectionEquality().hash(_aliasElement),
        period,
        ownedBy,
        administeredBy,
        const DeepCollectionEquality().hash(_coverageArea),
        const DeepCollectionEquality().hash(_contact),
        const DeepCollectionEquality().hash(_endpoint),
        const DeepCollectionEquality().hash(_network),
        const DeepCollectionEquality().hash(_coverage),
        const DeepCollectionEquality().hash(_related)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InsuranceProductImplCopyWith<_$InsuranceProductImpl> get copyWith =>
      __$$InsuranceProductImplCopyWithImpl<_$InsuranceProductImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InsuranceProductImplToJson(
      this,
    );
  }
}

abstract class _InsuranceProduct extends InsuranceProduct {
  const factory _InsuranceProduct(
      {@JsonKey(unknownEnumValue: R6ResourceType.InsuranceProduct)
      final R6ResourceType resourceType,
      final FhirId? id,
      final FhirMeta? meta,
      final FhirUri? implicitRules,
      @JsonKey(name: '_implicitRules') final Element? implicitRulesElement,
      final FhirCode? language,
      @JsonKey(name: '_language') final Element? languageElement,
      final Narrative? text,
      final List<Resource>? contained,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final List<Identifier>? identifier,
      final FhirCode? status,
      @JsonKey(name: '_status') final Element? statusElement,
      final List<CodeableConcept>? type,
      final String? name,
      @JsonKey(name: '_name') final Element? nameElement,
      final List<String>? alias,
      @JsonKey(name: '_alias') final List<Element>? aliasElement,
      final Period? period,
      final Reference? ownedBy,
      final Reference? administeredBy,
      final List<Reference>? coverageArea,
      final List<ExtendedContactDetail>? contact,
      final List<Reference>? endpoint,
      final List<Reference>? network,
      final List<InsuranceProductCoverage>? coverage,
      final List<InsuranceProductRelated>? related}) = _$InsuranceProductImpl;
  const _InsuranceProduct._() : super._();

  factory _InsuranceProduct.fromJson(Map<String, dynamic> json) =
      _$InsuranceProductImpl.fromJson;

  @override

  /// This is a InsuranceProduct resource
  @JsonKey(unknownEnumValue: R6ResourceType.InsuranceProduct)
  R6ResourceType get resourceType;
  @override

  /// The logical id of the resource, as used in the URL for the resource.
  /// Once assigned, this value never changes.
  FhirId? get id;
  @override

  /// The metadata about the resource. This is content that is
  /// maintained by the infrastructure. Changes to the content might not
  /// always be associated with version changes to the resource.
  FhirMeta? get meta;
  @override

  /// A reference to a set of rules that were followed when the
  /// resource was constructed, and which must be understood when processing
  /// the content. Often, this is a reference to an implementation guide that
  /// defines the special rules along with other profiles etc.
  FhirUri? get implicitRules;
  @override

  /// Extensions for implicitRules
  @JsonKey(name: '_implicitRules')
  Element? get implicitRulesElement;
  @override

  /// The base language in which the resource is written.
  FhirCode? get language;
  @override

  /// Extensions for language
  @JsonKey(name: '_language')
  Element? get languageElement;
  @override

  /// A human-readable narrative that contains a summary of the resource
  /// and can be used to represent the content of the resource to a human.
  Narrative? get text;
  @override

  /// These resources do not have an independent existence apart
  /// from the resource that contains them - they cannot be identified
  /// independently, nor can they have their own independent transaction
  /// scope.
  List<Resource>? get contained;
  @override

  /// May be used to represent additional information that is not part of
  /// the basic definition of the resource.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// May be used to represent additional information that is not part of
  /// the basic definition of the resource and that modifies the understanding
  /// of the element that contains it and/or the understanding of the
  /// containing element's descendants.
  List<FhirExtension>? get modifierExtension;
  @override

  /// Business identifiers assigned to this health insurance product which
  /// remain constant as the resource is updated and propagates from server to server.
  List<Identifier>? get identifier;
  @override

  /// The current state of the health insurance product.
  FhirCode? get status;
  @override

  /// Extensions for status
  @JsonKey(name: '_status')
  Element? get statusElement;
  @override

  /// The kind of health insurance product.
  List<CodeableConcept>? get type;
  @override

  /// Official name of the health insurance product as designated by the owner.
  String? get name;
  @override

  /// Extensions for name
  @JsonKey(name: '_name')
  Element? get nameElement;
  @override

  /// A list of alternate names that the product is known as, or was known as
  /// in the past.
  List<String>? get alias;
  @override

  /// Extensions for alias
  @JsonKey(name: '_alias')
  List<Element>? get aliasElement;
  @override

  /// The period of time that the health insurance product is available.
  Period? get period;
  @override

  /// The entity that is providing the health insurance product and underwriting
  /// the risk.
  Reference? get ownedBy;
  @override

  /// An organization which administer other services such as underwriting,
  /// customer service and/or claims processing on behalf of the health
  /// insurance product owner.
  Reference? get administeredBy;
  @override

  /// The geographic region in which a health insurance product's benefits apply.
  List<Reference>? get coverageArea;
  @override

  /// The contact details of communication devices available relevant to the
  /// specific Insurance Product.
  List<ExtendedContactDetail>? get contact;
  @override

  /// The technical endpoints providing access to services operated for the
  /// health insurance product.
  List<Reference>? get endpoint;
  @override

  /// Reference to the network included in the health insurance product.
  List<Reference>? get network;
  @override

  /// Details about the coverage offered by the insurance product.
  List<InsuranceProductCoverage>? get coverage;
  @override

  /// Another product that is related to this product.
  List<InsuranceProductRelated>? get related;
  @override
  @JsonKey(ignore: true)
  _$$InsuranceProductImplCopyWith<_$InsuranceProductImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

InsuranceProductCoverage _$InsuranceProductCoverageFromJson(
    Map<String, dynamic> json) {
  return _InsuranceProductCoverage.fromJson(json);
}

/// @nodoc
mixin _$InsuranceProductCoverage {
  /// [id] Unique id for the element within a resource.
  String? get id => throw _privateConstructorUsedError;

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Type of coverage (e.g., Medical, Dental).
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [network] Reference to the network providing the type of coverage.
  List<Reference>? get network => throw _privateConstructorUsedError;

  /// [benefit] Specific benefits under this type of coverage.
  List<InsuranceProductBenefit>? get benefit =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InsuranceProductCoverageCopyWith<InsuranceProductCoverage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InsuranceProductCoverageCopyWith<$Res> {
  factory $InsuranceProductCoverageCopyWith(InsuranceProductCoverage value,
          $Res Function(InsuranceProductCoverage) then) =
      _$InsuranceProductCoverageCopyWithImpl<$Res, InsuranceProductCoverage>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      List<Reference>? network,
      List<InsuranceProductBenefit>? benefit});

  $CodeableConceptCopyWith<$Res> get type;
}

/// @nodoc
class _$InsuranceProductCoverageCopyWithImpl<$Res,
        $Val extends InsuranceProductCoverage>
    implements $InsuranceProductCoverageCopyWith<$Res> {
  _$InsuranceProductCoverageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? network = freezed,
    Object? benefit = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      network: freezed == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      benefit: freezed == benefit
          ? _value.benefit
          : benefit // ignore: cast_nullable_to_non_nullable
              as List<InsuranceProductBenefit>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$InsuranceProductCoverageImplCopyWith<$Res>
    implements $InsuranceProductCoverageCopyWith<$Res> {
  factory _$$InsuranceProductCoverageImplCopyWith(
          _$InsuranceProductCoverageImpl value,
          $Res Function(_$InsuranceProductCoverageImpl) then) =
      __$$InsuranceProductCoverageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      List<Reference>? network,
      List<InsuranceProductBenefit>? benefit});

  @override
  $CodeableConceptCopyWith<$Res> get type;
}

/// @nodoc
class __$$InsuranceProductCoverageImplCopyWithImpl<$Res>
    extends _$InsuranceProductCoverageCopyWithImpl<$Res,
        _$InsuranceProductCoverageImpl>
    implements _$$InsuranceProductCoverageImplCopyWith<$Res> {
  __$$InsuranceProductCoverageImplCopyWithImpl(
      _$InsuranceProductCoverageImpl _value,
      $Res Function(_$InsuranceProductCoverageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? network = freezed,
    Object? benefit = freezed,
  }) {
    return _then(_$InsuranceProductCoverageImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      network: freezed == network
          ? _value._network
          : network // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      benefit: freezed == benefit
          ? _value._benefit
          : benefit // ignore: cast_nullable_to_non_nullable
              as List<InsuranceProductBenefit>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$InsuranceProductCoverageImpl extends _InsuranceProductCoverage {
  _$InsuranceProductCoverageImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      final List<Reference>? network,
      final List<InsuranceProductBenefit>? benefit})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _network = network,
        _benefit = benefit,
        super._();

  factory _$InsuranceProductCoverageImpl.fromJson(Map<String, dynamic> json) =>
      _$$InsuranceProductCoverageImplFromJson(json);

  /// [id] Unique id for the element within a resource.
  @override
  final String? id;

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  final List<FhirExtension>? _extension_;

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Type of coverage (e.g., Medical, Dental).
  @override
  final CodeableConcept type;

  /// [network] Reference to the network providing the type of coverage.
  final List<Reference>? _network;

  /// [network] Reference to the network providing the type of coverage.
  @override
  List<Reference>? get network {
    final value = _network;
    if (value == null) return null;
    if (_network is EqualUnmodifiableListView) return _network;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [benefit] Specific benefits under this type of coverage.
  final List<InsuranceProductBenefit>? _benefit;

  /// [benefit] Specific benefits under this type of coverage.
  @override
  List<InsuranceProductBenefit>? get benefit {
    final value = _benefit;
    if (value == null) return null;
    if (_benefit is EqualUnmodifiableListView) return _benefit;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'InsuranceProductCoverage(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, network: $network, benefit: $benefit)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsuranceProductCoverageImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality().equals(other._network, _network) &&
            const DeepCollectionEquality().equals(other._benefit, _benefit));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      const DeepCollectionEquality().hash(_network),
      const DeepCollectionEquality().hash(_benefit));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InsuranceProductCoverageImplCopyWith<_$InsuranceProductCoverageImpl>
      get copyWith => __$$InsuranceProductCoverageImplCopyWithImpl<
          _$InsuranceProductCoverageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InsuranceProductCoverageImplToJson(
      this,
    );
  }
}

abstract class _InsuranceProductCoverage extends InsuranceProductCoverage {
  factory _InsuranceProductCoverage(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept type,
          final List<Reference>? network,
          final List<InsuranceProductBenefit>? benefit}) =
      _$InsuranceProductCoverageImpl;
  _InsuranceProductCoverage._() : super._();

  factory _InsuranceProductCoverage.fromJson(Map<String, dynamic> json) =
      _$InsuranceProductCoverageImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource.
  String? get id;
  @override

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Type of coverage (e.g., Medical, Dental).
  CodeableConcept get type;
  @override

  /// [network] Reference to the network providing the type of coverage.
  List<Reference>? get network;
  @override

  /// [benefit] Specific benefits under this type of coverage.
  List<InsuranceProductBenefit>? get benefit;
  @override
  @JsonKey(ignore: true)
  _$$InsuranceProductCoverageImplCopyWith<_$InsuranceProductCoverageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

InsuranceProductBenefit _$InsuranceProductBenefitFromJson(
    Map<String, dynamic> json) {
  return _InsuranceProductBenefit.fromJson(json);
}

/// @nodoc
mixin _$InsuranceProductBenefit {
  /// [id] Unique id for the element within a resource.
  String? get id => throw _privateConstructorUsedError;

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [type] Type of benefit (e.g., primary care, specialty care).
  CodeableConcept get type => throw _privateConstructorUsedError;

  /// [requirement] The referral requirements to have access/coverage for this benefit.
  String? get requirement => throw _privateConstructorUsedError;

  /// [limit] The specific limits on the benefit.
  List<InsuranceProductLimit>? get limit => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InsuranceProductBenefitCopyWith<InsuranceProductBenefit> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InsuranceProductBenefitCopyWith<$Res> {
  factory $InsuranceProductBenefitCopyWith(InsuranceProductBenefit value,
          $Res Function(InsuranceProductBenefit) then) =
      _$InsuranceProductBenefitCopyWithImpl<$Res, InsuranceProductBenefit>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      String? requirement,
      List<InsuranceProductLimit>? limit});

  $CodeableConceptCopyWith<$Res> get type;
}

/// @nodoc
class _$InsuranceProductBenefitCopyWithImpl<$Res,
        $Val extends InsuranceProductBenefit>
    implements $InsuranceProductBenefitCopyWith<$Res> {
  _$InsuranceProductBenefitCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? requirement = freezed,
    Object? limit = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      requirement: freezed == requirement
          ? _value.requirement
          : requirement // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as List<InsuranceProductLimit>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get type {
    return $CodeableConceptCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$InsuranceProductBenefitImplCopyWith<$Res>
    implements $InsuranceProductBenefitCopyWith<$Res> {
  factory _$$InsuranceProductBenefitImplCopyWith(
          _$InsuranceProductBenefitImpl value,
          $Res Function(_$InsuranceProductBenefitImpl) then) =
      __$$InsuranceProductBenefitImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      CodeableConcept type,
      String? requirement,
      List<InsuranceProductLimit>? limit});

  @override
  $CodeableConceptCopyWith<$Res> get type;
}

/// @nodoc
class __$$InsuranceProductBenefitImplCopyWithImpl<$Res>
    extends _$InsuranceProductBenefitCopyWithImpl<$Res,
        _$InsuranceProductBenefitImpl>
    implements _$$InsuranceProductBenefitImplCopyWith<$Res> {
  __$$InsuranceProductBenefitImplCopyWithImpl(
      _$InsuranceProductBenefitImpl _value,
      $Res Function(_$InsuranceProductBenefitImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? type = null,
    Object? requirement = freezed,
    Object? limit = freezed,
  }) {
    return _then(_$InsuranceProductBenefitImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      requirement: freezed == requirement
          ? _value.requirement
          : requirement // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: freezed == limit
          ? _value._limit
          : limit // ignore: cast_nullable_to_non_nullable
              as List<InsuranceProductLimit>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$InsuranceProductBenefitImpl extends _InsuranceProductBenefit {
  _$InsuranceProductBenefitImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.type,
      this.requirement,
      final List<InsuranceProductLimit>? limit})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        _limit = limit,
        super._();

  factory _$InsuranceProductBenefitImpl.fromJson(Map<String, dynamic> json) =>
      _$$InsuranceProductBenefitImplFromJson(json);

  /// [id] Unique id for the element within a resource.
  @override
  final String? id;

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  final List<FhirExtension>? _extension_;

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [type] Type of benefit (e.g., primary care, specialty care).
  @override
  final CodeableConcept type;

  /// [requirement] The referral requirements to have access/coverage for this benefit.
  @override
  final String? requirement;

  /// [limit] The specific limits on the benefit.
  final List<InsuranceProductLimit>? _limit;

  /// [limit] The specific limits on the benefit.
  @override
  List<InsuranceProductLimit>? get limit {
    final value = _limit;
    if (value == null) return null;
    if (_limit is EqualUnmodifiableListView) return _limit;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'InsuranceProductBenefit(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, type: $type, requirement: $requirement, limit: $limit)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsuranceProductBenefitImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.requirement, requirement) ||
                other.requirement == requirement) &&
            const DeepCollectionEquality().equals(other._limit, _limit));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      type,
      requirement,
      const DeepCollectionEquality().hash(_limit));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InsuranceProductBenefitImplCopyWith<_$InsuranceProductBenefitImpl>
      get copyWith => __$$InsuranceProductBenefitImplCopyWithImpl<
          _$InsuranceProductBenefitImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InsuranceProductBenefitImplToJson(
      this,
    );
  }
}

abstract class _InsuranceProductBenefit extends InsuranceProductBenefit {
  factory _InsuranceProductBenefit(
          {final String? id,
          @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
          final List<FhirExtension>? modifierExtension,
          required final CodeableConcept type,
          final String? requirement,
          final List<InsuranceProductLimit>? limit}) =
      _$InsuranceProductBenefitImpl;
  _InsuranceProductBenefit._() : super._();

  factory _InsuranceProductBenefit.fromJson(Map<String, dynamic> json) =
      _$InsuranceProductBenefitImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource.
  String? get id;
  @override

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  List<FhirExtension>? get modifierExtension;
  @override

  /// [type] Type of benefit (e.g., primary care, specialty care).
  CodeableConcept get type;
  @override

  /// [requirement] The referral requirements to have access/coverage for this benefit.
  String? get requirement;
  @override

  /// [limit] The specific limits on the benefit.
  List<InsuranceProductLimit>? get limit;
  @override
  @JsonKey(ignore: true)
  _$$InsuranceProductBenefitImplCopyWith<_$InsuranceProductBenefitImpl>
      get copyWith => throw _privateConstructorUsedError;
}

InsuranceProductLimit _$InsuranceProductLimitFromJson(
    Map<String, dynamic> json) {
  return _InsuranceProductLimit.fromJson(json);
}

/// @nodoc
mixin _$InsuranceProductLimit {
  /// [id] Unique id for the element within a resource.
  String? get id => throw _privateConstructorUsedError;

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [value] The maximum amount of a service item a plan will pay for a covered benefit.
  Quantity? get value => throw _privateConstructorUsedError;

  /// [code] The specific limit on the benefit.
  CodeableConcept? get code => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InsuranceProductLimitCopyWith<InsuranceProductLimit> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InsuranceProductLimitCopyWith<$Res> {
  factory $InsuranceProductLimitCopyWith(InsuranceProductLimit value,
          $Res Function(InsuranceProductLimit) then) =
      _$InsuranceProductLimitCopyWithImpl<$Res, InsuranceProductLimit>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Quantity? value,
      CodeableConcept? code});

  $QuantityCopyWith<$Res>? get value;
  $CodeableConceptCopyWith<$Res>? get code;
}

/// @nodoc
class _$InsuranceProductLimitCopyWithImpl<$Res,
        $Val extends InsuranceProductLimit>
    implements $InsuranceProductLimitCopyWith<$Res> {
  _$InsuranceProductLimitCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? value = freezed,
    Object? code = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $QuantityCopyWith<$Res>? get value {
    if (_value.value == null) {
      return null;
    }

    return $QuantityCopyWith<$Res>(_value.value!, (value) {
      return _then(_value.copyWith(value: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res>? get code {
    if (_value.code == null) {
      return null;
    }

    return $CodeableConceptCopyWith<$Res>(_value.code!, (value) {
      return _then(_value.copyWith(code: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$InsuranceProductLimitImplCopyWith<$Res>
    implements $InsuranceProductLimitCopyWith<$Res> {
  factory _$$InsuranceProductLimitImplCopyWith(
          _$InsuranceProductLimitImpl value,
          $Res Function(_$InsuranceProductLimitImpl) then) =
      __$$InsuranceProductLimitImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Quantity? value,
      CodeableConcept? code});

  @override
  $QuantityCopyWith<$Res>? get value;
  @override
  $CodeableConceptCopyWith<$Res>? get code;
}

/// @nodoc
class __$$InsuranceProductLimitImplCopyWithImpl<$Res>
    extends _$InsuranceProductLimitCopyWithImpl<$Res,
        _$InsuranceProductLimitImpl>
    implements _$$InsuranceProductLimitImplCopyWith<$Res> {
  __$$InsuranceProductLimitImplCopyWithImpl(_$InsuranceProductLimitImpl _value,
      $Res Function(_$InsuranceProductLimitImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? value = freezed,
    Object? code = freezed,
  }) {
    return _then(_$InsuranceProductLimitImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Quantity?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as CodeableConcept?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$InsuranceProductLimitImpl extends _InsuranceProductLimit {
  _$InsuranceProductLimitImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      this.value,
      this.code})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$InsuranceProductLimitImpl.fromJson(Map<String, dynamic> json) =>
      _$$InsuranceProductLimitImplFromJson(json);

  /// [id] Unique id for the element within a resource.
  @override
  final String? id;

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  final List<FhirExtension>? _extension_;

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [value] The maximum amount of a service item a plan will pay for a covered benefit.
  @override
  final Quantity? value;

  /// [code] The specific limit on the benefit.
  @override
  final CodeableConcept? code;

  @override
  String toString() {
    return 'InsuranceProductLimit(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, value: $value, code: $code)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsuranceProductLimitImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.code, code) || other.code == code));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      value,
      code);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InsuranceProductLimitImplCopyWith<_$InsuranceProductLimitImpl>
      get copyWith => __$$InsuranceProductLimitImplCopyWithImpl<
          _$InsuranceProductLimitImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InsuranceProductLimitImplToJson(
      this,
    );
  }
}

abstract class _InsuranceProductLimit extends InsuranceProductLimit {
  factory _InsuranceProductLimit(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      final Quantity? value,
      final CodeableConcept? code}) = _$InsuranceProductLimitImpl;
  _InsuranceProductLimit._() : super._();

  factory _InsuranceProductLimit.fromJson(Map<String, dynamic> json) =
      _$InsuranceProductLimitImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource.
  String? get id;
  @override

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  List<FhirExtension>? get modifierExtension;
  @override

  /// [value] The maximum amount of a service item a plan will pay for a covered benefit.
  Quantity? get value;
  @override

  /// [code] The specific limit on the benefit.
  CodeableConcept? get code;
  @override
  @JsonKey(ignore: true)
  _$$InsuranceProductLimitImplCopyWith<_$InsuranceProductLimitImpl>
      get copyWith => throw _privateConstructorUsedError;
}

InsuranceProductRelated _$InsuranceProductRelatedFromJson(
    Map<String, dynamic> json) {
  return _InsuranceProductRelated.fromJson(json);
}

/// @nodoc
mixin _$InsuranceProductRelated {
  /// [id] Unique id for the element within a resource (for internal references).
  String? get id => throw _privateConstructorUsedError;

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ => throw _privateConstructorUsedError;

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  List<FhirExtension>? get modifierExtension =>
      throw _privateConstructorUsedError;

  /// [product] The Related Product reference.
  Reference get product => throw _privateConstructorUsedError;

  /// [relationship] The relationship of this product to the related product.
  CodeableConcept get relationship => throw _privateConstructorUsedError;

  /// [period] Period of time that the product relationship is valid.
  Period? get period => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InsuranceProductRelatedCopyWith<InsuranceProductRelated> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InsuranceProductRelatedCopyWith<$Res> {
  factory $InsuranceProductRelatedCopyWith(InsuranceProductRelated value,
          $Res Function(InsuranceProductRelated) then) =
      _$InsuranceProductRelatedCopyWithImpl<$Res, InsuranceProductRelated>;
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference product,
      CodeableConcept relationship,
      Period? period});

  $ReferenceCopyWith<$Res> get product;
  $CodeableConceptCopyWith<$Res> get relationship;
  $PeriodCopyWith<$Res>? get period;
}

/// @nodoc
class _$InsuranceProductRelatedCopyWithImpl<$Res,
        $Val extends InsuranceProductRelated>
    implements $InsuranceProductRelatedCopyWith<$Res> {
  _$InsuranceProductRelatedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? product = null,
    Object? relationship = null,
    Object? period = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value.extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value.modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      product: null == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as Reference,
      relationship: null == relationship
          ? _value.relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      period: freezed == period
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as Period?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ReferenceCopyWith<$Res> get product {
    return $ReferenceCopyWith<$Res>(_value.product, (value) {
      return _then(_value.copyWith(product: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CodeableConceptCopyWith<$Res> get relationship {
    return $CodeableConceptCopyWith<$Res>(_value.relationship, (value) {
      return _then(_value.copyWith(relationship: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PeriodCopyWith<$Res>? get period {
    if (_value.period == null) {
      return null;
    }

    return $PeriodCopyWith<$Res>(_value.period!, (value) {
      return _then(_value.copyWith(period: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$InsuranceProductRelatedImplCopyWith<$Res>
    implements $InsuranceProductRelatedCopyWith<$Res> {
  factory _$$InsuranceProductRelatedImplCopyWith(
          _$InsuranceProductRelatedImpl value,
          $Res Function(_$InsuranceProductRelatedImpl) then) =
      __$$InsuranceProductRelatedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @JsonKey(name: 'extension') List<FhirExtension>? extension_,
      List<FhirExtension>? modifierExtension,
      Reference product,
      CodeableConcept relationship,
      Period? period});

  @override
  $ReferenceCopyWith<$Res> get product;
  @override
  $CodeableConceptCopyWith<$Res> get relationship;
  @override
  $PeriodCopyWith<$Res>? get period;
}

/// @nodoc
class __$$InsuranceProductRelatedImplCopyWithImpl<$Res>
    extends _$InsuranceProductRelatedCopyWithImpl<$Res,
        _$InsuranceProductRelatedImpl>
    implements _$$InsuranceProductRelatedImplCopyWith<$Res> {
  __$$InsuranceProductRelatedImplCopyWithImpl(
      _$InsuranceProductRelatedImpl _value,
      $Res Function(_$InsuranceProductRelatedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? extension_ = freezed,
    Object? modifierExtension = freezed,
    Object? product = null,
    Object? relationship = null,
    Object? period = freezed,
  }) {
    return _then(_$InsuranceProductRelatedImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      extension_: freezed == extension_
          ? _value._extension_
          : extension_ // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      modifierExtension: freezed == modifierExtension
          ? _value._modifierExtension
          : modifierExtension // ignore: cast_nullable_to_non_nullable
              as List<FhirExtension>?,
      product: null == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as Reference,
      relationship: null == relationship
          ? _value.relationship
          : relationship // ignore: cast_nullable_to_non_nullable
              as CodeableConcept,
      period: freezed == period
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as Period?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$InsuranceProductRelatedImpl extends _InsuranceProductRelated {
  _$InsuranceProductRelatedImpl(
      {this.id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required this.product,
      required this.relationship,
      this.period})
      : _extension_ = extension_,
        _modifierExtension = modifierExtension,
        super._();

  factory _$InsuranceProductRelatedImpl.fromJson(Map<String, dynamic> json) =>
      _$$InsuranceProductRelatedImplFromJson(json);

  /// [id] Unique id for the element within a resource (for internal references).
  @override
  final String? id;

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  final List<FhirExtension>? _extension_;

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  @override
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_ {
    final value = _extension_;
    if (value == null) return null;
    if (_extension_ is EqualUnmodifiableListView) return _extension_;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  final List<FhirExtension>? _modifierExtension;

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  @override
  List<FhirExtension>? get modifierExtension {
    final value = _modifierExtension;
    if (value == null) return null;
    if (_modifierExtension is EqualUnmodifiableListView)
      return _modifierExtension;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [product] The Related Product reference.
  @override
  final Reference product;

  /// [relationship] The relationship of this product to the related product.
  @override
  final CodeableConcept relationship;

  /// [period] Period of time that the product relationship is valid.
  @override
  final Period? period;

  @override
  String toString() {
    return 'InsuranceProductRelated(id: $id, extension_: $extension_, modifierExtension: $modifierExtension, product: $product, relationship: $relationship, period: $period)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InsuranceProductRelatedImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality()
                .equals(other._extension_, _extension_) &&
            const DeepCollectionEquality()
                .equals(other._modifierExtension, _modifierExtension) &&
            (identical(other.product, product) || other.product == product) &&
            (identical(other.relationship, relationship) ||
                other.relationship == relationship) &&
            (identical(other.period, period) || other.period == period));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_extension_),
      const DeepCollectionEquality().hash(_modifierExtension),
      product,
      relationship,
      period);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InsuranceProductRelatedImplCopyWith<_$InsuranceProductRelatedImpl>
      get copyWith => __$$InsuranceProductRelatedImplCopyWithImpl<
          _$InsuranceProductRelatedImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$InsuranceProductRelatedImplToJson(
      this,
    );
  }
}

abstract class _InsuranceProductRelated extends InsuranceProductRelated {
  factory _InsuranceProductRelated(
      {final String? id,
      @JsonKey(name: 'extension') final List<FhirExtension>? extension_,
      final List<FhirExtension>? modifierExtension,
      required final Reference product,
      required final CodeableConcept relationship,
      final Period? period}) = _$InsuranceProductRelatedImpl;
  _InsuranceProductRelated._() : super._();

  factory _InsuranceProductRelated.fromJson(Map<String, dynamic> json) =
      _$InsuranceProductRelatedImpl.fromJson;

  @override

  /// [id] Unique id for the element within a resource (for internal references).
  String? get id;
  @override

  /// [extension] May be used to represent additional information that is not part of the basic definition of the element.
  @JsonKey(name: 'extension')
  List<FhirExtension>? get extension_;
  @override

  /// [modifierExtension] May be used to represent additional information that modifies the understanding of the element.
  List<FhirExtension>? get modifierExtension;
  @override

  /// [product] The Related Product reference.
  Reference get product;
  @override

  /// [relationship] The relationship of this product to the related product.
  CodeableConcept get relationship;
  @override

  /// [period] Period of time that the product relationship is valid.
  Period? get period;
  @override
  @JsonKey(ignore: true)
  _$$InsuranceProductRelatedImplCopyWith<_$InsuranceProductRelatedImpl>
      get copyWith => throw _privateConstructorUsedError;
}
